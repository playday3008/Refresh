!function(t) {
    function e(i) {
        if (n[i])
            return n[i].exports;
        var r = n[i] = {
            exports: {},
            id: i,
            loaded: !1
        };
        return t[i].call(r.exports, r, r.exports, e),
        r.loaded = !0,
        r.exports
    }
    var i = window.webpackJsonp;
    window.webpackJsonp = function(a, o) {
        for (var s, l, h = 0, c = []; h < a.length; h++)
            l = a[h],
            r[l] && c.push.apply(c, r[l]),
            r[l] = 0;
        for (s in o) {
            var u = o[s];
            switch (typeof u) {
            case "object":
                t[s] = function(e) {
                    var i = e.slice(1)
                      , n = e[0];
                    return function(e, r, a) {
                        t[n].apply(this, [e, r, a].concat(i))
                    }
                }(u);
                break;
            case "function":
                t[s] = u;
                break;
            default:
                t[s] = t[u]
            }
        }
        for (i && i(a, o); c.length; )
            c.shift().call(null, e);
        if (o[0])
            return n[0] = 0,
            e(0)
    }
    ;
    var n = {}
      , r = {
        2: 0
    };
    return e.e = function(t, i) {
        if (0 === r[t])
            return i.call(null, e);
        if (void 0 !== r[t])
            r[t].push(i);
        else {
            r[t] = [i];
            var n = document.getElementsByTagName("head")[0]
              , a = document.createElement("script");
            a.type = "text/javascript",
            a.charset = "utf-8",
            a.async = !0,
            a.src = e.p + "" + t + "." + ({
                0: "Skull",
                1: "Landscape",
                3: "Templates",
                4: "bundle"
            }[t] || t) + ".js",
            n.appendChild(a)
        }
    }
    ,
    e.m = t,
    e.c = n,
    e.p = "",
    e(0)
}(function(t) {
    for (var e in t)
        if (Object.prototype.hasOwnProperty.call(t, e))
            switch (typeof t[e]) {
            case "function":
                break;
            case "object":
                t[e] = function(e) {
                    var i = e.slice(1)
                      , n = t[e[0]];
                    return function(t, e, r) {
                        n.apply(this, [t, e, r].concat(i))
                    }
                }(t[e]);
                break;
            default:
                t[e] = t[t[e]]
            }
    return t
}({
    0: function(t, e, i) {
        i(18),
        i(587),
        t.exports = i(217)
    },
    18: [612, 18],
    217: function(t, e, i) {
        var n, r;
        (function(i) {
            !function() {
                "use strict";
                var a = function() {
                    this.init()
                };
                a.prototype = {
                    init: function() {
                        var t = this || o;
                        return t._codecs = {},
                        t._howls = [],
                        t._muted = !1,
                        t._volume = 1,
                        t._canPlayEvent = "canplaythrough",
                        t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null,
                        t.masterGain = null,
                        t.noAudio = !1,
                        t.usingWebAudio = !0,
                        t.autoSuspend = !0,
                        t.ctx = null,
                        t.mobileAutoEnable = !0,
                        t._setup(),
                        t
                    },
                    volume: function(t) {
                        var e = this || o;
                        if (t = parseFloat(t),
                        e.ctx || f(),
                        "undefined" != typeof t && t >= 0 && t <= 1) {
                            if (e._volume = t,
                            e._muted)
                                return e;
                            e.usingWebAudio && (e.masterGain.gain.value = t);
                            for (var i = 0; i < e._howls.length; i++)
                                if (!e._howls[i]._webAudio)
                                    for (var n = e._howls[i]._getSoundIds(), r = 0; r < n.length; r++) {
                                        var a = e._howls[i]._soundById(n[r]);
                                        a && a._node && (a._node.volume = a._volume * t)
                                    }
                            return e
                        }
                        return e._volume
                    },
                    mute: function(t) {
                        var e = this || o;
                        e.ctx || f(),
                        e._muted = t,
                        e.usingWebAudio && (e.masterGain.gain.value = t ? 0 : e._volume);
                        for (var i = 0; i < e._howls.length; i++)
                            if (!e._howls[i]._webAudio)
                                for (var n = e._howls[i]._getSoundIds(), r = 0; r < n.length; r++) {
                                    var a = e._howls[i]._soundById(n[r]);
                                    a && a._node && (a._node.muted = !!t || a._muted)
                                }
                        return e
                    },
                    unload: function() {
                        for (var t = this || o, e = t._howls.length - 1; e >= 0; e--)
                            t._howls[e].unload();
                        return t.usingWebAudio && t.ctx && "undefined" != typeof t.ctx.close && (t.ctx.close(),
                        t.ctx = null,
                        f()),
                        t
                    },
                    codecs: function(t) {
                        return (this || o)._codecs[t.replace(/^x-/, "")]
                    },
                    _setup: function() {
                        var t = this || o;
                        if (t.state = t.ctx ? t.ctx.state || "running" : "running",
                        t._autoSuspend(),
                        !t.usingWebAudio)
                            if ("undefined" != typeof Audio)
                                try {
                                    var e = new Audio;
                                    "undefined" == typeof e.oncanplaythrough && (t._canPlayEvent = "canplay")
                                } catch (e) {
                                    t.noAudio = !0
                                }
                            else
                                t.noAudio = !0;
                        try {
                            var e = new Audio;
                            e.muted && (t.noAudio = !0)
                        } catch (t) {}
                        return t.noAudio || t._setupCodecs(),
                        t
                    },
                    _setupCodecs: function() {
                        var t = this || o
                          , e = null;
                        try {
                            e = "undefined" != typeof Audio ? new Audio : null
                        } catch (e) {
                            return t
                        }
                        if (!e || "function" != typeof e.canPlayType)
                            return t;
                        var i = e.canPlayType("audio/mpeg;").replace(/^no$/, "")
                          , n = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g)
                          , r = n && parseInt(n[0].split("/")[1], 10) < 33;
                        return t._codecs = {
                            mp3: !(r || !i && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
                            mpeg: !!i,
                            opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                            ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            wav: !!e.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
                            aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
                            caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                            m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                            webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                            dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                            flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
                        },
                        t
                    },
                    _enableMobileAudio: function() {
                        var t = this || o
                          , e = /iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(t._navigator && t._navigator.userAgent)
                          , i = !!("ontouchend"in window || t._navigator && t._navigator.maxTouchPoints > 0 || t._navigator && t._navigator.msMaxTouchPoints > 0);
                        if (!t._mobileEnabled && t.ctx && (e || i)) {
                            t._mobileEnabled = !1,
                            t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0,
                            t.unload()),
                            t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
                            var n = function() {
                                var e = t.ctx.createBufferSource();
                                e.buffer = t._scratchBuffer,
                                e.connect(t.ctx.destination),
                                "undefined" == typeof e.start ? e.noteOn(0) : e.start(0),
                                e.onended = function() {
                                    e.disconnect(0),
                                    t._mobileEnabled = !0,
                                    t.mobileAutoEnable = !1,
                                    document.removeEventListener("touchend", n, !0)
                                }
                            };
                            return document.addEventListener("touchend", n, !0),
                            t
                        }
                    },
                    _autoSuspend: function() {
                        var t = this;
                        if (t.autoSuspend && t.ctx && "undefined" != typeof t.ctx.suspend && o.usingWebAudio) {
                            for (var e = 0; e < t._howls.length; e++)
                                if (t._howls[e]._webAudio)
                                    for (var i = 0; i < t._howls[e]._sounds.length; i++)
                                        if (!t._howls[e]._sounds[i]._paused)
                                            return t;
                            return t._suspendTimer && clearTimeout(t._suspendTimer),
                            t._suspendTimer = setTimeout(function() {
                                t.autoSuspend && (t._suspendTimer = null,
                                t.state = "suspending",
                                t.ctx.suspend().then(function() {
                                    t.state = "suspended",
                                    t._resumeAfterSuspend && (delete t._resumeAfterSuspend,
                                    t._autoResume())
                                }))
                            }, 3e4),
                            t
                        }
                    },
                    _autoResume: function() {
                        var t = this;
                        if (t.ctx && "undefined" != typeof t.ctx.resume && o.usingWebAudio)
                            return "running" === t.state && t._suspendTimer ? (clearTimeout(t._suspendTimer),
                            t._suspendTimer = null) : "suspended" === t.state ? (t.state = "resuming",
                            t.ctx.resume().then(function() {
                                t.state = "running";
                                for (var e = 0; e < t._howls.length; e++)
                                    t._howls[e]._emit("resume")
                            }),
                            t._suspendTimer && (clearTimeout(t._suspendTimer),
                            t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0),
                            t
                    }
                };
                var o = new a
                  , s = function(t) {
                    var e = this;
                    return t.src && 0 !== t.src.length ? void e.init(t) : void console.error("An array of source files must be passed with any new Howl.")
                };
                s.prototype = {
                    init: function(t) {
                        var e = this;
                        return o.ctx || f(),
                        e._autoplay = t.autoplay || !1,
                        e._format = "string" != typeof t.format ? t.format : [t.format],
                        e._html5 = t.html5 || !1,
                        e._muted = t.mute || !1,
                        e._loop = t.loop || !1,
                        e._pool = t.pool || 5,
                        e._preload = "boolean" != typeof t.preload || t.preload,
                        e._rate = t.rate || 1,
                        e._sprite = t.sprite || {},
                        e._src = "string" != typeof t.src ? t.src : [t.src],
                        e._volume = void 0 !== t.volume ? t.volume : 1,
                        e._duration = 0,
                        e._state = "unloaded",
                        e._sounds = [],
                        e._endTimers = {},
                        e._queue = [],
                        e._onend = t.onend ? [{
                            fn: t.onend
                        }] : [],
                        e._onfade = t.onfade ? [{
                            fn: t.onfade
                        }] : [],
                        e._onload = t.onload ? [{
                            fn: t.onload
                        }] : [],
                        e._onloaderror = t.onloaderror ? [{
                            fn: t.onloaderror
                        }] : [],
                        e._onpause = t.onpause ? [{
                            fn: t.onpause
                        }] : [],
                        e._onplay = t.onplay ? [{
                            fn: t.onplay
                        }] : [],
                        e._onstop = t.onstop ? [{
                            fn: t.onstop
                        }] : [],
                        e._onmute = t.onmute ? [{
                            fn: t.onmute
                        }] : [],
                        e._onvolume = t.onvolume ? [{
                            fn: t.onvolume
                        }] : [],
                        e._onrate = t.onrate ? [{
                            fn: t.onrate
                        }] : [],
                        e._onseek = t.onseek ? [{
                            fn: t.onseek
                        }] : [],
                        e._onresume = [],
                        e._webAudio = o.usingWebAudio && !e._html5,
                        "undefined" != typeof o.ctx && o.ctx && o.mobileAutoEnable && o._enableMobileAudio(),
                        o._howls.push(e),
                        e._autoplay && e._queue.push({
                            event: "play",
                            action: function() {
                                e.play()
                            }
                        }),
                        e._preload && e.load(),
                        e
                    },
                    load: function() {
                        var t = this
                          , e = null;
                        if (o.noAudio)
                            return void t._emit("loaderror", null, "No audio support.");
                        "string" == typeof t._src && (t._src = [t._src]);
                        for (var i = 0; i < t._src.length; i++) {
                            var n, r;
                            if (t._format && t._format[i])
                                n = t._format[i];
                            else {
                                if (r = t._src[i],
                                "string" != typeof r) {
                                    t._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                    continue
                                }
                                n = /^data:audio\/([^;,]+);/i.exec(r),
                                n || (n = /\.([^.]+)$/.exec(r.split("?", 1)[0])),
                                n && (n = n[1].toLowerCase())
                            }
                            if (o.codecs(n)) {
                                e = t._src[i];
                                break
                            }
                        }
                        return e ? (t._src = e,
                        t._state = "loading",
                        "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (t._html5 = !0,
                        t._webAudio = !1),
                        new l(t),
                        t._webAudio && c(t),
                        t) : void t._emit("loaderror", null, "No codec support for selected audio sources.")
                    },
                    play: function(t, e) {
                        var i = this
                          , n = null;
                        if ("number" == typeof t)
                            n = t,
                            t = null;
                        else {
                            if ("string" == typeof t && "loaded" === i._state && !i._sprite[t])
                                return null;
                            if ("undefined" == typeof t) {
                                t = "__default";
                                for (var r = 0, a = 0; a < i._sounds.length; a++)
                                    i._sounds[a]._paused && !i._sounds[a]._ended && (r++,
                                    n = i._sounds[a]._id);
                                1 === r ? t = null : n = null
                            }
                        }
                        var s = n ? i._soundById(n) : i._inactiveSound();
                        if (!s)
                            return null;
                        if (n && !t && (t = s._sprite || "__default"),
                        "loaded" !== i._state && !i._sprite[t])
                            return i._queue.push({
                                event: "play",
                                action: function() {
                                    i.play(i._soundById(s._id) ? s._id : void 0)
                                }
                            }),
                            s._id;
                        if (n && !s._paused)
                            return e || setTimeout(function() {
                                i._emit("play", s._id)
                            }, 0),
                            s._id;
                        i._webAudio && o._autoResume();
                        var l = Math.max(0, s._seek > 0 ? s._seek : i._sprite[t][0] / 1e3)
                          , h = Math.max(0, (i._sprite[t][0] + i._sprite[t][1]) / 1e3 - l)
                          , c = 1e3 * h / Math.abs(s._rate);
                        s._paused = !1,
                        s._ended = !1,
                        s._sprite = t,
                        s._seek = l,
                        s._start = i._sprite[t][0] / 1e3,
                        s._stop = (i._sprite[t][0] + i._sprite[t][1]) / 1e3,
                        s._loop = !(!s._loop && !i._sprite[t][2]);
                        var u = s._node;
                        if (i._webAudio) {
                            var p = function() {
                                i._refreshBuffer(s);
                                var t = s._muted || i._muted ? 0 : s._volume;
                                u.gain.setValueAtTime(t, o.ctx.currentTime),
                                s._playStart = o.ctx.currentTime,
                                "undefined" == typeof u.bufferSource.start ? s._loop ? u.bufferSource.noteGrainOn(0, l, 86400) : u.bufferSource.noteGrainOn(0, l, h) : s._loop ? u.bufferSource.start(0, l, 86400) : u.bufferSource.start(0, l, h),
                                c !== 1 / 0 && (i._endTimers[s._id] = setTimeout(i._ended.bind(i, s), c)),
                                e || setTimeout(function() {
                                    i._emit("play", s._id)
                                }, 0)
                            }
                              , d = "running" === o.state;
                            "loaded" === i._state && d ? p() : (i.once(d ? "load" : "resume", p, d ? s._id : null),
                            i._clearTimer(s._id))
                        } else {
                            var f = function() {
                                u.currentTime = l,
                                u.muted = s._muted || i._muted || o._muted || u.muted,
                                u.volume = s._volume * o.volume(),
                                u.playbackRate = s._rate,
                                setTimeout(function() {
                                    u.play(),
                                    c !== 1 / 0 && (i._endTimers[s._id] = setTimeout(i._ended.bind(i, s), c)),
                                    e || i._emit("play", s._id)
                                }, 0)
                            }
                              , m = "loaded" === i._state && (window && window.ejecta || !u.readyState && o._navigator.isCocoonJS);
                            if (4 === u.readyState || m)
                                f();
                            else {
                                var g = function() {
                                    f(),
                                    u.removeEventListener(o._canPlayEvent, g, !1)
                                };
                                u.addEventListener(o._canPlayEvent, g, !1),
                                i._clearTimer(s._id)
                            }
                        }
                        return s._id
                    },
                    pause: function(t) {
                        var e = this;
                        if ("loaded" !== e._state)
                            return e._queue.push({
                                event: "pause",
                                action: function() {
                                    e.pause(t)
                                }
                            }),
                            e;
                        for (var i = e._getSoundIds(t), n = 0; n < i.length; n++) {
                            e._clearTimer(i[n]);
                            var r = e._soundById(i[n]);
                            if (r && !r._paused && (r._seek = e.seek(i[n]),
                            r._rateSeek = 0,
                            r._paused = !0,
                            e._stopFade(i[n]),
                            r._node))
                                if (e._webAudio) {
                                    if (!r._node.bufferSource)
                                        return e;
                                    "undefined" == typeof r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0),
                                    e._cleanBuffer(r._node)
                                } else
                                    isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                            arguments[1] || e._emit("pause", r ? r._id : null)
                        }
                        return e
                    },
                    stop: function(t, e) {
                        var i = this;
                        if ("loaded" !== i._state)
                            return i._queue.push({
                                event: "stop",
                                action: function() {
                                    i.stop(t)
                                }
                            }),
                            i;
                        for (var n = i._getSoundIds(t), r = 0; r < n.length; r++) {
                            i._clearTimer(n[r]);
                            var a = i._soundById(n[r]);
                            if (a && (a._seek = a._start || 0,
                            a._rateSeek = 0,
                            a._paused = !0,
                            a._ended = !0,
                            i._stopFade(n[r]),
                            a._node))
                                if (i._webAudio) {
                                    if (!a._node.bufferSource)
                                        return e || i._emit("stop", a._id),
                                        i;
                                    "undefined" == typeof a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0),
                                    i._cleanBuffer(a._node)
                                } else
                                    isNaN(a._node.duration) && a._node.duration !== 1 / 0 || (a._node.currentTime = a._start || 0,
                                    a._node.pause());
                            a && !e && i._emit("stop", a._id)
                        }
                        return i
                    },
                    mute: function(t, e) {
                        var i = this;
                        if ("loaded" !== i._state)
                            return i._queue.push({
                                event: "mute",
                                action: function() {
                                    i.mute(t, e)
                                }
                            }),
                            i;
                        if ("undefined" == typeof e) {
                            if ("boolean" != typeof t)
                                return i._muted;
                            i._muted = t
                        }
                        for (var n = i._getSoundIds(e), r = 0; r < n.length; r++) {
                            var a = i._soundById(n[r]);
                            a && (a._muted = t,
                            i._webAudio && a._node ? a._node.gain.setValueAtTime(t ? 0 : a._volume, o.ctx.currentTime) : a._node && (a._node.muted = !!o._muted || t),
                            i._emit("mute", a._id))
                        }
                        return i
                    },
                    volume: function() {
                        var t, e, i = this, n = arguments;
                        if (0 === n.length)
                            return i._volume;
                        if (1 === n.length || 2 === n.length && "undefined" == typeof n[1]) {
                            var r = i._getSoundIds()
                              , a = r.indexOf(n[0]);
                            a >= 0 ? e = parseInt(n[0], 10) : t = parseFloat(n[0])
                        } else
                            n.length >= 2 && (t = parseFloat(n[0]),
                            e = parseInt(n[1], 10));
                        var s;
                        if (!("undefined" != typeof t && t >= 0 && t <= 1))
                            return s = e ? i._soundById(e) : i._sounds[0],
                            s ? s._volume : 0;
                        if ("loaded" !== i._state)
                            return i._queue.push({
                                event: "volume",
                                action: function() {
                                    i.volume.apply(i, n)
                                }
                            }),
                            i;
                        "undefined" == typeof e && (i._volume = t),
                        e = i._getSoundIds(e);
                        for (var l = 0; l < e.length; l++)
                            s = i._soundById(e[l]),
                            s && (s._volume = t,
                            n[2] || i._stopFade(e[l]),
                            i._webAudio && s._node && !s._muted ? s._node.gain.setValueAtTime(t, o.ctx.currentTime) : s._node && !s._muted && (s._node.volume = t * o.volume()),
                            i._emit("volume", s._id));
                        return i
                    },
                    fade: function(t, e, i, n) {
                        var r = this
                          , a = Math.abs(t - e)
                          , s = t > e ? "out" : "in"
                          , l = a / .01
                          , h = l > 0 ? i / l : i;
                        if (h < 4 && (l = Math.ceil(l / (4 / h)),
                        h = 4),
                        "loaded" !== r._state)
                            return r._queue.push({
                                event: "fade",
                                action: function() {
                                    r.fade(t, e, i, n)
                                }
                            }),
                            r;
                        r.volume(t, n);
                        for (var c = r._getSoundIds(n), u = 0; u < c.length; u++) {
                            var p = r._soundById(c[u]);
                            if (p) {
                                if (n || r._stopFade(c[u]),
                                r._webAudio && !p._muted) {
                                    var d = o.ctx.currentTime
                                      , f = d + i / 1e3;
                                    p._volume = t,
                                    p._node.gain.setValueAtTime(t, d),
                                    p._node.gain.linearRampToValueAtTime(e, f)
                                }
                                var m = t;
                                p._interval = setInterval(function(t, i) {
                                    l > 0 && (m += "in" === s ? .01 : -.01),
                                    m = Math.max(0, m),
                                    m = Math.min(1, m),
                                    m = Math.round(100 * m) / 100,
                                    r._webAudio ? ("undefined" == typeof n && (r._volume = m),
                                    i._volume = m) : r.volume(m, t, !0),
                                    m === e && (clearInterval(i._interval),
                                    i._interval = null,
                                    r.volume(m, t),
                                    r._emit("fade", t))
                                }
                                .bind(r, c[u], p), h)
                            }
                        }
                        return r
                    },
                    _stopFade: function(t) {
                        var e = this
                          , i = e._soundById(t);
                        return i && i._interval && (e._webAudio && i._node.gain.cancelScheduledValues(o.ctx.currentTime),
                        clearInterval(i._interval),
                        i._interval = null,
                        e._emit("fade", t)),
                        e
                    },
                    loop: function() {
                        var t, e, i, n = this, r = arguments;
                        if (0 === r.length)
                            return n._loop;
                        if (1 === r.length) {
                            if ("boolean" != typeof r[0])
                                return i = n._soundById(parseInt(r[0], 10)),
                                !!i && i._loop;
                            t = r[0],
                            n._loop = t
                        } else
                            2 === r.length && (t = r[0],
                            e = parseInt(r[1], 10));
                        for (var a = n._getSoundIds(e), o = 0; o < a.length; o++)
                            i = n._soundById(a[o]),
                            i && (i._loop = t,
                            n._webAudio && i._node && i._node.bufferSource && (i._node.bufferSource.loop = t,
                            t && (i._node.bufferSource.loopStart = i._start || 0,
                            i._node.bufferSource.loopEnd = i._stop)));
                        return n
                    },
                    rate: function() {
                        var t, e, i = this, n = arguments;
                        if (0 === n.length)
                            e = i._sounds[0]._id;
                        else if (1 === n.length) {
                            var r = i._getSoundIds()
                              , a = r.indexOf(n[0]);
                            a >= 0 ? e = parseInt(n[0], 10) : t = parseFloat(n[0])
                        } else
                            2 === n.length && (t = parseFloat(n[0]),
                            e = parseInt(n[1], 10));
                        var s;
                        if ("number" != typeof t)
                            return s = i._soundById(e),
                            s ? s._rate : i._rate;
                        if ("loaded" !== i._state)
                            return i._queue.push({
                                event: "rate",
                                action: function() {
                                    i.rate.apply(i, n)
                                }
                            }),
                            i;
                        "undefined" == typeof e && (i._rate = t),
                        e = i._getSoundIds(e);
                        for (var l = 0; l < e.length; l++)
                            if (s = i._soundById(e[l])) {
                                s._rateSeek = i.seek(e[l]),
                                s._playStart = i._webAudio ? o.ctx.currentTime : s._playStart,
                                s._rate = t,
                                i._webAudio && s._node && s._node.bufferSource ? s._node.bufferSource.playbackRate.value = t : s._node && (s._node.playbackRate = t);
                                var h = i.seek(e[l])
                                  , c = (i._sprite[s._sprite][0] + i._sprite[s._sprite][1]) / 1e3 - h
                                  , u = 1e3 * c / Math.abs(s._rate);
                                !i._endTimers[e[l]] && s._paused || (i._clearTimer(e[l]),
                                i._endTimers[e[l]] = setTimeout(i._ended.bind(i, s), u)),
                                i._emit("rate", s._id)
                            }
                        return i
                    },
                    seek: function() {
                        var t, e, i = this, n = arguments;
                        if (0 === n.length)
                            e = i._sounds[0]._id;
                        else if (1 === n.length) {
                            var r = i._getSoundIds()
                              , a = r.indexOf(n[0]);
                            a >= 0 ? e = parseInt(n[0], 10) : (e = i._sounds[0]._id,
                            t = parseFloat(n[0]))
                        } else
                            2 === n.length && (t = parseFloat(n[0]),
                            e = parseInt(n[1], 10));
                        if ("undefined" == typeof e)
                            return i;
                        if ("loaded" !== i._state)
                            return i._queue.push({
                                event: "seek",
                                action: function() {
                                    i.seek.apply(i, n)
                                }
                            }),
                            i;
                        var s = i._soundById(e);
                        if (s) {
                            if (!("number" == typeof t && t >= 0)) {
                                if (i._webAudio) {
                                    var l = i.playing(e) ? o.ctx.currentTime - s._playStart : 0
                                      , h = s._rateSeek ? s._rateSeek - s._seek : 0;
                                    return s._seek + (h + l * Math.abs(s._rate))
                                }
                                return s._node.currentTime
                            }
                            var c = i.playing(e);
                            c && i.pause(e, !0),
                            s._seek = t,
                            s._ended = !1,
                            i._clearTimer(e),
                            c && i.play(e, !0),
                            !i._webAudio && s._node && (s._node.currentTime = t),
                            i._emit("seek", e)
                        }
                        return i
                    },
                    playing: function(t) {
                        var e = this;
                        if ("number" == typeof t) {
                            var i = e._soundById(t);
                            return !!i && !i._paused
                        }
                        for (var n = 0; n < e._sounds.length; n++)
                            if (!e._sounds[n]._paused)
                                return !0;
                        return !1
                    },
                    duration: function(t) {
                        var e = this
                          , i = e._duration
                          , n = e._soundById(t);
                        return n && (i = e._sprite[n._sprite][1] / 1e3),
                        i
                    },
                    state: function() {
                        return this._state
                    },
                    unload: function() {
                        for (var t = this, e = t._sounds, i = 0; i < e.length; i++) {
                            e[i]._paused || (t.stop(e[i]._id),
                            t._emit("end", e[i]._id)),
                            t._webAudio || (e[i]._node.src = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=",
                            e[i]._node.removeEventListener("error", e[i]._errorFn, !1),
                            e[i]._node.removeEventListener(o._canPlayEvent, e[i]._loadFn, !1)),
                            delete e[i]._node,
                            t._clearTimer(e[i]._id);
                            var n = o._howls.indexOf(t);
                            n >= 0 && o._howls.splice(n, 1)
                        }
                        var r = !0;
                        for (i = 0; i < o._howls.length; i++)
                            if (o._howls[i]._src === t._src) {
                                r = !1;
                                break
                            }
                        return h && r && delete h[t._src],
                        o.noAudio = !1,
                        t._state = "unloaded",
                        t._sounds = [],
                        t = null,
                        null
                    },
                    on: function(t, e, i, n) {
                        var r = this
                          , a = r["_on" + t];
                        return "function" == typeof e && a.push(n ? {
                            id: i,
                            fn: e,
                            once: n
                        } : {
                            id: i,
                            fn: e
                        }),
                        r
                    },
                    off: function(t, e, i) {
                        var n = this
                          , r = n["_on" + t]
                          , a = 0;
                        if (e) {
                            for (a = 0; a < r.length; a++)
                                if (e === r[a].fn && i === r[a].id) {
                                    r.splice(a, 1);
                                    break
                                }
                        } else if (t)
                            n["_on" + t] = [];
                        else {
                            var o = Object.keys(n);
                            for (a = 0; a < o.length; a++)
                                0 === o[a].indexOf("_on") && Array.isArray(n[o[a]]) && (n[o[a]] = [])
                        }
                        return n
                    },
                    once: function(t, e, i) {
                        var n = this;
                        return n.on(t, e, i, 1),
                        n
                    },
                    _emit: function(t, e, i) {
                        for (var n = this, r = n["_on" + t], a = r.length - 1; a >= 0; a--)
                            r[a].id && r[a].id !== e && "load" !== t || (setTimeout(function(t) {
                                t.call(this, e, i)
                            }
                            .bind(n, r[a].fn), 0),
                            r[a].once && n.off(t, r[a].fn, r[a].id));
                        return n
                    },
                    _loadQueue: function() {
                        var t = this;
                        if (t._queue.length > 0) {
                            var e = t._queue[0];
                            t.once(e.event, function() {
                                t._queue.shift(),
                                t._loadQueue()
                            }),
                            e.action()
                        }
                        return t
                    },
                    _ended: function(t) {
                        var e = this
                          , i = t._sprite
                          , n = !(!t._loop && !e._sprite[i][2]);
                        if (e._emit("end", t._id),
                        !e._webAudio && n && e.stop(t._id, !0).play(t._id),
                        e._webAudio && n) {
                            e._emit("play", t._id),
                            t._seek = t._start || 0,
                            t._rateSeek = 0,
                            t._playStart = o.ctx.currentTime;
                            var r = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
                            e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), r)
                        }
                        return e._webAudio && !n && (t._paused = !0,
                        t._ended = !0,
                        t._seek = t._start || 0,
                        t._rateSeek = 0,
                        e._clearTimer(t._id),
                        e._cleanBuffer(t._node),
                        o._autoSuspend()),
                        e._webAudio || n || e.stop(t._id),
                        e
                    },
                    _clearTimer: function(t) {
                        var e = this;
                        return e._endTimers[t] && (clearTimeout(e._endTimers[t]),
                        delete e._endTimers[t]),
                        e
                    },
                    _soundById: function(t) {
                        for (var e = this, i = 0; i < e._sounds.length; i++)
                            if (t === e._sounds[i]._id)
                                return e._sounds[i];
                        return null
                    },
                    _inactiveSound: function() {
                        var t = this;
                        t._drain();
                        for (var e = 0; e < t._sounds.length; e++)
                            if (t._sounds[e]._ended)
                                return t._sounds[e].reset();
                        return new l(t)
                    },
                    _drain: function() {
                        var t = this
                          , e = t._pool
                          , i = 0
                          , n = 0;
                        if (!(t._sounds.length < e)) {
                            for (n = 0; n < t._sounds.length; n++)
                                t._sounds[n]._ended && i++;
                            for (n = t._sounds.length - 1; n >= 0; n--) {
                                if (i <= e)
                                    return;
                                t._sounds[n]._ended && (t._webAudio && t._sounds[n]._node && t._sounds[n]._node.disconnect(0),
                                t._sounds.splice(n, 1),
                                i--)
                            }
                        }
                    },
                    _getSoundIds: function(t) {
                        var e = this;
                        if ("undefined" == typeof t) {
                            for (var i = [], n = 0; n < e._sounds.length; n++)
                                i.push(e._sounds[n]._id);
                            return i
                        }
                        return [t]
                    },
                    _refreshBuffer: function(t) {
                        var e = this;
                        return t._node.bufferSource = o.ctx.createBufferSource(),
                        t._node.bufferSource.buffer = h[e._src],
                        t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node),
                        t._node.bufferSource.loop = t._loop,
                        t._loop && (t._node.bufferSource.loopStart = t._start || 0,
                        t._node.bufferSource.loopEnd = t._stop),
                        t._node.bufferSource.playbackRate.value = t._rate,
                        e
                    },
                    _cleanBuffer: function(t) {
                        var e = this;
                        if (e._scratchBuffer) {
                            t.bufferSource.onended = null,
                            t.bufferSource.disconnect(0);
                            try {
                                t.bufferSource.buffer = e._scratchBuffer
                            } catch (t) {}
                        }
                        return t.bufferSource = null,
                        e
                    }
                };
                var l = function(t) {
                    this._parent = t,
                    this.init()
                };
                l.prototype = {
                    init: function() {
                        var t = this
                          , e = t._parent;
                        return t._muted = e._muted,
                        t._loop = e._loop,
                        t._volume = e._volume,
                        t._muted = e._muted,
                        t._rate = e._rate,
                        t._seek = 0,
                        t._paused = !0,
                        t._ended = !0,
                        t._sprite = "__default",
                        t._id = Math.round(Date.now() * Math.random()),
                        e._sounds.push(t),
                        t.create(),
                        t
                    },
                    create: function() {
                        var t = this
                          , e = t._parent
                          , i = o._muted || t._muted || t._parent._muted ? 0 : t._volume;
                        return e._webAudio ? (t._node = "undefined" == typeof o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(),
                        t._node.gain.setValueAtTime(i, o.ctx.currentTime),
                        t._node.paused = !0,
                        t._node.connect(o.masterGain)) : (t._node = new Audio,
                        t._errorFn = t._errorListener.bind(t),
                        t._node.addEventListener("error", t._errorFn, !1),
                        t._loadFn = t._loadListener.bind(t),
                        t._node.addEventListener(o._canPlayEvent, t._loadFn, !1),
                        t._node.src = e._src,
                        t._node.preload = "auto",
                        t._node.volume = i * o.volume(),
                        t._node.load()),
                        t
                    },
                    reset: function() {
                        var t = this
                          , e = t._parent;
                        return t._muted = e._muted,
                        t._loop = e._loop,
                        t._volume = e._volume,
                        t._muted = e._muted,
                        t._rate = e._rate,
                        t._seek = 0,
                        t._rateSeek = 0,
                        t._paused = !0,
                        t._ended = !0,
                        t._sprite = "__default",
                        t._id = Math.round(Date.now() * Math.random()),
                        t
                    },
                    _errorListener: function() {
                        var t = this;
                        t._parent._emit("loaderror", t._id, t._node.error ? t._node.error.code : 0),
                        t._node.removeEventListener("error", t._errorListener, !1)
                    },
                    _loadListener: function() {
                        var t = this
                          , e = t._parent;
                        e._duration = Math.ceil(10 * t._node.duration) / 10,
                        0 === Object.keys(e._sprite).length && (e._sprite = {
                            __default: [0, 1e3 * e._duration]
                        }),
                        "loaded" !== e._state && (e._state = "loaded",
                        e._emit("load"),
                        e._loadQueue()),
                        t._node.removeEventListener(o._canPlayEvent, t._loadFn, !1)
                    }
                };
                var h = {}
                  , c = function(t) {
                    var e = t._src;
                    if (h[e])
                        return t._duration = h[e].duration,
                        void d(t);
                    if (/^data:[^;]+;base64,/.test(e)) {
                        for (var i = atob(e.split(",")[1]), n = new Uint8Array(i.length), r = 0; r < i.length; ++r)
                            n[r] = i.charCodeAt(r);
                        p(n.buffer, t)
                    } else {
                        var a = new XMLHttpRequest;
                        a.open("GET", e, !0),
                        a.responseType = "arraybuffer",
                        a.onload = function() {
                            var e = (a.status + "")[0];
                            return "0" !== e && "2" !== e && "3" !== e ? void t._emit("loaderror", null, "Failed loading audio file with status: " + a.status + ".") : void p(a.response, t)
                        }
                        ,
                        a.onerror = function() {
                            t._webAudio && (t._html5 = !0,
                            t._webAudio = !1,
                            t._sounds = [],
                            delete h[e],
                            t.load())
                        }
                        ,
                        u(a)
                    }
                }
                  , u = function(t) {
                    try {
                        t.send()
                    } catch (e) {
                        t.onerror()
                    }
                }
                  , p = function(t, e) {
                    o.ctx.decodeAudioData(t, function(t) {
                        t && e._sounds.length > 0 && (h[e._src] = t,
                        d(e, t))
                    }, function() {
                        e._emit("loaderror", null, "Decoding audio data failed.")
                    })
                }
                  , d = function(t, e) {
                    e && !t._duration && (t._duration = e.duration),
                    0 === Object.keys(t._sprite).length && (t._sprite = {
                        __default: [0, 1e3 * t._duration]
                    }),
                    "loaded" !== t._state && (t._state = "loaded",
                    t._emit("load"),
                    t._loadQueue())
                }
                  , f = function() {
                    try {
                        "undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1
                    } catch (t) {
                        o.usingWebAudio = !1
                    }
                    var t = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform)
                      , e = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
                      , i = e ? parseInt(e[1], 10) : null;
                    if (t && i && i < 9) {
                        var n = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                        (o._navigator && o._navigator.standalone && !n || o._navigator && !o._navigator.standalone && !n) && (o.usingWebAudio = !1)
                    }
                    o.usingWebAudio && (o.masterGain = "undefined" == typeof o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(),
                    o.masterGain.gain.value = 1,
                    o.masterGain.connect(o.ctx.destination)),
                    o._setup()
                };
                n = [],
                r = function() {
                    return {
                        Howler: o,
                        Howl: s
                    }
                }
                .apply(e, n),
                !(void 0 !== r && (t.exports = r)),
                e.Howler = o,
                e.Howl = s,
                "undefined" != typeof window ? (window.HowlerGlobal = a,
                window.Howler = o,
                window.Howl = s,
                window.Sound = l) : "undefined" != typeof i && (i.HowlerGlobal = a,
                i.Howler = o,
                i.Howl = s,
                i.Sound = l)
            }(),
            function() {
                "use strict";
                HowlerGlobal.prototype._pos = [0, 0, 0],
                HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
                HowlerGlobal.prototype.stereo = function(t) {
                    var e = this;
                    if (!e.ctx || !e.ctx.listener)
                        return e;
                    for (var i = e._howls.length - 1; i >= 0; i--)
                        e._howls[i].stereo(t);
                    return e
                }
                ,
                HowlerGlobal.prototype.pos = function(t, e, i) {
                    var n = this;
                    return n.ctx && n.ctx.listener ? (e = "number" != typeof e ? n._pos[1] : e,
                    i = "number" != typeof i ? n._pos[2] : i,
                    "number" != typeof t ? n._pos : (n._pos = [t, e, i],
                    n.ctx.listener.setPosition(n._pos[0], n._pos[1], n._pos[2]),
                    n)) : n
                }
                ,
                HowlerGlobal.prototype.orientation = function(t, e, i, n, r, a) {
                    var o = this;
                    if (!o.ctx || !o.ctx.listener)
                        return o;
                    var s = o._orientation;
                    return e = "number" != typeof e ? s[1] : e,
                    i = "number" != typeof i ? s[2] : i,
                    n = "number" != typeof n ? s[3] : n,
                    r = "number" != typeof r ? s[4] : r,
                    a = "number" != typeof a ? s[5] : a,
                    "number" != typeof t ? s : (o._orientation = [t, e, i, n, r, a],
                    o.ctx.listener.setOrientation(t, e, i, n, r, a),
                    o)
                }
                ,
                Howl.prototype.init = function(t) {
                    return function(e) {
                        var i = this;
                        return i._orientation = e.orientation || [1, 0, 0],
                        i._stereo = e.stereo || null,
                        i._pos = e.pos || null,
                        i._pannerAttr = {
                            coneInnerAngle: "undefined" != typeof e.coneInnerAngle ? e.coneInnerAngle : 360,
                            coneOuterAngle: "undefined" != typeof e.coneOuterAngle ? e.coneOuterAngle : 360,
                            coneOuterGain: "undefined" != typeof e.coneOuterGain ? e.coneOuterGain : 0,
                            distanceModel: "undefined" != typeof e.distanceModel ? e.distanceModel : "inverse",
                            maxDistance: "undefined" != typeof e.maxDistance ? e.maxDistance : 1e4,
                            panningModel: "undefined" != typeof e.panningModel ? e.panningModel : "HRTF",
                            refDistance: "undefined" != typeof e.refDistance ? e.refDistance : 1,
                            rolloffFactor: "undefined" != typeof e.rolloffFactor ? e.rolloffFactor : 1
                        },
                        i._onstereo = e.onstereo ? [{
                            fn: e.onstereo
                        }] : [],
                        i._onpos = e.onpos ? [{
                            fn: e.onpos
                        }] : [],
                        i._onorientation = e.onorientation ? [{
                            fn: e.onorientation
                        }] : [],
                        t.call(this, e)
                    }
                }(Howl.prototype.init),
                Howl.prototype.stereo = function(e, i) {
                    var n = this;
                    if (!n._webAudio)
                        return n;
                    if ("loaded" !== n._state)
                        return n._queue.push({
                            event: "stereo",
                            action: function() {
                                n.stereo(e, i)
                            }
                        }),
                        n;
                    var r = "undefined" == typeof Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                    if ("undefined" == typeof i) {
                        if ("number" != typeof e)
                            return n._stereo;
                        n._stereo = e,
                        n._pos = [e, 0, 0]
                    }
                    for (var a = n._getSoundIds(i), o = 0; o < a.length; o++) {
                        var s = n._soundById(a[o]);
                        if (s) {
                            if ("number" != typeof e)
                                return s._stereo;
                            s._stereo = e,
                            s._pos = [e, 0, 0],
                            s._node && (s._pannerAttr.panningModel = "equalpower",
                            s._panner && s._panner.pan || t(s, r),
                            "spatial" === r ? s._panner.setPosition(e, 0, 0) : s._panner.pan.value = e),
                            n._emit("stereo", s._id)
                        }
                    }
                    return n
                }
                ,
                Howl.prototype.pos = function(e, i, n, r) {
                    var a = this;
                    if (!a._webAudio)
                        return a;
                    if ("loaded" !== a._state)
                        return a._queue.push({
                            event: "pos",
                            action: function() {
                                a.pos(e, i, n, r)
                            }
                        }),
                        a;
                    if (i = "number" != typeof i ? 0 : i,
                    n = "number" != typeof n ? -.5 : n,
                    "undefined" == typeof r) {
                        if ("number" != typeof e)
                            return a._pos;
                        a._pos = [e, i, n]
                    }
                    for (var o = a._getSoundIds(r), s = 0; s < o.length; s++) {
                        var l = a._soundById(o[s]);
                        if (l) {
                            if ("number" != typeof e)
                                return l._pos;
                            l._pos = [e, i, n],
                            l._node && (l._panner && !l._panner.pan || t(l, "spatial"),
                            l._panner.setPosition(e, i, n)),
                            a._emit("pos", l._id)
                        }
                    }
                    return a
                }
                ,
                Howl.prototype.orientation = function(e, i, n, r) {
                    var a = this;
                    if (!a._webAudio)
                        return a;
                    if ("loaded" !== a._state)
                        return a._queue.push({
                            event: "orientation",
                            action: function() {
                                a.orientation(e, i, n, r)
                            }
                        }),
                        a;
                    if (i = "number" != typeof i ? a._orientation[1] : i,
                    n = "number" != typeof n ? a._orientation[2] : n,
                    "undefined" == typeof r) {
                        if ("number" != typeof e)
                            return a._orientation;
                        a._orientation = [e, i, n]
                    }
                    for (var o = a._getSoundIds(r), s = 0; s < o.length; s++) {
                        var l = a._soundById(o[s]);
                        if (l) {
                            if ("number" != typeof e)
                                return l._orientation;
                            l._orientation = [e, i, n],
                            l._node && (l._panner || (l._pos || (l._pos = a._pos || [0, 0, -.5]),
                            t(l, "spatial")),
                            l._panner.setOrientation(e, i, n)),
                            a._emit("orientation", l._id)
                        }
                    }
                    return a
                }
                ,
                Howl.prototype.pannerAttr = function() {
                    var e, i, n, r = this, a = arguments;
                    if (!r._webAudio)
                        return r;
                    if (0 === a.length)
                        return r._pannerAttr;
                    if (1 === a.length) {
                        if ("object" != typeof a[0])
                            return n = r._soundById(parseInt(a[0], 10)),
                            n ? n._pannerAttr : r._pannerAttr;
                        e = a[0],
                        "undefined" == typeof i && (r._pannerAttr = {
                            coneInnerAngle: "undefined" != typeof e.coneInnerAngle ? e.coneInnerAngle : r._coneInnerAngle,
                            coneOuterAngle: "undefined" != typeof e.coneOuterAngle ? e.coneOuterAngle : r._coneOuterAngle,
                            coneOuterGain: "undefined" != typeof e.coneOuterGain ? e.coneOuterGain : r._coneOuterGain,
                            distanceModel: "undefined" != typeof e.distanceModel ? e.distanceModel : r._distanceModel,
                            maxDistance: "undefined" != typeof e.maxDistance ? e.maxDistance : r._maxDistance,
                            panningModel: "undefined" != typeof e.panningModel ? e.panningModel : r._panningModel,
                            refDistance: "undefined" != typeof e.refDistance ? e.refDistance : r._refDistance,
                            rolloffFactor: "undefined" != typeof e.rolloffFactor ? e.rolloffFactor : r._rolloffFactor
                        })
                    } else
                        2 === a.length && (e = a[0],
                        i = parseInt(a[1], 10));
                    for (var o = r._getSoundIds(i), s = 0; s < o.length; s++)
                        if (n = r._soundById(o[s])) {
                            var l = n._pannerAttr;
                            l = {
                                coneInnerAngle: "undefined" != typeof e.coneInnerAngle ? e.coneInnerAngle : l.coneInnerAngle,
                                coneOuterAngle: "undefined" != typeof e.coneOuterAngle ? e.coneOuterAngle : l.coneOuterAngle,
                                coneOuterGain: "undefined" != typeof e.coneOuterGain ? e.coneOuterGain : l.coneOuterGain,
                                distanceModel: "undefined" != typeof e.distanceModel ? e.distanceModel : l.distanceModel,
                                maxDistance: "undefined" != typeof e.maxDistance ? e.maxDistance : l.maxDistance,
                                panningModel: "undefined" != typeof e.panningModel ? e.panningModel : l.panningModel,
                                refDistance: "undefined" != typeof e.refDistance ? e.refDistance : l.refDistance,
                                rolloffFactor: "undefined" != typeof e.rolloffFactor ? e.rolloffFactor : l.rolloffFactor
                            };
                            var h = n._panner;
                            h ? (h.coneInnerAngle = l.coneInnerAngle,
                            h.coneOuterAngle = l.coneOuterAngle,
                            h.coneOuterGain = l.coneOuterGain,
                            h.distanceModel = l.distanceModel,
                            h.maxDistance = l.maxDistance,
                            h.panningModel = l.panningModel,
                            h.refDistance = l.refDistance,
                            h.rolloffFactor = l.rolloffFactor) : (n._pos || (n._pos = r._pos || [0, 0, -.5]),
                            t(n, "spatial"))
                        }
                    return r
                }
                ,
                Sound.prototype.init = function(t) {
                    return function() {
                        var e = this
                          , i = e._parent;
                        e._orientation = i._orientation,
                        e._stereo = i._stereo,
                        e._pos = i._pos,
                        e._pannerAttr = i._pannerAttr,
                        t.call(this),
                        e._stereo ? i.stereo(e._stereo) : e._pos && i.pos(e._pos[0], e._pos[1], e._pos[2], e._id)
                    }
                }(Sound.prototype.init),
                Sound.prototype.reset = function(t) {
                    return function() {
                        var e = this
                          , i = e._parent;
                        return e._orientation = i._orientation,
                        e._pos = i._pos,
                        e._pannerAttr = i._pannerAttr,
                        t.call(this)
                    }
                }(Sound.prototype.reset);
                var t = function(t, e) {
                    e = e || "spatial",
                    "spatial" === e ? (t._panner = Howler.ctx.createPanner(),
                    t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle,
                    t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle,
                    t._panner.coneOuterGain = t._pannerAttr.coneOuterGain,
                    t._panner.distanceModel = t._pannerAttr.distanceModel,
                    t._panner.maxDistance = t._pannerAttr.maxDistance,
                    t._panner.panningModel = t._pannerAttr.panningModel,
                    t._panner.refDistance = t._pannerAttr.refDistance,
                    t._panner.rolloffFactor = t._pannerAttr.rolloffFactor,
                    t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]),
                    t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(),
                    t._panner.pan.value = t._stereo),
                    t._panner.connect(t._node),
                    t._paused || t._parent.pause(t._id, !0).play(t._id)
                }
            }()
        }
        ).call(e, function() {
            return this
        }())
    },
    587: function(t, e, i) {
        var n, r;
        (function(a) {
            var o = "undefined" != typeof t && t.exports && "undefined" != typeof a ? a : this || window;
            (o._gsQueue || (o._gsQueue = [])).push(function() {
                "use strict";
                o._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                    var n = function(t) {
                        var e, i = [], n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]))
                            ;
                        return i
                    }
                      , r = function(t, e, i) {
                        var n, r, a = t.cycle;
                        for (n in a)
                            r = a[n],
                            t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                        delete t.cycle
                    }
                      , a = function(t, e, n) {
                        i.call(this, t, e, n),
                        this._cycle = 0,
                        this._yoyo = this.vars.yoyo === !0,
                        this._repeat = this.vars.repeat || 0,
                        this._repeatDelay = this.vars.repeatDelay || 0,
                        this._dirty = !0,
                        this.render = a.prototype.render
                    }
                      , o = 1e-10
                      , s = i._internals
                      , l = s.isSelector
                      , h = s.isArray
                      , c = a.prototype = i.to({}, .1, {})
                      , u = [];
                    a.version = "1.19.1",
                    c.constructor = a,
                    c.kill()._gc = !1,
                    a.killTweensOf = a.killDelayedCallsTo = i.killTweensOf,
                    a.getTweensOf = i.getTweensOf,
                    a.lagSmoothing = i.lagSmoothing,
                    a.ticker = i.ticker,
                    a.render = i.render,
                    c.invalidate = function() {
                        return this._yoyo = this.vars.yoyo === !0,
                        this._repeat = this.vars.repeat || 0,
                        this._repeatDelay = this.vars.repeatDelay || 0,
                        this._uncache(!0),
                        i.prototype.invalidate.call(this)
                    }
                    ,
                    c.updateTo = function(t, e) {
                        var n, r = this.ratio, a = this.vars.immediateRender || t.immediateRender;
                        e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time,
                        this._uncache(!1),
                        this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                        for (n in t)
                            this.vars[n] = t[n];
                        if (this._initted || a)
                            if (e)
                                this._initted = !1,
                                a && this.render(0, !0, !0);
                            else if (this._gc && this._enabled(!0, !1),
                            this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this),
                            this._time / this._duration > .998) {
                                var o = this._totalTime;
                                this.render(0, !0, !1),
                                this._initted = !1,
                                this.render(o, !0, !1)
                            } else if (this._initted = !1,
                            this._init(),
                            this._time > 0 || a)
                                for (var s, l = 1 / (1 - r), h = this._firstPT; h; )
                                    s = h.s + h.c,
                                    h.c *= l,
                                    h.s = s - h.c,
                                    h = h._next;
                        return this
                    }
                    ,
                    c.render = function(t, e, i) {
                        this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                        var n, r, a, l, h, c, u, p, d = this._dirty ? this.totalDuration() : this._totalDuration, f = this._time, m = this._totalTime, g = this._cycle, v = this._duration, _ = this._rawPrevTime;
                        if (t >= d - 1e-7 && t >= 0 ? (this._totalTime = d,
                        this._cycle = this._repeat,
                        this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0,
                        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = v,
                        this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1),
                        this._reversed || (n = !0,
                        r = "onComplete",
                        i = i || this._timeline.autoRemoveChildren),
                        0 === v && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0),
                        (_ < 0 || t <= 0 && t >= -1e-7 || _ === o && "isPause" !== this.data) && _ !== t && (i = !0,
                        _ > o && (r = "onReverseComplete")),
                        this._rawPrevTime = p = !e || t || _ === t ? t : o)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0,
                        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
                        (0 !== m || 0 === v && _ > 0) && (r = "onReverseComplete",
                        n = this._reversed),
                        t < 0 && (this._active = !1,
                        0 === v && (this._initted || !this.vars.lazy || i) && (_ >= 0 && (i = !0),
                        this._rawPrevTime = p = !e || t || _ === t ? t : o)),
                        this._initted || (i = !0)) : (this._totalTime = this._time = t,
                        0 !== this._repeat && (l = v + this._repeatDelay,
                        this._cycle = this._totalTime / l >> 0,
                        0 !== this._cycle && this._cycle === this._totalTime / l && m <= t && this._cycle--,
                        this._time = this._totalTime - this._cycle * l,
                        this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time),
                        this._time > v ? this._time = v : this._time < 0 && (this._time = 0)),
                        this._easeType ? (h = this._time / v,
                        c = this._easeType,
                        u = this._easePower,
                        (1 === c || 3 === c && h >= .5) && (h = 1 - h),
                        3 === c && (h *= 2),
                        1 === u ? h *= h : 2 === u ? h *= h * h : 3 === u ? h *= h * h * h : 4 === u && (h *= h * h * h * h),
                        1 === c ? this.ratio = 1 - h : 2 === c ? this.ratio = h : this._time / v < .5 ? this.ratio = h / 2 : this.ratio = 1 - h / 2) : this.ratio = this._ease.getRatio(this._time / v)),
                        f === this._time && !i && g === this._cycle)
                            return void (m !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                        if (!this._initted) {
                            if (this._init(),
                            !this._initted || this._gc)
                                return;
                            if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
                                return this._time = f,
                                this._totalTime = m,
                                this._rawPrevTime = _,
                                this._cycle = g,
                                s.lazyTweens.push(this),
                                void (this._lazy = [t, e]);
                            this._time && !n ? this.ratio = this._ease.getRatio(this._time / v) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (this._lazy !== !1 && (this._lazy = !1),
                        this._active || !this._paused && this._time !== f && t >= 0 && (this._active = !0),
                        0 === m && (2 === this._initted && t > 0 && this._init(),
                        this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")),
                        this.vars.onStart && (0 === this._totalTime && 0 !== v || e || this._callback("onStart"))),
                        a = this._firstPT; a; )
                            a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s,
                            a = a._next;
                        this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, e, i),
                        e || (this._totalTime !== m || r) && this._callback("onUpdate")),
                        this._cycle !== g && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")),
                        r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i),
                        n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                        this._active = !1),
                        !e && this.vars[r] && this._callback(r),
                        0 === v && this._rawPrevTime === o && p !== o && (this._rawPrevTime = 0)))
                    }
                    ,
                    a.to = function(t, e, i) {
                        return new a(t,e,i)
                    }
                    ,
                    a.from = function(t, e, i) {
                        return i.runBackwards = !0,
                        i.immediateRender = 0 != i.immediateRender,
                        new a(t,e,i)
                    }
                    ,
                    a.fromTo = function(t, e, i, n) {
                        return n.startAt = i,
                        n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender,
                        new a(t,e,n)
                    }
                    ,
                    a.staggerTo = a.allTo = function(t, e, o, s, c, p, d) {
                        s = s || 0;
                        var f, m, g, v, _ = 0, y = [], x = function() {
                            o.onComplete && o.onComplete.apply(o.onCompleteScope || this, arguments),
                            c.apply(d || o.callbackScope || this, p || u)
                        }, b = o.cycle, w = o.startAt && o.startAt.cycle;
                        for (h(t) || ("string" == typeof t && (t = i.selector(t) || t),
                        l(t) && (t = n(t))),
                        t = t || [],
                        s < 0 && (t = n(t),
                        t.reverse(),
                        s *= -1),
                        f = t.length - 1,
                        g = 0; g <= f; g++) {
                            m = {};
                            for (v in o)
                                m[v] = o[v];
                            if (b && (r(m, t, g),
                            null != m.duration && (e = m.duration,
                            delete m.duration)),
                            w) {
                                w = m.startAt = {};
                                for (v in o.startAt)
                                    w[v] = o.startAt[v];
                                r(m.startAt, t, g)
                            }
                            m.delay = _ + (m.delay || 0),
                            g === f && c && (m.onComplete = x),
                            y[g] = new a(t[g],e,m),
                            _ += s
                        }
                        return y
                    }
                    ,
                    a.staggerFrom = a.allFrom = function(t, e, i, n, r, o, s) {
                        return i.runBackwards = !0,
                        i.immediateRender = 0 != i.immediateRender,
                        a.staggerTo(t, e, i, n, r, o, s)
                    }
                    ,
                    a.staggerFromTo = a.allFromTo = function(t, e, i, n, r, o, s, l) {
                        return n.startAt = i,
                        n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender,
                        a.staggerTo(t, e, n, r, o, s, l)
                    }
                    ,
                    a.delayedCall = function(t, e, i, n, r) {
                        return new a(e,0,{
                            delay: t,
                            onComplete: e,
                            onCompleteParams: i,
                            callbackScope: n,
                            onReverseComplete: e,
                            onReverseCompleteParams: i,
                            immediateRender: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }
                    ,
                    a.set = function(t, e) {
                        return new a(t,0,e)
                    }
                    ,
                    a.isTweening = function(t) {
                        return i.getTweensOf(t, !0).length > 0
                    }
                    ;
                    var p = function(t, e) {
                        for (var n = [], r = 0, a = t._first; a; )
                            a instanceof i ? n[r++] = a : (e && (n[r++] = a),
                            n = n.concat(p(a, e)),
                            r = n.length),
                            a = a._next;
                        return n
                    }
                      , d = a.getAllTweens = function(e) {
                        return p(t._rootTimeline, e).concat(p(t._rootFramesTimeline, e))
                    }
                    ;
                    a.killAll = function(t, i, n, r) {
                        null == i && (i = !0),
                        null == n && (n = !0);
                        var a, o, s, l = d(0 != r), h = l.length, c = i && n && r;
                        for (s = 0; s < h; s++)
                            o = l[s],
                            (c || o instanceof e || (a = o.target === o.vars.onComplete) && n || i && !a) && (t ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
                    }
                    ,
                    a.killChildTweensOf = function(t, e) {
                        if (null != t) {
                            var r, o, c, u, p, d = s.tweenLookup;
                            if ("string" == typeof t && (t = i.selector(t) || t),
                            l(t) && (t = n(t)),
                            h(t))
                                for (u = t.length; --u > -1; )
                                    a.killChildTweensOf(t[u], e);
                            else {
                                r = [];
                                for (c in d)
                                    for (o = d[c].target.parentNode; o; )
                                        o === t && (r = r.concat(d[c].tweens)),
                                        o = o.parentNode;
                                for (p = r.length,
                                u = 0; u < p; u++)
                                    e && r[u].totalTime(r[u].totalDuration()),
                                    r[u]._enabled(!1, !1)
                            }
                        }
                    }
                    ;
                    var f = function(t, i, n, r) {
                        i = i !== !1,
                        n = n !== !1,
                        r = r !== !1;
                        for (var a, o, s = d(r), l = i && n && r, h = s.length; --h > -1; )
                            o = s[h],
                            (l || o instanceof e || (a = o.target === o.vars.onComplete) && n || i && !a) && o.paused(t)
                    };
                    return a.pauseAll = function(t, e, i) {
                        f(!0, t, e, i)
                    }
                    ,
                    a.resumeAll = function(t, e, i) {
                        f(!1, t, e, i)
                    }
                    ,
                    a.globalTimeScale = function(e) {
                        var n = t._rootTimeline
                          , r = i.ticker.time;
                        return arguments.length ? (e = e || o,
                        n._startTime = r - (r - n._startTime) * n._timeScale / e,
                        n = t._rootFramesTimeline,
                        r = i.ticker.frame,
                        n._startTime = r - (r - n._startTime) * n._timeScale / e,
                        n._timeScale = t._rootTimeline._timeScale = e,
                        e) : n._timeScale
                    }
                    ,
                    c.progress = function(t, e) {
                        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                    }
                    ,
                    c.totalProgress = function(t, e) {
                        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                    }
                    ,
                    c.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(),
                        t > this._duration && (t = this._duration),
                        this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)),
                        this.totalTime(t, e)) : this._time
                    }
                    ,
                    c.duration = function(e) {
                        return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                    }
                    ,
                    c.totalDuration = function(t) {
                        return arguments.length ? this._repeat === -1 ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat,
                        this._dirty = !1),
                        this._totalDuration)
                    }
                    ,
                    c.repeat = function(t) {
                        return arguments.length ? (this._repeat = t,
                        this._uncache(!0)) : this._repeat
                    }
                    ,
                    c.repeatDelay = function(t) {
                        return arguments.length ? (this._repeatDelay = t,
                        this._uncache(!0)) : this._repeatDelay
                    }
                    ,
                    c.yoyo = function(t) {
                        return arguments.length ? (this._yoyo = t,
                        this) : this._yoyo
                    }
                    ,
                    a
                }, !0),
                o._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
                    var n = function(t) {
                        e.call(this, t),
                        this._labels = {},
                        this.autoRemoveChildren = this.vars.autoRemoveChildren === !0,
                        this.smoothChildTiming = this.vars.smoothChildTiming === !0,
                        this._sortChildren = !0,
                        this._onUpdate = this.vars.onUpdate;
                        var i, n, r = this.vars;
                        for (n in r)
                            i = r[n],
                            h(i) && i.join("").indexOf("{self}") !== -1 && (r[n] = this._swapSelfInParams(i));
                        h(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                    }
                      , r = 1e-10
                      , a = i._internals
                      , s = n._internals = {}
                      , l = a.isSelector
                      , h = a.isArray
                      , c = a.lazyTweens
                      , u = a.lazyRender
                      , p = o._gsDefine.globals
                      , d = function(t) {
                        var e, i = {};
                        for (e in t)
                            i[e] = t[e];
                        return i
                    }
                      , f = function(t, e, i) {
                        var n, r, a = t.cycle;
                        for (n in a)
                            r = a[n],
                            t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                        delete t.cycle
                    }
                      , m = s.pauseCallback = function() {}
                      , g = function(t) {
                        var e, i = [], n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]))
                            ;
                        return i
                    }
                      , v = n.prototype = new e;
                    return n.version = "1.19.1",
                    v.constructor = n,
                    v.kill()._gc = v._forcingPlayhead = v._hasPause = !1,
                    v.to = function(t, e, n, r) {
                        var a = n.repeat && p.TweenMax || i;
                        return e ? this.add(new a(t,e,n), r) : this.set(t, n, r)
                    }
                    ,
                    v.from = function(t, e, n, r) {
                        return this.add((n.repeat && p.TweenMax || i).from(t, e, n), r)
                    }
                    ,
                    v.fromTo = function(t, e, n, r, a) {
                        var o = r.repeat && p.TweenMax || i;
                        return e ? this.add(o.fromTo(t, e, n, r), a) : this.set(t, r, a)
                    }
                    ,
                    v.staggerTo = function(t, e, r, a, o, s, h, c) {
                        var u, p, m = new n({
                            onComplete: s,
                            onCompleteParams: h,
                            callbackScope: c,
                            smoothChildTiming: this.smoothChildTiming
                        }), v = r.cycle;
                        for ("string" == typeof t && (t = i.selector(t) || t),
                        t = t || [],
                        l(t) && (t = g(t)),
                        a = a || 0,
                        a < 0 && (t = g(t),
                        t.reverse(),
                        a *= -1),
                        p = 0; p < t.length; p++)
                            u = d(r),
                            u.startAt && (u.startAt = d(u.startAt),
                            u.startAt.cycle && f(u.startAt, t, p)),
                            v && (f(u, t, p),
                            null != u.duration && (e = u.duration,
                            delete u.duration)),
                            m.to(t[p], e, u, p * a);
                        return this.add(m, o)
                    }
                    ,
                    v.staggerFrom = function(t, e, i, n, r, a, o, s) {
                        return i.immediateRender = 0 != i.immediateRender,
                        i.runBackwards = !0,
                        this.staggerTo(t, e, i, n, r, a, o, s)
                    }
                    ,
                    v.staggerFromTo = function(t, e, i, n, r, a, o, s, l) {
                        return n.startAt = i,
                        n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender,
                        this.staggerTo(t, e, n, r, a, o, s, l)
                    }
                    ,
                    v.call = function(t, e, n, r) {
                        return this.add(i.delayedCall(0, t, e, n), r)
                    }
                    ,
                    v.set = function(t, e, n) {
                        return n = this._parseTimeOrLabel(n, 0, !0),
                        null == e.immediateRender && (e.immediateRender = n === this._time && !this._paused),
                        this.add(new i(t,0,e), n)
                    }
                    ,
                    n.exportRoot = function(t, e) {
                        t = t || {},
                        null == t.smoothChildTiming && (t.smoothChildTiming = !0);
                        var r, a, o = new n(t), s = o._timeline;
                        for (null == e && (e = !0),
                        s._remove(o, !0),
                        o._startTime = 0,
                        o._rawPrevTime = o._time = o._totalTime = s._time,
                        r = s._first; r; )
                            a = r._next,
                            e && r instanceof i && r.target === r.vars.onComplete || o.add(r, r._startTime - r._delay),
                            r = a;
                        return s.add(o, 0),
                        o
                    }
                    ,
                    v.add = function(r, a, o, s) {
                        var l, c, u, p, d, f;
                        if ("number" != typeof a && (a = this._parseTimeOrLabel(a, 0, !0, r)),
                        !(r instanceof t)) {
                            if (r instanceof Array || r && r.push && h(r)) {
                                for (o = o || "normal",
                                s = s || 0,
                                l = a,
                                c = r.length,
                                u = 0; u < c; u++)
                                    h(p = r[u]) && (p = new n({
                                        tweens: p
                                    })),
                                    this.add(p, l),
                                    "string" != typeof p && "function" != typeof p && ("sequence" === o ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === o && (p._startTime -= p.delay())),
                                    l += s;
                                return this._uncache(!0)
                            }
                            if ("string" == typeof r)
                                return this.addLabel(r, a);
                            if ("function" != typeof r)
                                throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                            r = i.delayedCall(0, r)
                        }
                        if (e.prototype.add.call(this, r, a),
                        (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                            for (d = this,
                            f = d.rawTime() > r._startTime; d._timeline; )
                                f && d._timeline.smoothChildTiming ? d.totalTime(d._totalTime, !0) : d._gc && d._enabled(!0, !1),
                                d = d._timeline;
                        return this
                    }
                    ,
                    v.remove = function(e) {
                        if (e instanceof t) {
                            this._remove(e, !1);
                            var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                            return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale,
                            this
                        }
                        if (e instanceof Array || e && e.push && h(e)) {
                            for (var n = e.length; --n > -1; )
                                this.remove(e[n]);
                            return this
                        }
                        return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                    }
                    ,
                    v._remove = function(t, i) {
                        e.prototype._remove.call(this, t, i);
                        var n = this._last;
                        return n ? this._time > this.duration() && (this._time = this._duration,
                        this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0,
                        this
                    }
                    ,
                    v.append = function(t, e) {
                        return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                    }
                    ,
                    v.insert = v.insertMultiple = function(t, e, i, n) {
                        return this.add(t, e || 0, i, n)
                    }
                    ,
                    v.appendMultiple = function(t, e, i, n) {
                        return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
                    }
                    ,
                    v.addLabel = function(t, e) {
                        return this._labels[t] = this._parseTimeOrLabel(e),
                        this
                    }
                    ,
                    v.addPause = function(t, e, n, r) {
                        var a = i.delayedCall(0, m, n, r || this);
                        return a.vars.onComplete = a.vars.onReverseComplete = e,
                        a.data = "isPause",
                        this._hasPause = !0,
                        this.add(a, t)
                    }
                    ,
                    v.removeLabel = function(t) {
                        return delete this._labels[t],
                        this
                    }
                    ,
                    v.getLabelTime = function(t) {
                        return null != this._labels[t] ? this._labels[t] : -1
                    }
                    ,
                    v._parseTimeOrLabel = function(e, i, n, r) {
                        var a;
                        if (r instanceof t && r.timeline === this)
                            this.remove(r);
                        else if (r && (r instanceof Array || r.push && h(r)))
                            for (a = r.length; --a > -1; )
                                r[a]instanceof t && r[a].timeline === this && this.remove(r[a]);
                        if ("string" == typeof i)
                            return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, n);
                        if (i = i || 0,
                        "string" != typeof e || !isNaN(e) && null == this._labels[e])
                            null == e && (e = this.duration());
                        else {
                            if (a = e.indexOf("="),
                            a === -1)
                                return null == this._labels[e] ? n ? this._labels[e] = this.duration() + i : i : this._labels[e] + i;
                            i = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)),
                            e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, n) : this.duration()
                        }
                        return Number(e) + i
                    }
                    ,
                    v.seek = function(t, e) {
                        return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1)
                    }
                    ,
                    v.stop = function() {
                        return this.paused(!0)
                    }
                    ,
                    v.gotoAndPlay = function(t, e) {
                        return this.play(t, e)
                    }
                    ,
                    v.gotoAndStop = function(t, e) {
                        return this.pause(t, e)
                    }
                    ,
                    v.render = function(t, e, i) {
                        this._gc && this._enabled(!0, !1);
                        var n, a, o, s, l, h, p, d = this._dirty ? this.totalDuration() : this._totalDuration, f = this._time, m = this._startTime, g = this._timeScale, v = this._paused;
                        if (t >= d - 1e-7 && t >= 0)
                            this._totalTime = this._time = d,
                            this._reversed || this._hasPausedChild() || (a = !0,
                            s = "onComplete",
                            l = !!this._timeline.autoRemoveChildren,
                            0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (l = !0,
                            this._rawPrevTime > r && (s = "onReverseComplete"))),
                            this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r,
                            t = d + 1e-4;
                        else if (t < 1e-7)
                            if (this._totalTime = this._time = 0,
                            (0 !== f || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (s = "onReverseComplete",
                            a = this._reversed),
                            t < 0)
                                this._active = !1,
                                this._timeline.autoRemoveChildren && this._reversed ? (l = a = !0,
                                s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0),
                                this._rawPrevTime = t;
                            else {
                                if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r,
                                0 === t && a)
                                    for (n = this._first; n && 0 === n._startTime; )
                                        n._duration || (a = !1),
                                        n = n._next;
                                t = 0,
                                this._initted || (l = !0)
                            }
                        else {
                            if (this._hasPause && !this._forcingPlayhead && !e) {
                                if (t >= f)
                                    for (n = this._first; n && n._startTime <= t && !h; )
                                        n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (h = n),
                                        n = n._next;
                                else
                                    for (n = this._last; n && n._startTime >= t && !h; )
                                        n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (h = n),
                                        n = n._prev;
                                h && (this._time = t = h._startTime,
                                this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                            }
                            this._totalTime = this._time = this._rawPrevTime = t
                        }
                        if (this._time !== f && this._first || i || l || h) {
                            if (this._initted || (this._initted = !0),
                            this._active || !this._paused && this._time !== f && t > 0 && (this._active = !0),
                            0 === f && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")),
                            p = this._time,
                            p >= f)
                                for (n = this._first; n && (o = n._next,
                                p === this._time && (!this._paused || v)); )
                                    (n._active || n._startTime <= p && !n._paused && !n._gc) && (h === n && this.pause(),
                                    n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)),
                                    n = o;
                            else
                                for (n = this._last; n && (o = n._prev,
                                p === this._time && (!this._paused || v)); ) {
                                    if (n._active || n._startTime <= f && !n._paused && !n._gc) {
                                        if (h === n) {
                                            for (h = n._prev; h && h.endTime() > this._time; )
                                                h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i),
                                                h = h._prev;
                                            h = null,
                                            this.pause()
                                        }
                                        n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                    }
                                    n = o
                                }
                            this._onUpdate && (e || (c.length && u(),
                            this._callback("onUpdate"))),
                            s && (this._gc || m !== this._startTime && g === this._timeScale || (0 === this._time || d >= this.totalDuration()) && (a && (c.length && u(),
                            this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                            this._active = !1),
                            !e && this.vars[s] && this._callback(s)))
                        }
                    }
                    ,
                    v._hasPausedChild = function() {
                        for (var t = this._first; t; ) {
                            if (t._paused || t instanceof n && t._hasPausedChild())
                                return !0;
                            t = t._next
                        }
                        return !1
                    }
                    ,
                    v.getChildren = function(t, e, n, r) {
                        r = r || -9999999999;
                        for (var a = [], o = this._first, s = 0; o; )
                            o._startTime < r || (o instanceof i ? e !== !1 && (a[s++] = o) : (n !== !1 && (a[s++] = o),
                            t !== !1 && (a = a.concat(o.getChildren(!0, e, n)),
                            s = a.length))),
                            o = o._next;
                        return a
                    }
                    ,
                    v.getTweensOf = function(t, e) {
                        var n, r, a = this._gc, o = [], s = 0;
                        for (a && this._enabled(!0, !0),
                        n = i.getTweensOf(t),
                        r = n.length; --r > -1; )
                            (n[r].timeline === this || e && this._contains(n[r])) && (o[s++] = n[r]);
                        return a && this._enabled(!1, !0),
                        o
                    }
                    ,
                    v.recent = function() {
                        return this._recent
                    }
                    ,
                    v._contains = function(t) {
                        for (var e = t.timeline; e; ) {
                            if (e === this)
                                return !0;
                            e = e.timeline
                        }
                        return !1
                    }
                    ,
                    v.shiftChildren = function(t, e, i) {
                        i = i || 0;
                        for (var n, r = this._first, a = this._labels; r; )
                            r._startTime >= i && (r._startTime += t),
                            r = r._next;
                        if (e)
                            for (n in a)
                                a[n] >= i && (a[n] += t);
                        return this._uncache(!0)
                    }
                    ,
                    v._kill = function(t, e) {
                        if (!t && !e)
                            return this._enabled(!1, !1);
                        for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1; )
                            i[n]._kill(t, e) && (r = !0);
                        return r
                    }
                    ,
                    v.clear = function(t) {
                        var e = this.getChildren(!1, !0, !0)
                          , i = e.length;
                        for (this._time = this._totalTime = 0; --i > -1; )
                            e[i]._enabled(!1, !1);
                        return t !== !1 && (this._labels = {}),
                        this._uncache(!0)
                    }
                    ,
                    v.invalidate = function() {
                        for (var e = this._first; e; )
                            e.invalidate(),
                            e = e._next;
                        return t.prototype.invalidate.call(this)
                    }
                    ,
                    v._enabled = function(t, i) {
                        if (t === this._gc)
                            for (var n = this._first; n; )
                                n._enabled(t, !0),
                                n = n._next;
                        return e.prototype._enabled.call(this, t, i)
                    }
                    ,
                    v.totalTime = function(e, i, n) {
                        this._forcingPlayhead = !0;
                        var r = t.prototype.totalTime.apply(this, arguments);
                        return this._forcingPlayhead = !1,
                        r
                    }
                    ,
                    v.duration = function(t) {
                        return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t),
                        this) : (this._dirty && this.totalDuration(),
                        this._duration)
                    }
                    ,
                    v.totalDuration = function(t) {
                        if (!arguments.length) {
                            if (this._dirty) {
                                for (var e, i, n = 0, r = this._last, a = 999999999999; r; )
                                    e = r._prev,
                                    r._dirty && r.totalDuration(),
                                    r._startTime > a && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : a = r._startTime,
                                    r._startTime < 0 && !r._paused && (n -= r._startTime,
                                    this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale),
                                    this.shiftChildren(-r._startTime, !1, -9999999999),
                                    a = 0),
                                    i = r._startTime + r._totalDuration / r._timeScale,
                                    i > n && (n = i),
                                    r = e;
                                this._duration = this._totalDuration = n,
                                this._dirty = !1
                            }
                            return this._totalDuration
                        }
                        return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
                    }
                    ,
                    v.paused = function(e) {
                        if (!e)
                            for (var i = this._first, n = this._time; i; )
                                i._startTime === n && "isPause" === i.data && (i._rawPrevTime = 0),
                                i = i._next;
                        return t.prototype.paused.apply(this, arguments)
                    }
                    ,
                    v.usesFrames = function() {
                        for (var e = this._timeline; e._timeline; )
                            e = e._timeline;
                        return e === t._rootFramesTimeline
                    }
                    ,
                    v.rawTime = function(t) {
                        return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
                    }
                    ,
                    n
                }, !0),
                o._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
                    var n = function(e) {
                        t.call(this, e),
                        this._repeat = this.vars.repeat || 0,
                        this._repeatDelay = this.vars.repeatDelay || 0,
                        this._cycle = 0,
                        this._yoyo = this.vars.yoyo === !0,
                        this._dirty = !0
                    }
                      , r = 1e-10
                      , a = e._internals
                      , s = a.lazyTweens
                      , l = a.lazyRender
                      , h = o._gsDefine.globals
                      , c = new i(null,null,1,0)
                      , u = n.prototype = new t;
                    return u.constructor = n,
                    u.kill()._gc = !1,
                    n.version = "1.19.1",
                    u.invalidate = function() {
                        return this._yoyo = this.vars.yoyo === !0,
                        this._repeat = this.vars.repeat || 0,
                        this._repeatDelay = this.vars.repeatDelay || 0,
                        this._uncache(!0),
                        t.prototype.invalidate.call(this)
                    }
                    ,
                    u.addCallback = function(t, i, n, r) {
                        return this.add(e.delayedCall(0, t, n, r), i)
                    }
                    ,
                    u.removeCallback = function(t, e) {
                        if (t)
                            if (null == e)
                                this._kill(null, t);
                            else
                                for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1; )
                                    i[n]._startTime === r && i[n]._enabled(!1, !1);
                        return this
                    }
                    ,
                    u.removePause = function(e) {
                        return this.removeCallback(t._internals.pauseCallback, e)
                    }
                    ,
                    u.tweenTo = function(t, i) {
                        i = i || {};
                        var n, r, a, o = {
                            ease: c,
                            useFrames: this.usesFrames(),
                            immediateRender: !1
                        }, s = i.repeat && h.TweenMax || e;
                        for (r in i)
                            o[r] = i[r];
                        return o.time = this._parseTimeOrLabel(t),
                        n = Math.abs(Number(o.time) - this._time) / this._timeScale || .001,
                        a = new s(this,n,o),
                        o.onStart = function() {
                            a.target.paused(!0),
                            a.vars.time !== a.target.time() && n === a.duration() && a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale),
                            i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || a, i.onStartParams || [])
                        }
                        ,
                        a
                    }
                    ,
                    u.tweenFromTo = function(t, e, i) {
                        i = i || {},
                        t = this._parseTimeOrLabel(t),
                        i.startAt = {
                            onComplete: this.seek,
                            onCompleteParams: [t],
                            callbackScope: this
                        },
                        i.immediateRender = i.immediateRender !== !1;
                        var n = this.tweenTo(e, i);
                        return n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
                    }
                    ,
                    u.render = function(t, e, i) {
                        this._gc && this._enabled(!0, !1);
                        var n, a, o, h, c, u, p, d, f = this._dirty ? this.totalDuration() : this._totalDuration, m = this._duration, g = this._time, v = this._totalTime, _ = this._startTime, y = this._timeScale, x = this._rawPrevTime, b = this._paused, w = this._cycle;
                        if (t >= f - 1e-7 && t >= 0)
                            this._locked || (this._totalTime = f,
                            this._cycle = this._repeat),
                            this._reversed || this._hasPausedChild() || (a = !0,
                            h = "onComplete",
                            c = !!this._timeline.autoRemoveChildren,
                            0 === this._duration && (t <= 0 && t >= -1e-7 || x < 0 || x === r) && x !== t && this._first && (c = !0,
                            x > r && (h = "onReverseComplete"))),
                            this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r,
                            this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = m,
                            t = m + 1e-4);
                        else if (t < 1e-7)
                            if (this._locked || (this._totalTime = this._cycle = 0),
                            this._time = 0,
                            (0 !== g || 0 === m && x !== r && (x > 0 || t < 0 && x >= 0) && !this._locked) && (h = "onReverseComplete",
                            a = this._reversed),
                            t < 0)
                                this._active = !1,
                                this._timeline.autoRemoveChildren && this._reversed ? (c = a = !0,
                                h = "onReverseComplete") : x >= 0 && this._first && (c = !0),
                                this._rawPrevTime = t;
                            else {
                                if (this._rawPrevTime = m || !e || t || this._rawPrevTime === t ? t : r,
                                0 === t && a)
                                    for (n = this._first; n && 0 === n._startTime; )
                                        n._duration || (a = !1),
                                        n = n._next;
                                t = 0,
                                this._initted || (c = !0)
                            }
                        else if (0 === m && x < 0 && (c = !0),
                        this._time = this._rawPrevTime = t,
                        this._locked || (this._totalTime = t,
                        0 !== this._repeat && (u = m + this._repeatDelay,
                        this._cycle = this._totalTime / u >> 0,
                        0 !== this._cycle && this._cycle === this._totalTime / u && v <= t && this._cycle--,
                        this._time = this._totalTime - this._cycle * u,
                        this._yoyo && 0 !== (1 & this._cycle) && (this._time = m - this._time),
                        this._time > m ? (this._time = m,
                        t = m + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)),
                        this._hasPause && !this._forcingPlayhead && !e && t < m) {
                            if (t = this._time,
                            t >= g || this._repeat && w !== this._cycle)
                                for (n = this._first; n && n._startTime <= t && !p; )
                                    n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (p = n),
                                    n = n._next;
                            else
                                for (n = this._last; n && n._startTime >= t && !p; )
                                    n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (p = n),
                                    n = n._prev;
                            p && (this._time = t = p._startTime,
                            this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                        }
                        if (this._cycle !== w && !this._locked) {
                            var M = this._yoyo && 0 !== (1 & w)
                              , T = M === (this._yoyo && 0 !== (1 & this._cycle))
                              , S = this._totalTime
                              , E = this._cycle
                              , A = this._rawPrevTime
                              , P = this._time;
                            if (this._totalTime = w * m,
                            this._cycle < w ? M = !M : this._totalTime += m,
                            this._time = g,
                            this._rawPrevTime = 0 === m ? x - 1e-4 : x,
                            this._cycle = w,
                            this._locked = !0,
                            g = M ? 0 : m,
                            this.render(g, e, 0 === m),
                            e || this._gc || this.vars.onRepeat && (this._cycle = E,
                            this._locked = !1,
                            this._callback("onRepeat")),
                            g !== this._time)
                                return;
                            if (T && (this._cycle = w,
                            this._locked = !0,
                            g = M ? m + 1e-4 : -1e-4,
                            this.render(g, !0, !1)),
                            this._locked = !1,
                            this._paused && !b)
                                return;
                            this._time = P,
                            this._totalTime = S,
                            this._cycle = E,
                            this._rawPrevTime = A
                        }
                        if (!(this._time !== g && this._first || i || c || p))
                            return void (v !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")));
                        if (this._initted || (this._initted = !0),
                        this._active || !this._paused && this._totalTime !== v && t > 0 && (this._active = !0),
                        0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")),
                        d = this._time,
                        d >= g)
                            for (n = this._first; n && (o = n._next,
                            d === this._time && (!this._paused || b)); )
                                (n._active || n._startTime <= this._time && !n._paused && !n._gc) && (p === n && this.pause(),
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)),
                                n = o;
                        else
                            for (n = this._last; n && (o = n._prev,
                            d === this._time && (!this._paused || b)); ) {
                                if (n._active || n._startTime <= g && !n._paused && !n._gc) {
                                    if (p === n) {
                                        for (p = n._prev; p && p.endTime() > this._time; )
                                            p.render(p._reversed ? p.totalDuration() - (t - p._startTime) * p._timeScale : (t - p._startTime) * p._timeScale, e, i),
                                            p = p._prev;
                                        p = null,
                                        this.pause()
                                    }
                                    n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                                }
                                n = o
                            }
                        this._onUpdate && (e || (s.length && l(),
                        this._callback("onUpdate"))),
                        h && (this._locked || this._gc || _ !== this._startTime && y === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (a && (s.length && l(),
                        this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                        this._active = !1),
                        !e && this.vars[h] && this._callback(h)))
                    }
                    ,
                    u.getActive = function(t, e, i) {
                        null == t && (t = !0),
                        null == e && (e = !0),
                        null == i && (i = !1);
                        var n, r, a = [], o = this.getChildren(t, e, i), s = 0, l = o.length;
                        for (n = 0; n < l; n++)
                            r = o[n],
                            r.isActive() && (a[s++] = r);
                        return a
                    }
                    ,
                    u.getLabelAfter = function(t) {
                        t || 0 !== t && (t = this._time);
                        var e, i = this.getLabelsArray(), n = i.length;
                        for (e = 0; e < n; e++)
                            if (i[e].time > t)
                                return i[e].name;
                        return null
                    }
                    ,
                    u.getLabelBefore = function(t) {
                        null == t && (t = this._time);
                        for (var e = this.getLabelsArray(), i = e.length; --i > -1; )
                            if (e[i].time < t)
                                return e[i].name;
                        return null
                    }
                    ,
                    u.getLabelsArray = function() {
                        var t, e = [], i = 0;
                        for (t in this._labels)
                            e[i++] = {
                                time: this._labels[t],
                                name: t
                            };
                        return e.sort(function(t, e) {
                            return t.time - e.time
                        }),
                        e
                    }
                    ,
                    u.invalidate = function() {
                        return this._locked = !1,
                        t.prototype.invalidate.call(this)
                    }
                    ,
                    u.progress = function(t, e) {
                        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
                    }
                    ,
                    u.totalProgress = function(t, e) {
                        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
                    }
                    ,
                    u.totalDuration = function(e) {
                        return arguments.length ? this._repeat !== -1 && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this),
                        this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat),
                        this._totalDuration)
                    }
                    ,
                    u.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(),
                        t > this._duration && (t = this._duration),
                        this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)),
                        this.totalTime(t, e)) : this._time
                    }
                    ,
                    u.repeat = function(t) {
                        return arguments.length ? (this._repeat = t,
                        this._uncache(!0)) : this._repeat
                    }
                    ,
                    u.repeatDelay = function(t) {
                        return arguments.length ? (this._repeatDelay = t,
                        this._uncache(!0)) : this._repeatDelay
                    }
                    ,
                    u.yoyo = function(t) {
                        return arguments.length ? (this._yoyo = t,
                        this) : this._yoyo
                    }
                    ,
                    u.currentLabel = function(t) {
                        return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                    }
                    ,
                    n
                }, !0),
                function() {
                    var t = 180 / Math.PI
                      , e = []
                      , i = []
                      , n = []
                      , r = {}
                      , a = o._gsDefine.globals
                      , s = function(t, e, i, n) {
                        i === n && (i = n - (n - e) / 1e6),
                        t === e && (e = t + (i - t) / 1e6),
                        this.a = t,
                        this.b = e,
                        this.c = i,
                        this.d = n,
                        this.da = n - t,
                        this.ca = i - t,
                        this.ba = e - t
                    }
                      , l = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,"
                      , h = function(t, e, i, n) {
                        var r = {
                            a: t
                        }
                          , a = {}
                          , o = {}
                          , s = {
                            c: n
                        }
                          , l = (t + e) / 2
                          , h = (e + i) / 2
                          , c = (i + n) / 2
                          , u = (l + h) / 2
                          , p = (h + c) / 2
                          , d = (p - u) / 8;
                        return r.b = l + (t - l) / 4,
                        a.b = u + d,
                        r.c = a.a = (r.b + a.b) / 2,
                        a.c = o.a = (u + p) / 2,
                        o.b = p - d,
                        s.b = c + (n - c) / 4,
                        o.c = s.a = (o.b + s.b) / 2,
                        [r, a, o, s]
                    }
                      , c = function(t, r, a, o, s) {
                        var l, c, u, p, d, f, m, g, v, _, y, x, b, w = t.length - 1, M = 0, T = t[0].a;
                        for (l = 0; l < w; l++)
                            d = t[M],
                            c = d.a,
                            u = d.d,
                            p = t[M + 1].d,
                            s ? (y = e[l],
                            x = i[l],
                            b = (x + y) * r * .25 / (o ? .5 : n[l] || .5),
                            f = u - (u - c) * (o ? .5 * r : 0 !== y ? b / y : 0),
                            m = u + (p - u) * (o ? .5 * r : 0 !== x ? b / x : 0),
                            g = u - (f + ((m - f) * (3 * y / (y + x) + .5) / 4 || 0))) : (f = u - (u - c) * r * .5,
                            m = u + (p - u) * r * .5,
                            g = u - (f + m) / 2),
                            f += g,
                            m += g,
                            d.c = v = f,
                            0 !== l ? d.b = T : d.b = T = d.a + .6 * (d.c - d.a),
                            d.da = u - c,
                            d.ca = v - c,
                            d.ba = T - c,
                            a ? (_ = h(c, T, v, u),
                            t.splice(M, 1, _[0], _[1], _[2], _[3]),
                            M += 4) : M++,
                            T = m;
                        d = t[M],
                        d.b = T,
                        d.c = T + .4 * (d.d - T),
                        d.da = d.d - d.a,
                        d.ca = d.c - d.a,
                        d.ba = T - d.a,
                        a && (_ = h(d.a, T, d.c, d.d),
                        t.splice(M, 1, _[0], _[1], _[2], _[3]))
                    }
                      , u = function(t, n, r, a) {
                        var o, l, h, c, u, p, d = [];
                        if (a)
                            for (t = [a].concat(t),
                            l = t.length; --l > -1; )
                                "string" == typeof (p = t[l][n]) && "=" === p.charAt(1) && (t[l][n] = a[n] + Number(p.charAt(0) + p.substr(2)));
                        if (o = t.length - 2,
                        o < 0)
                            return d[0] = new s(t[0][n],0,0,t[o < -1 ? 0 : 1][n]),
                            d;
                        for (l = 0; l < o; l++)
                            h = t[l][n],
                            c = t[l + 1][n],
                            d[l] = new s(h,0,0,c),
                            r && (u = t[l + 2][n],
                            e[l] = (e[l] || 0) + (c - h) * (c - h),
                            i[l] = (i[l] || 0) + (u - c) * (u - c));
                        return d[l] = new s(t[l][n],0,0,t[l + 1][n]),
                        d
                    }
                      , p = function(t, a, o, s, h, p) {
                        var d, f, m, g, v, _, y, x, b = {}, w = [], M = p || t[0];
                        h = "string" == typeof h ? "," + h + "," : l,
                        null == a && (a = 1);
                        for (f in t[0])
                            w.push(f);
                        if (t.length > 1) {
                            for (x = t[t.length - 1],
                            y = !0,
                            d = w.length; --d > -1; )
                                if (f = w[d],
                                Math.abs(M[f] - x[f]) > .05) {
                                    y = !1;
                                    break
                                }
                            y && (t = t.concat(),
                            p && t.unshift(p),
                            t.push(t[1]),
                            p = t[t.length - 3])
                        }
                        for (e.length = i.length = n.length = 0,
                        d = w.length; --d > -1; )
                            f = w[d],
                            r[f] = h.indexOf("," + f + ",") !== -1,
                            b[f] = u(t, f, r[f], p);
                        for (d = e.length; --d > -1; )
                            e[d] = Math.sqrt(e[d]),
                            i[d] = Math.sqrt(i[d]);
                        if (!s) {
                            for (d = w.length; --d > -1; )
                                if (r[f])
                                    for (m = b[w[d]],
                                    _ = m.length - 1,
                                    g = 0; g < _; g++)
                                        v = m[g + 1].da / i[g] + m[g].da / e[g] || 0,
                                        n[g] = (n[g] || 0) + v * v;
                            for (d = n.length; --d > -1; )
                                n[d] = Math.sqrt(n[d])
                        }
                        for (d = w.length,
                        g = o ? 4 : 1; --d > -1; )
                            f = w[d],
                            m = b[f],
                            c(m, a, o, s, r[f]),
                            y && (m.splice(0, g),
                            m.splice(m.length - g, g));
                        return b
                    }
                      , d = function(t, e, i) {
                        e = e || "soft";
                        var n, r, a, o, l, h, c, u, p, d, f, m = {}, g = "cubic" === e ? 3 : 2, v = "soft" === e, _ = [];
                        if (v && i && (t = [i].concat(t)),
                        null == t || t.length < g + 1)
                            throw "invalid Bezier data";
                        for (p in t[0])
                            _.push(p);
                        for (h = _.length; --h > -1; ) {
                            for (p = _[h],
                            m[p] = l = [],
                            d = 0,
                            u = t.length,
                            c = 0; c < u; c++)
                                n = null == i ? t[c][p] : "string" == typeof (f = t[c][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f),
                                v && c > 1 && c < u - 1 && (l[d++] = (n + l[d - 2]) / 2),
                                l[d++] = n;
                            for (u = d - g + 1,
                            d = 0,
                            c = 0; c < u; c += g)
                                n = l[c],
                                r = l[c + 1],
                                a = l[c + 2],
                                o = 2 === g ? 0 : l[c + 3],
                                l[d++] = f = 3 === g ? new s(n,r,a,o) : new s(n,(2 * r + n) / 3,(2 * r + a) / 3,a);
                            l.length = d
                        }
                        return m
                    }
                      , f = function(t, e, i) {
                        for (var n, r, a, o, s, l, h, c, u, p, d, f = 1 / i, m = t.length; --m > -1; )
                            for (p = t[m],
                            a = p.a,
                            o = p.d - a,
                            s = p.c - a,
                            l = p.b - a,
                            n = r = 0,
                            c = 1; c <= i; c++)
                                h = f * c,
                                u = 1 - h,
                                n = r - (r = (h * h * o + 3 * u * (h * s + u * l)) * h),
                                d = m * i + c - 1,
                                e[d] = (e[d] || 0) + n * n
                    }
                      , m = function(t, e) {
                        e = e >> 0 || 6;
                        var i, n, r, a, o = [], s = [], l = 0, h = 0, c = e - 1, u = [], p = [];
                        for (i in t)
                            f(t[i], o, e);
                        for (r = o.length,
                        n = 0; n < r; n++)
                            l += Math.sqrt(o[n]),
                            a = n % e,
                            p[a] = l,
                            a === c && (h += l,
                            a = n / e >> 0,
                            u[a] = p,
                            s[a] = h,
                            l = 0,
                            p = []);
                        return {
                            length: h,
                            lengths: s,
                            segments: u
                        }
                    }
                      , g = o._gsDefine.plugin({
                        propName: "bezier",
                        priority: -1,
                        version: "1.3.7",
                        API: 2,
                        global: !0,
                        init: function(t, e, i) {
                            this._target = t,
                            e instanceof Array && (e = {
                                values: e
                            }),
                            this._func = {},
                            this._mod = {},
                            this._props = [],
                            this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                            var n, r, a, o, s, l = e.values || [], h = {}, c = l[0], u = e.autoRotate || i.vars.orientToBezier;
                            this._autoRotate = u ? u instanceof Array ? u : [["x", "y", "rotation", u === !0 ? 0 : Number(u) || 0]] : null;
                            for (n in c)
                                this._props.push(n);
                            for (a = this._props.length; --a > -1; )
                                n = this._props[a],
                                this._overwriteProps.push(n),
                                r = this._func[n] = "function" == typeof t[n],
                                h[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]),
                                s || h[n] !== l[0][n] && (s = h);
                            if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? p(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : d(l, e.type, h),
                            this._segCount = this._beziers[n].length,
                            this._timeRes) {
                                var f = m(this._beziers, this._timeRes);
                                this._length = f.length,
                                this._lengths = f.lengths,
                                this._segments = f.segments,
                                this._l1 = this._li = this._s1 = this._si = 0,
                                this._l2 = this._lengths[0],
                                this._curSeg = this._segments[0],
                                this._s2 = this._curSeg[0],
                                this._prec = 1 / this._curSeg.length
                            }
                            if (u = this._autoRotate)
                                for (this._initialRotations = [],
                                u[0]instanceof Array || (this._autoRotate = u = [u]),
                                a = u.length; --a > -1; ) {
                                    for (o = 0; o < 3; o++)
                                        n = u[a][o],
                                        this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                                    n = u[a][2],
                                    this._initialRotations[a] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0,
                                    this._overwriteProps.push(n)
                                }
                            return this._startRatio = i.vars.runBackwards ? 1 : 0,
                            !0
                        },
                        set: function(e) {
                            var i, n, r, a, o, s, l, h, c, u, p = this._segCount, d = this._func, f = this._target, m = e !== this._startRatio;
                            if (this._timeRes) {
                                if (c = this._lengths,
                                u = this._curSeg,
                                e *= this._length,
                                r = this._li,
                                e > this._l2 && r < p - 1) {
                                    for (h = p - 1; r < h && (this._l2 = c[++r]) <= e; )
                                        ;
                                    this._l1 = c[r - 1],
                                    this._li = r,
                                    this._curSeg = u = this._segments[r],
                                    this._s2 = u[this._s1 = this._si = 0]
                                } else if (e < this._l1 && r > 0) {
                                    for (; r > 0 && (this._l1 = c[--r]) >= e; )
                                        ;
                                    0 === r && e < this._l1 ? this._l1 = 0 : r++,
                                    this._l2 = c[r],
                                    this._li = r,
                                    this._curSeg = u = this._segments[r],
                                    this._s1 = u[(this._si = u.length - 1) - 1] || 0,
                                    this._s2 = u[this._si]
                                }
                                if (i = r,
                                e -= this._l1,
                                r = this._si,
                                e > this._s2 && r < u.length - 1) {
                                    for (h = u.length - 1; r < h && (this._s2 = u[++r]) <= e; )
                                        ;
                                    this._s1 = u[r - 1],
                                    this._si = r
                                } else if (e < this._s1 && r > 0) {
                                    for (; r > 0 && (this._s1 = u[--r]) >= e; )
                                        ;
                                    0 === r && e < this._s1 ? this._s1 = 0 : r++,
                                    this._s2 = u[r],
                                    this._si = r
                                }
                                s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                            } else
                                i = e < 0 ? 0 : e >= 1 ? p - 1 : p * e >> 0,
                                s = (e - i * (1 / p)) * p;
                            for (n = 1 - s,
                            r = this._props.length; --r > -1; )
                                a = this._props[r],
                                o = this._beziers[a][i],
                                l = (s * s * o.da + 3 * n * (s * o.ca + n * o.ba)) * s + o.a,
                                this._mod[a] && (l = this._mod[a](l, f)),
                                d[a] ? f[a](l) : f[a] = l;
                            if (this._autoRotate) {
                                var g, v, _, y, x, b, w, M = this._autoRotate;
                                for (r = M.length; --r > -1; )
                                    a = M[r][2],
                                    b = M[r][3] || 0,
                                    w = M[r][4] === !0 ? 1 : t,
                                    o = this._beziers[M[r][0]],
                                    g = this._beziers[M[r][1]],
                                    o && g && (o = o[i],
                                    g = g[i],
                                    v = o.a + (o.b - o.a) * s,
                                    y = o.b + (o.c - o.b) * s,
                                    v += (y - v) * s,
                                    y += (o.c + (o.d - o.c) * s - y) * s,
                                    _ = g.a + (g.b - g.a) * s,
                                    x = g.b + (g.c - g.b) * s,
                                    _ += (x - _) * s,
                                    x += (g.c + (g.d - g.c) * s - x) * s,
                                    l = m ? Math.atan2(x - _, y - v) * w + b : this._initialRotations[r],
                                    this._mod[a] && (l = this._mod[a](l, f)),
                                    d[a] ? f[a](l) : f[a] = l)
                            }
                        }
                    })
                      , v = g.prototype;
                    g.bezierThrough = p,
                    g.cubicToQuadratic = h,
                    g._autoCSS = !0,
                    g.quadraticToCubic = function(t, e, i) {
                        return new s(t,(2 * e + t) / 3,(2 * e + i) / 3,i)
                    }
                    ,
                    g._cssRegister = function() {
                        var t = a.CSSPlugin;
                        if (t) {
                            var e = t._internals
                              , i = e._parseToProxy
                              , n = e._setPluginRatio
                              , r = e.CSSPropTween;
                            e._registerComplexSpecialProp("bezier", {
                                parser: function(t, e, a, o, s, l) {
                                    e instanceof Array && (e = {
                                        values: e
                                    }),
                                    l = new g;
                                    var h, c, u, p = e.values, d = p.length - 1, f = [], m = {};
                                    if (d < 0)
                                        return s;
                                    for (h = 0; h <= d; h++)
                                        u = i(t, p[h], o, s, l, d !== h),
                                        f[h] = u.end;
                                    for (c in e)
                                        m[c] = e[c];
                                    return m.values = f,
                                    s = new r(t,"bezier",0,0,u.pt,2),
                                    s.data = u,
                                    s.plugin = l,
                                    s.setRatio = n,
                                    0 === m.autoRotate && (m.autoRotate = !0),
                                    !m.autoRotate || m.autoRotate instanceof Array || (h = m.autoRotate === !0 ? 0 : Number(m.autoRotate),
                                    m.autoRotate = null != u.end.left ? [["left", "top", "rotation", h, !1]] : null != u.end.x && [["x", "y", "rotation", h, !1]]),
                                    m.autoRotate && (o._transform || o._enableTransforms(!1),
                                    u.autoRotate = o._target._gsTransform,
                                    u.proxy.rotation = u.autoRotate.rotation || 0,
                                    o._overwriteProps.push("rotation")),
                                    l._onInitTween(u.proxy, m, o._tween),
                                    s
                                }
                            })
                        }
                    }
                    ,
                    v._mod = function(t) {
                        for (var e, i = this._overwriteProps, n = i.length; --n > -1; )
                            e = t[i[n]],
                            e && "function" == typeof e && (this._mod[i[n]] = e)
                    }
                    ,
                    v._kill = function(t) {
                        var e, i, n = this._props;
                        for (e in this._beziers)
                            if (e in t)
                                for (delete this._beziers[e],
                                delete this._func[e],
                                i = n.length; --i > -1; )
                                    n[i] === e && n.splice(i, 1);
                        if (n = this._autoRotate)
                            for (i = n.length; --i > -1; )
                                t[n[i][2]] && n.splice(i, 1);
                        return this._super._kill.call(this, t)
                    }
                }(),
                o._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
                    var i, n, r, a, s = function() {
                        t.call(this, "css"),
                        this._overwriteProps.length = 0,
                        this.setRatio = s.prototype.setRatio
                    }, l = o._gsDefine.globals, h = {}, c = s.prototype = new t("css");
                    c.constructor = s,
                    s.version = "1.19.1",
                    s.API = 2,
                    s.defaultTransformPerspective = 0,
                    s.defaultSkewType = "compensated",
                    s.defaultSmoothOrigin = !0,
                    c = "px",
                    s.suffixMap = {
                        top: c,
                        right: c,
                        bottom: c,
                        left: c,
                        width: c,
                        height: c,
                        fontSize: c,
                        padding: c,
                        margin: c,
                        perspective: c,
                        lineHeight: ""
                    };
                    var u, p, d, f, m, g, v, _, y = /(?:\-|\.|\b)(\d|\.|e\-)+/g, x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, M = /(?:\d|\-|\+|=|#|\.)*/g, T = /opacity *= *([^)]*)/i, S = /opacity:([^;]*)/i, E = /alpha\(opacity *=.+?\)/i, A = /^(rgb|hsl)/, P = /([A-Z])/g, R = /-([a-z])/gi, L = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, C = function(t, e) {
                        return e.toUpperCase()
                    }, O = /(?:Left|Right|Width)/i, I = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, U = /,(?=[^\)]*(?:\(|$))/gi, F = /[\s,\(]/i, N = Math.PI / 180, z = 180 / Math.PI, B = {}, k = {
                        style: {}
                    }, G = o.document || {
                        createElement: function() {
                            return k
                        }
                    }, V = function(t, e) {
                        return G.createElementNS ? G.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : G.createElement(t)
                    }, H = V("div"), j = V("img"), W = s._internals = {
                        _specialProps: h
                    }, X = (o.navigator || {}).userAgent || "", Y = function() {
                        var t = X.indexOf("Android")
                          , e = V("a");
                        return d = X.indexOf("Safari") !== -1 && X.indexOf("Chrome") === -1 && (t === -1 || parseFloat(X.substr(t + 8, 2)) > 3),
                        m = d && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6,
                        f = X.indexOf("Firefox") !== -1,
                        (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (g = parseFloat(RegExp.$1)),
                        !!e && (e.style.cssText = "top:1px;opacity:.55;",
                        /^0.55/.test(e.style.opacity))
                    }(), q = function(t) {
                        return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                    }, Z = function(t) {
                        o.console && console.log(t)
                    }, Q = "", J = "", K = function(t, e) {
                        e = e || H;
                        var i, n, r = e.style;
                        if (void 0 !== r[t])
                            return t;
                        for (t = t.charAt(0).toUpperCase() + t.substr(1),
                        i = ["O", "Moz", "ms", "Ms", "Webkit"],
                        n = 5; --n > -1 && void 0 === r[i[n] + t]; )
                            ;
                        return n >= 0 ? (J = 3 === n ? "ms" : i[n],
                        Q = "-" + J.toLowerCase() + "-",
                        J + t) : null
                    }, $ = G.defaultView ? G.defaultView.getComputedStyle : function() {}
                    , tt = s.getStyle = function(t, e, i, n, r) {
                        var a;
                        return Y || "opacity" !== e ? (!n && t.style[e] ? a = t.style[e] : (i = i || $(t)) ? a = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(P, "-$1").toLowerCase()) : t.currentStyle && (a = t.currentStyle[e]),
                        null == r || a && "none" !== a && "auto" !== a && "auto auto" !== a ? a : r) : q(t)
                    }
                    , et = W.convertToPixels = function(t, i, n, r, a) {
                        if ("px" === r || !r)
                            return n;
                        if ("auto" === r || !n)
                            return 0;
                        var o, l, h, c = O.test(i), u = t, p = H.style, d = n < 0, f = 1 === n;
                        if (d && (n = -n),
                        f && (n *= 100),
                        "%" === r && i.indexOf("border") !== -1)
                            o = n / 100 * (c ? t.clientWidth : t.clientHeight);
                        else {
                            if (p.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;",
                            "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r)
                                p[c ? "borderLeftWidth" : "borderTopWidth"] = n + r;
                            else {
                                if (u = t.parentNode || G.body,
                                l = u._gsCache,
                                h = e.ticker.frame,
                                l && c && l.time === h)
                                    return l.width * n / 100;
                                p[c ? "width" : "height"] = n + r
                            }
                            u.appendChild(H),
                            o = parseFloat(H[c ? "offsetWidth" : "offsetHeight"]),
                            u.removeChild(H),
                            c && "%" === r && s.cacheWidths !== !1 && (l = u._gsCache = u._gsCache || {},
                            l.time = h,
                            l.width = o / n * 100),
                            0 !== o || a || (o = et(t, i, n, r, !0))
                        }
                        return f && (o /= 100),
                        d ? -o : o
                    }
                    , it = W.calculateOffset = function(t, e, i) {
                        if ("absolute" !== tt(t, "position", i))
                            return 0;
                        var n = "left" === e ? "Left" : "Top"
                          , r = tt(t, "margin" + n, i);
                        return t["offset" + n] - (et(t, e, parseFloat(r), r.replace(M, "")) || 0)
                    }
                    , nt = function(t, e) {
                        var i, n, r, a = {};
                        if (e = e || $(t, null))
                            if (i = e.length)
                                for (; --i > -1; )
                                    r = e[i],
                                    r.indexOf("-transform") !== -1 && Lt !== r || (a[r.replace(R, C)] = e.getPropertyValue(r));
                            else
                                for (i in e)
                                    i.indexOf("Transform") !== -1 && Rt !== i || (a[i] = e[i]);
                        else if (e = t.currentStyle || t.style)
                            for (i in e)
                                "string" == typeof i && void 0 === a[i] && (a[i.replace(R, C)] = e[i]);
                        return Y || (a.opacity = q(t)),
                        n = jt(t, e, !1),
                        a.rotation = n.rotation,
                        a.skewX = n.skewX,
                        a.scaleX = n.scaleX,
                        a.scaleY = n.scaleY,
                        a.x = n.x,
                        a.y = n.y,
                        Ot && (a.z = n.z,
                        a.rotationX = n.rotationX,
                        a.rotationY = n.rotationY,
                        a.scaleZ = n.scaleZ),
                        a.filters && delete a.filters,
                        a
                    }, rt = function(t, e, i, n, r) {
                        var a, o, s, l = {}, h = t.style;
                        for (o in i)
                            "cssText" !== o && "length" !== o && isNaN(o) && (e[o] !== (a = i[o]) || r && r[o]) && o.indexOf("Origin") === -1 && ("number" != typeof a && "string" != typeof a || (l[o] = "auto" !== a || "left" !== o && "top" !== o ? "" !== a && "auto" !== a && "none" !== a || "string" != typeof e[o] || "" === e[o].replace(w, "") ? a : 0 : it(t, o),
                            void 0 !== h[o] && (s = new yt(h,o,h[o],s))));
                        if (n)
                            for (o in n)
                                "className" !== o && (l[o] = n[o]);
                        return {
                            difs: l,
                            firstMPT: s
                        }
                    }, at = {
                        width: ["Left", "Right"],
                        height: ["Top", "Bottom"]
                    }, ot = ["marginLeft", "marginRight", "marginTop", "marginBottom"], st = function(t, e, i) {
                        if ("svg" === (t.nodeName + "").toLowerCase())
                            return (i || $(t))[e] || 0;
                        if (t.getCTM && Gt(t))
                            return t.getBBox()[e] || 0;
                        var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight)
                          , r = at[e]
                          , a = r.length;
                        for (i = i || $(t, null); --a > -1; )
                            n -= parseFloat(tt(t, "padding" + r[a], i, !0)) || 0,
                            n -= parseFloat(tt(t, "border" + r[a] + "Width", i, !0)) || 0;
                        return n
                    }, lt = function(t, e) {
                        if ("contain" === t || "auto" === t || "auto auto" === t)
                            return t + " ";
                        null != t && "" !== t || (t = "0 0");
                        var i, n = t.split(" "), r = t.indexOf("left") !== -1 ? "0%" : t.indexOf("right") !== -1 ? "100%" : n[0], a = t.indexOf("top") !== -1 ? "0%" : t.indexOf("bottom") !== -1 ? "100%" : n[1];
                        if (n.length > 3 && !e) {
                            for (n = t.split(", ").join(",").split(","),
                            t = [],
                            i = 0; i < n.length; i++)
                                t.push(lt(n[i]));
                            return t.join(",")
                        }
                        return null == a ? a = "center" === r ? "50%" : "0" : "center" === a && (a = "50%"),
                        ("center" === r || isNaN(parseFloat(r)) && (r + "").indexOf("=") === -1) && (r = "50%"),
                        t = r + " " + a + (n.length > 2 ? " " + n[2] : ""),
                        e && (e.oxp = r.indexOf("%") !== -1,
                        e.oyp = a.indexOf("%") !== -1,
                        e.oxr = "=" === r.charAt(1),
                        e.oyr = "=" === a.charAt(1),
                        e.ox = parseFloat(r.replace(w, "")),
                        e.oy = parseFloat(a.replace(w, "")),
                        e.v = t),
                        e || t
                    }, ht = function(t, e) {
                        return "function" == typeof t && (t = t(_, v)),
                        "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
                    }, ct = function(t, e) {
                        return "function" == typeof t && (t = t(_, v)),
                        null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
                    }, ut = function(t, e, i, n) {
                        var r, a, o, s, l, h = 1e-6;
                        return "function" == typeof t && (t = t(_, v)),
                        null == t ? s = e : "number" == typeof t ? s = t : (r = 360,
                        a = t.split("_"),
                        l = "=" === t.charAt(1),
                        o = (l ? parseInt(t.charAt(0) + "1", 10) * parseFloat(a[0].substr(2)) : parseFloat(a[0])) * (t.indexOf("rad") === -1 ? 1 : z) - (l ? 0 : e),
                        a.length && (n && (n[i] = e + o),
                        t.indexOf("short") !== -1 && (o %= r,
                        o !== o % (r / 2) && (o = o < 0 ? o + r : o - r)),
                        t.indexOf("_cw") !== -1 && o < 0 ? o = (o + 9999999999 * r) % r - (o / r | 0) * r : t.indexOf("ccw") !== -1 && o > 0 && (o = (o - 9999999999 * r) % r - (o / r | 0) * r)),
                        s = e + o),
                        s < h && s > -h && (s = 0),
                        s
                    }, pt = {
                        aqua: [0, 255, 255],
                        lime: [0, 255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, 255],
                        navy: [0, 0, 128],
                        white: [255, 255, 255],
                        fuchsia: [255, 0, 255],
                        olive: [128, 128, 0],
                        yellow: [255, 255, 0],
                        orange: [255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [255, 0, 0],
                        pink: [255, 192, 203],
                        cyan: [0, 255, 255],
                        transparent: [255, 255, 255, 0]
                    }, dt = function(t, e, i) {
                        return t = t < 0 ? t + 1 : t > 1 ? t - 1 : t,
                        255 * (6 * t < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
                    }, ft = s.parseColor = function(t, e) {
                        var i, n, r, a, o, s, l, h, c, u, p;
                        if (t)
                            if ("number" == typeof t)
                                i = [t >> 16, t >> 8 & 255, 255 & t];
                            else {
                                if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)),
                                pt[t])
                                    i = pt[t];
                                else if ("#" === t.charAt(0))
                                    4 === t.length && (n = t.charAt(1),
                                    r = t.charAt(2),
                                    a = t.charAt(3),
                                    t = "#" + n + n + r + r + a + a),
                                    t = parseInt(t.substr(1), 16),
                                    i = [t >> 16, t >> 8 & 255, 255 & t];
                                else if ("hsl" === t.substr(0, 3))
                                    if (i = p = t.match(y),
                                    e) {
                                        if (t.indexOf("=") !== -1)
                                            return t.match(x)
                                    } else
                                        o = Number(i[0]) % 360 / 360,
                                        s = Number(i[1]) / 100,
                                        l = Number(i[2]) / 100,
                                        r = l <= .5 ? l * (s + 1) : l + s - l * s,
                                        n = 2 * l - r,
                                        i.length > 3 && (i[3] = Number(t[3])),
                                        i[0] = dt(o + 1 / 3, n, r),
                                        i[1] = dt(o, n, r),
                                        i[2] = dt(o - 1 / 3, n, r);
                                else
                                    i = t.match(y) || pt.transparent;
                                i[0] = Number(i[0]),
                                i[1] = Number(i[1]),
                                i[2] = Number(i[2]),
                                i.length > 3 && (i[3] = Number(i[3]))
                            }
                        else
                            i = pt.black;
                        return e && !p && (n = i[0] / 255,
                        r = i[1] / 255,
                        a = i[2] / 255,
                        h = Math.max(n, r, a),
                        c = Math.min(n, r, a),
                        l = (h + c) / 2,
                        h === c ? o = s = 0 : (u = h - c,
                        s = l > .5 ? u / (2 - h - c) : u / (h + c),
                        o = h === n ? (r - a) / u + (r < a ? 6 : 0) : h === r ? (a - n) / u + 2 : (n - r) / u + 4,
                        o *= 60),
                        i[0] = o + .5 | 0,
                        i[1] = 100 * s + .5 | 0,
                        i[2] = 100 * l + .5 | 0),
                        i
                    }
                    , mt = function(t, e) {
                        var i, n, r, a = t.match(gt) || [], o = 0, s = a.length ? "" : t;
                        for (i = 0; i < a.length; i++)
                            n = a[i],
                            r = t.substr(o, t.indexOf(n, o) - o),
                            o += r.length + n.length,
                            n = ft(n, e),
                            3 === n.length && n.push(1),
                            s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                        return s + t.substr(o)
                    }, gt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                    for (c in pt)
                        gt += "|" + c + "\\b";
                    gt = new RegExp(gt + ")","gi"),
                    s.colorStringFilter = function(t) {
                        var e, i = t[0] + t[1];
                        gt.test(i) && (e = i.indexOf("hsl(") !== -1 || i.indexOf("hsla(") !== -1,
                        t[0] = mt(t[0], e),
                        t[1] = mt(t[1], e)),
                        gt.lastIndex = 0
                    }
                    ,
                    e.defaultStringFilter || (e.defaultStringFilter = s.colorStringFilter);
                    var vt = function(t, e, i, n) {
                        if (null == t)
                            return function(t) {
                                return t
                            }
                            ;
                        var r, a = e ? (t.match(gt) || [""])[0] : "", o = t.split(a).join("").match(b) || [], s = t.substr(0, t.indexOf(o[0])), l = ")" === t.charAt(t.length - 1) ? ")" : "", h = t.indexOf(" ") !== -1 ? " " : ",", c = o.length, u = c > 0 ? o[0].replace(y, "") : "";
                        return c ? r = e ? function(t) {
                            var e, p, d, f;
                            if ("number" == typeof t)
                                t += u;
                            else if (n && U.test(t)) {
                                for (f = t.replace(U, "|").split("|"),
                                d = 0; d < f.length; d++)
                                    f[d] = r(f[d]);
                                return f.join(",")
                            }
                            if (e = (t.match(gt) || [a])[0],
                            p = t.split(e).join("").match(b) || [],
                            d = p.length,
                            c > d--)
                                for (; ++d < c; )
                                    p[d] = i ? p[(d - 1) / 2 | 0] : o[d];
                            return s + p.join(h) + h + e + l + (t.indexOf("inset") !== -1 ? " inset" : "")
                        }
                        : function(t) {
                            var e, a, p;
                            if ("number" == typeof t)
                                t += u;
                            else if (n && U.test(t)) {
                                for (a = t.replace(U, "|").split("|"),
                                p = 0; p < a.length; p++)
                                    a[p] = r(a[p]);
                                return a.join(",")
                            }
                            if (e = t.match(b) || [],
                            p = e.length,
                            c > p--)
                                for (; ++p < c; )
                                    e[p] = i ? e[(p - 1) / 2 | 0] : o[p];
                            return s + e.join(h) + l
                        }
                        : function(t) {
                            return t
                        }
                    }
                      , _t = function(t) {
                        return t = t.split(","),
                        function(e, i, n, r, a, o, s) {
                            var l, h = (i + "").split(" ");
                            for (s = {},
                            l = 0; l < 4; l++)
                                s[t[l]] = h[l] = h[l] || h[(l - 1) / 2 >> 0];
                            return r.parse(e, s, a, o)
                        }
                    }
                      , yt = (W._setPluginRatio = function(t) {
                        this.plugin.setRatio(t);
                        for (var e, i, n, r, a, o = this.data, s = o.proxy, l = o.firstMPT, h = 1e-6; l; )
                            e = s[l.v],
                            l.r ? e = Math.round(e) : e < h && e > -h && (e = 0),
                            l.t[l.p] = e,
                            l = l._next;
                        if (o.autoRotate && (o.autoRotate.rotation = o.mod ? o.mod(s.rotation, this.t) : s.rotation),
                        1 === t || 0 === t)
                            for (l = o.firstMPT,
                            a = 1 === t ? "e" : "b"; l; ) {
                                if (i = l.t,
                                i.type) {
                                    if (1 === i.type) {
                                        for (r = i.xs0 + i.s + i.xs1,
                                        n = 1; n < i.l; n++)
                                            r += i["xn" + n] + i["xs" + (n + 1)];
                                        i[a] = r
                                    }
                                } else
                                    i[a] = i.s + i.xs0;
                                l = l._next
                            }
                    }
                    ,
                    function(t, e, i, n, r) {
                        this.t = t,
                        this.p = e,
                        this.v = i,
                        this.r = r,
                        n && (n._prev = this,
                        this._next = n)
                    }
                    )
                      , xt = (W._parseToProxy = function(t, e, i, n, r, a) {
                        var o, s, l, h, c, u = n, p = {}, d = {}, f = i._transform, m = B;
                        for (i._transform = null,
                        B = e,
                        n = c = i.parse(t, e, n, r),
                        B = m,
                        a && (i._transform = f,
                        u && (u._prev = null,
                        u._prev && (u._prev._next = null))); n && n !== u; ) {
                            if (n.type <= 1 && (s = n.p,
                            d[s] = n.s + n.c,
                            p[s] = n.s,
                            a || (h = new yt(n,"s",s,h,n.r),
                            n.c = 0),
                            1 === n.type))
                                for (o = n.l; --o > 0; )
                                    l = "xn" + o,
                                    s = n.p + "_" + l,
                                    d[s] = n.data[l],
                                    p[s] = n[l],
                                    a || (h = new yt(n,l,s,h,n.rxp[l]));
                            n = n._next
                        }
                        return {
                            proxy: p,
                            end: d,
                            firstMPT: h,
                            pt: c
                        }
                    }
                    ,
                    W.CSSPropTween = function(t, e, n, r, o, s, l, h, c, u, p) {
                        this.t = t,
                        this.p = e,
                        this.s = n,
                        this.c = r,
                        this.n = l || e,
                        t instanceof xt || a.push(this.n),
                        this.r = h,
                        this.type = s || 0,
                        c && (this.pr = c,
                        i = !0),
                        this.b = void 0 === u ? n : u,
                        this.e = void 0 === p ? n + r : p,
                        o && (this._next = o,
                        o._prev = this)
                    }
                    )
                      , bt = function(t, e, i, n, r, a) {
                        var o = new xt(t,e,i,n - i,r,-1,a);
                        return o.b = i,
                        o.e = o.xs0 = n,
                        o
                    }
                      , wt = s.parseComplex = function(t, e, i, n, r, a, o, l, h, c) {
                        i = i || a || "",
                        "function" == typeof n && (n = n(_, v)),
                        o = new xt(t,e,0,0,o,c ? 2 : 1,null,!1,l,i,n),
                        n += "",
                        r && gt.test(n + i) && (n = [i, n],
                        s.colorStringFilter(n),
                        i = n[0],
                        n = n[1]);
                        var p, d, f, m, g, b, w, M, T, S, E, A, P, R = i.split(", ").join(",").split(" "), L = n.split(", ").join(",").split(" "), C = R.length, O = u !== !1;
                        for (n.indexOf(",") === -1 && i.indexOf(",") === -1 || (R = R.join(" ").replace(U, ", ").split(" "),
                        L = L.join(" ").replace(U, ", ").split(" "),
                        C = R.length),
                        C !== L.length && (R = (a || "").split(" "),
                        C = R.length),
                        o.plugin = h,
                        o.setRatio = c,
                        gt.lastIndex = 0,
                        p = 0; p < C; p++)
                            if (m = R[p],
                            g = L[p],
                            M = parseFloat(m),
                            M || 0 === M)
                                o.appendXtra("", M, ht(g, M), g.replace(x, ""), O && g.indexOf("px") !== -1, !0);
                            else if (r && gt.test(m))
                                A = g.indexOf(")") + 1,
                                A = ")" + (A ? g.substr(A) : ""),
                                P = g.indexOf("hsl") !== -1 && Y,
                                m = ft(m, P),
                                g = ft(g, P),
                                T = m.length + g.length > 6,
                                T && !Y && 0 === g[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent",
                                o.e = o.e.split(L[p]).join("transparent")) : (Y || (T = !1),
                                P ? o.appendXtra(T ? "hsla(" : "hsl(", m[0], ht(g[0], m[0]), ",", !1, !0).appendXtra("", m[1], ht(g[1], m[1]), "%,", !1).appendXtra("", m[2], ht(g[2], m[2]), T ? "%," : "%" + A, !1) : o.appendXtra(T ? "rgba(" : "rgb(", m[0], g[0] - m[0], ",", !0, !0).appendXtra("", m[1], g[1] - m[1], ",", !0).appendXtra("", m[2], g[2] - m[2], T ? "," : A, !0),
                                T && (m = m.length < 4 ? 1 : m[3],
                                o.appendXtra("", m, (g.length < 4 ? 1 : g[3]) - m, A, !1))),
                                gt.lastIndex = 0;
                            else if (b = m.match(y)) {
                                if (w = g.match(x),
                                !w || w.length !== b.length)
                                    return o;
                                for (f = 0,
                                d = 0; d < b.length; d++)
                                    E = b[d],
                                    S = m.indexOf(E, f),
                                    o.appendXtra(m.substr(f, S - f), Number(E), ht(w[d], E), "", O && "px" === m.substr(S + E.length, 2), 0 === d),
                                    f = S + E.length;
                                o["xs" + o.l] += m.substr(f)
                            } else
                                o["xs" + o.l] += o.l || o["xs" + o.l] ? " " + g : g;
                        if (n.indexOf("=") !== -1 && o.data) {
                            for (A = o.xs0 + o.data.s,
                            p = 1; p < o.l; p++)
                                A += o["xs" + p] + o.data["xn" + p];
                            o.e = A + o["xs" + p]
                        }
                        return o.l || (o.type = -1,
                        o.xs0 = o.e),
                        o.xfirst || o
                    }
                      , Mt = 9;
                    for (c = xt.prototype,
                    c.l = c.pr = 0; --Mt > 0; )
                        c["xn" + Mt] = 0,
                        c["xs" + Mt] = "";
                    c.xs0 = "",
                    c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null,
                    c.appendXtra = function(t, e, i, n, r, a) {
                        var o = this
                          , s = o.l;
                        return o["xs" + s] += a && (s || o["xs" + s]) ? " " + t : t || "",
                        i || 0 === s || o.plugin ? (o.l++,
                        o.type = o.setRatio ? 2 : 1,
                        o["xs" + o.l] = n || "",
                        s > 0 ? (o.data["xn" + s] = e + i,
                        o.rxp["xn" + s] = r,
                        o["xn" + s] = e,
                        o.plugin || (o.xfirst = new xt(o,"xn" + s,e,i,o.xfirst || o,0,o.n,r,o.pr),
                        o.xfirst.xs0 = 0),
                        o) : (o.data = {
                            s: e + i
                        },
                        o.rxp = {},
                        o.s = e,
                        o.c = i,
                        o.r = r,
                        o)) : (o["xs" + s] += e + (n || ""),
                        o)
                    }
                    ;
                    var Tt = function(t, e) {
                        e = e || {},
                        this.p = e.prefix ? K(t) || t : t,
                        h[t] = h[this.p] = this,
                        this.format = e.formatter || vt(e.defaultValue, e.color, e.collapsible, e.multi),
                        e.parser && (this.parse = e.parser),
                        this.clrs = e.color,
                        this.multi = e.multi,
                        this.keyword = e.keyword,
                        this.dflt = e.defaultValue,
                        this.pr = e.priority || 0
                    }
                      , St = W._registerComplexSpecialProp = function(t, e, i) {
                        "object" != typeof e && (e = {
                            parser: i
                        });
                        var n, r, a = t.split(","), o = e.defaultValue;
                        for (i = i || [o],
                        n = 0; n < a.length; n++)
                            e.prefix = 0 === n && e.prefix,
                            e.defaultValue = i[n] || o,
                            r = new Tt(a[n],e)
                    }
                      , Et = W._registerPluginProp = function(t) {
                        if (!h[t]) {
                            var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                            St(t, {
                                parser: function(t, i, n, r, a, o, s) {
                                    var c = l.com.greensock.plugins[e];
                                    return c ? (c._cssRegister(),
                                    h[n].parse(t, i, n, r, a, o, s)) : (Z("Error: " + e + " js file not loaded."),
                                    a)
                                }
                            })
                        }
                    }
                    ;
                    c = Tt.prototype,
                    c.parseComplex = function(t, e, i, n, r, a) {
                        var o, s, l, h, c, u, p = this.keyword;
                        if (this.multi && (U.test(i) || U.test(e) ? (s = e.replace(U, "|").split("|"),
                        l = i.replace(U, "|").split("|")) : p && (s = [e],
                        l = [i])),
                        l) {
                            for (h = l.length > s.length ? l.length : s.length,
                            o = 0; o < h; o++)
                                e = s[o] = s[o] || this.dflt,
                                i = l[o] = l[o] || this.dflt,
                                p && (c = e.indexOf(p),
                                u = i.indexOf(p),
                                c !== u && (u === -1 ? s[o] = s[o].split(p).join("") : c === -1 && (s[o] += " " + p)));
                            e = s.join(", "),
                            i = l.join(", ")
                        }
                        return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, a)
                    }
                    ,
                    c.parse = function(t, e, i, n, a, o, s) {
                        return this.parseComplex(t.style, this.format(tt(t, this.p, r, !1, this.dflt)), this.format(e), a, o)
                    }
                    ,
                    s.registerSpecialProp = function(t, e, i) {
                        St(t, {
                            parser: function(t, n, r, a, o, s, l) {
                                var h = new xt(t,r,0,0,o,2,r,!1,i);
                                return h.plugin = s,
                                h.setRatio = e(t, n, a._tween, r),
                                h
                            },
                            priority: i
                        })
                    }
                    ,
                    s.useSVGTransformAttr = !0;
                    var At, Pt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), Rt = K("transform"), Lt = Q + "transform", Ct = K("transformOrigin"), Ot = null !== K("perspective"), It = W.Transform = function() {
                        this.perspective = parseFloat(s.defaultTransformPerspective) || 0,
                        this.force3D = !(s.defaultForce3D === !1 || !Ot) && (s.defaultForce3D || "auto")
                    }
                    , Dt = o.SVGElement, Ut = function(t, e, i) {
                        var n, r = G.createElementNS("http://www.w3.org/2000/svg", t), a = /([a-z])([A-Z])/g;
                        for (n in i)
                            r.setAttributeNS(null, n.replace(a, "$1-$2").toLowerCase(), i[n]);
                        return e.appendChild(r),
                        r
                    }, Ft = G.documentElement || {}, Nt = function() {
                        var t, e, i, n = g || /Android/i.test(X) && !o.chrome;
                        return G.createElementNS && !n && (t = Ut("svg", Ft),
                        e = Ut("rect", t, {
                            width: 100,
                            height: 50,
                            x: 100
                        }),
                        i = e.getBoundingClientRect().width,
                        e.style[Ct] = "50% 50%",
                        e.style[Rt] = "scaleX(0.5)",
                        n = i === e.getBoundingClientRect().width && !(f && Ot),
                        Ft.removeChild(t)),
                        n
                    }(), zt = function(t, e, i, n, r, a) {
                        var o, l, h, c, u, p, d, f, m, g, v, _, y, x, b = t._gsTransform, w = Ht(t, !0);
                        b && (y = b.xOrigin,
                        x = b.yOrigin),
                        (!n || (o = n.split(" ")).length < 2) && (d = t.getBBox(),
                        0 === d.x && 0 === d.y && d.width + d.height === 0 && (d = {
                            x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                            y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                            width: 0,
                            height: 0
                        }),
                        e = lt(e).split(" "),
                        o = [(e[0].indexOf("%") !== -1 ? parseFloat(e[0]) / 100 * d.width : parseFloat(e[0])) + d.x, (e[1].indexOf("%") !== -1 ? parseFloat(e[1]) / 100 * d.height : parseFloat(e[1])) + d.y]),
                        i.xOrigin = c = parseFloat(o[0]),
                        i.yOrigin = u = parseFloat(o[1]),
                        n && w !== Vt && (p = w[0],
                        d = w[1],
                        f = w[2],
                        m = w[3],
                        g = w[4],
                        v = w[5],
                        _ = p * m - d * f,
                        _ && (l = c * (m / _) + u * (-f / _) + (f * v - m * g) / _,
                        h = c * (-d / _) + u * (p / _) - (p * v - d * g) / _,
                        c = i.xOrigin = o[0] = l,
                        u = i.yOrigin = o[1] = h)),
                        b && (a && (i.xOffset = b.xOffset,
                        i.yOffset = b.yOffset,
                        b = i),
                        r || r !== !1 && s.defaultSmoothOrigin !== !1 ? (l = c - y,
                        h = u - x,
                        b.xOffset += l * w[0] + h * w[2] - l,
                        b.yOffset += l * w[1] + h * w[3] - h) : b.xOffset = b.yOffset = 0),
                        a || t.setAttribute("data-svg-origin", o.join(" "))
                    }, Bt = function(t) {
                        var e, i = V("svg", this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, r = this.nextSibling, a = this.style.cssText;
                        if (Ft.appendChild(i),
                        i.appendChild(this),
                        this.style.display = "block",
                        t)
                            try {
                                e = this.getBBox(),
                                this._originalGetBBox = this.getBBox,
                                this.getBBox = Bt
                            } catch (t) {}
                        else
                            this._originalGetBBox && (e = this._originalGetBBox());
                        return r ? n.insertBefore(this, r) : n.appendChild(this),
                        Ft.removeChild(i),
                        this.style.cssText = a,
                        e
                    }, kt = function(t) {
                        try {
                            return t.getBBox()
                        } catch (e) {
                            return Bt.call(t, !0)
                        }
                    }, Gt = function(t) {
                        return !(!(Dt && t.getCTM && kt(t)) || t.parentNode && !t.ownerSVGElement)
                    }, Vt = [1, 0, 0, 1, 0, 0], Ht = function(t, e) {
                        var i, n, r, a, o, s, l = t._gsTransform || new It, h = 1e5, c = t.style;
                        if (Rt ? n = tt(t, Lt, null, !0) : t.currentStyle && (n = t.currentStyle.filter.match(I),
                        n = n && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""),
                        i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n,
                        i && Rt && ((s = "none" === $(t).display) || !t.parentNode) && (s && (a = c.display,
                        c.display = "block"),
                        t.parentNode || (o = 1,
                        Ft.appendChild(t)),
                        n = tt(t, Lt, null, !0),
                        i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n,
                        a ? c.display = a : s && qt(c, "display"),
                        o && Ft.removeChild(t)),
                        (l.svg || t.getCTM && Gt(t)) && (i && (c[Rt] + "").indexOf("matrix") !== -1 && (n = c[Rt],
                        i = 0),
                        r = t.getAttribute("transform"),
                        i && r && (r.indexOf("matrix") !== -1 ? (n = r,
                        i = 0) : r.indexOf("translate") !== -1 && (n = "matrix(1,0,0,1," + r.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")",
                        i = 0))),
                        i)
                            return Vt;
                        for (r = (n || "").match(y) || [],
                        Mt = r.length; --Mt > -1; )
                            a = Number(r[Mt]),
                            r[Mt] = (o = a - (a |= 0)) ? (o * h + (o < 0 ? -.5 : .5) | 0) / h + a : a;
                        return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                    }, jt = W.getTransform = function(t, i, n, r) {
                        if (t._gsTransform && n && !r)
                            return t._gsTransform;
                        var a, o, l, h, c, u, p = n ? t._gsTransform || new It : new It, d = p.scaleX < 0, f = 2e-5, m = 1e5, g = Ot ? parseFloat(tt(t, Ct, i, !1, "0 0 0").split(" ")[2]) || p.zOrigin || 0 : 0, v = parseFloat(s.defaultTransformPerspective) || 0;
                        if (p.svg = !(!t.getCTM || !Gt(t)),
                        p.svg && (zt(t, tt(t, Ct, i, !1, "50% 50%") + "", p, t.getAttribute("data-svg-origin")),
                        At = s.useSVGTransformAttr || Nt),
                        a = Ht(t),
                        a !== Vt) {
                            if (16 === a.length) {
                                var _, y, x, b, w, M = a[0], T = a[1], S = a[2], E = a[3], A = a[4], P = a[5], R = a[6], L = a[7], C = a[8], O = a[9], I = a[10], D = a[12], U = a[13], F = a[14], N = a[11], B = Math.atan2(R, I);
                                p.zOrigin && (F = -p.zOrigin,
                                D = C * F - a[12],
                                U = O * F - a[13],
                                F = I * F + p.zOrigin - a[14]),
                                p.rotationX = B * z,
                                B && (b = Math.cos(-B),
                                w = Math.sin(-B),
                                _ = A * b + C * w,
                                y = P * b + O * w,
                                x = R * b + I * w,
                                C = A * -w + C * b,
                                O = P * -w + O * b,
                                I = R * -w + I * b,
                                N = L * -w + N * b,
                                A = _,
                                P = y,
                                R = x),
                                B = Math.atan2(-S, I),
                                p.rotationY = B * z,
                                B && (b = Math.cos(-B),
                                w = Math.sin(-B),
                                _ = M * b - C * w,
                                y = T * b - O * w,
                                x = S * b - I * w,
                                O = T * w + O * b,
                                I = S * w + I * b,
                                N = E * w + N * b,
                                M = _,
                                T = y,
                                S = x),
                                B = Math.atan2(T, M),
                                p.rotation = B * z,
                                B && (b = Math.cos(-B),
                                w = Math.sin(-B),
                                M = M * b + A * w,
                                y = T * b + P * w,
                                P = T * -w + P * b,
                                R = S * -w + R * b,
                                T = y),
                                p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0,
                                p.rotationY = 180 - p.rotationY),
                                p.scaleX = (Math.sqrt(M * M + T * T) * m + .5 | 0) / m,
                                p.scaleY = (Math.sqrt(P * P + O * O) * m + .5 | 0) / m,
                                p.scaleZ = (Math.sqrt(R * R + I * I) * m + .5 | 0) / m,
                                p.rotationX || p.rotationY ? p.skewX = 0 : (p.skewX = A || P ? Math.atan2(A, P) * z + p.rotation : p.skewX || 0,
                                Math.abs(p.skewX) > 90 && Math.abs(p.skewX) < 270 && (d ? (p.scaleX *= -1,
                                p.skewX += p.rotation <= 0 ? 180 : -180,
                                p.rotation += p.rotation <= 0 ? 180 : -180) : (p.scaleY *= -1,
                                p.skewX += p.skewX <= 0 ? 180 : -180))),
                                p.perspective = N ? 1 / (N < 0 ? -N : N) : 0,
                                p.x = D,
                                p.y = U,
                                p.z = F,
                                p.svg && (p.x -= p.xOrigin - (p.xOrigin * M - p.yOrigin * A),
                                p.y -= p.yOrigin - (p.yOrigin * T - p.xOrigin * P))
                            } else if (!Ot || r || !a.length || p.x !== a[4] || p.y !== a[5] || !p.rotationX && !p.rotationY) {
                                var k = a.length >= 6
                                  , G = k ? a[0] : 1
                                  , V = a[1] || 0
                                  , H = a[2] || 0
                                  , j = k ? a[3] : 1;
                                p.x = a[4] || 0,
                                p.y = a[5] || 0,
                                l = Math.sqrt(G * G + V * V),
                                h = Math.sqrt(j * j + H * H),
                                c = G || V ? Math.atan2(V, G) * z : p.rotation || 0,
                                u = H || j ? Math.atan2(H, j) * z + c : p.skewX || 0,
                                Math.abs(u) > 90 && Math.abs(u) < 270 && (d ? (l *= -1,
                                u += c <= 0 ? 180 : -180,
                                c += c <= 0 ? 180 : -180) : (h *= -1,
                                u += u <= 0 ? 180 : -180)),
                                p.scaleX = l,
                                p.scaleY = h,
                                p.rotation = c,
                                p.skewX = u,
                                Ot && (p.rotationX = p.rotationY = p.z = 0,
                                p.perspective = v,
                                p.scaleZ = 1),
                                p.svg && (p.x -= p.xOrigin - (p.xOrigin * G + p.yOrigin * H),
                                p.y -= p.yOrigin - (p.xOrigin * V + p.yOrigin * j))
                            }
                            p.zOrigin = g;
                            for (o in p)
                                p[o] < f && p[o] > -f && (p[o] = 0)
                        }
                        return n && (t._gsTransform = p,
                        p.svg && (At && t.style[Rt] ? e.delayedCall(.001, function() {
                            qt(t.style, Rt)
                        }) : !At && t.getAttribute("transform") && e.delayedCall(.001, function() {
                            t.removeAttribute("transform")
                        }))),
                        p
                    }
                    , Wt = function(t) {
                        var e, i, n = this.data, r = -n.rotation * N, a = r + n.skewX * N, o = 1e5, s = (Math.cos(r) * n.scaleX * o | 0) / o, l = (Math.sin(r) * n.scaleX * o | 0) / o, h = (Math.sin(a) * -n.scaleY * o | 0) / o, c = (Math.cos(a) * n.scaleY * o | 0) / o, u = this.t.style, p = this.t.currentStyle;
                        if (p) {
                            i = l,
                            l = -h,
                            h = -i,
                            e = p.filter,
                            u.filter = "";
                            var d, f, m = this.t.offsetWidth, v = this.t.offsetHeight, _ = "absolute" !== p.position, y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + h + ", M22=" + c, x = n.x + m * n.xPercent / 100, b = n.y + v * n.yPercent / 100;
                            if (null != n.ox && (d = (n.oxp ? m * n.ox * .01 : n.ox) - m / 2,
                            f = (n.oyp ? v * n.oy * .01 : n.oy) - v / 2,
                            x += d - (d * s + f * l),
                            b += f - (d * h + f * c)),
                            _ ? (d = m / 2,
                            f = v / 2,
                            y += ", Dx=" + (d - (d * s + f * l) + x) + ", Dy=" + (f - (d * h + f * c) + b) + ")") : y += ", sizingMethod='auto expand')",
                            e.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? u.filter = e.replace(D, y) : u.filter = y + " " + e,
                            0 !== t && 1 !== t || 1 === s && 0 === l && 0 === h && 1 === c && (_ && y.indexOf("Dx=0, Dy=0") === -1 || T.test(e) && 100 !== parseFloat(RegExp.$1) || e.indexOf(e.indexOf("Alpha")) === -1 && u.removeAttribute("filter")),
                            !_) {
                                var w, S, E, A = g < 8 ? 1 : -1;
                                for (d = n.ieOffsetX || 0,
                                f = n.ieOffsetY || 0,
                                n.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (l < 0 ? -l : l) * v)) / 2 + x),
                                n.ieOffsetY = Math.round((v - ((c < 0 ? -c : c) * v + (h < 0 ? -h : h) * m)) / 2 + b),
                                Mt = 0; Mt < 4; Mt++)
                                    S = ot[Mt],
                                    w = p[S],
                                    i = w.indexOf("px") !== -1 ? parseFloat(w) : et(this.t, S, parseFloat(w), w.replace(M, "")) || 0,
                                    E = i !== n[S] ? Mt < 2 ? -n.ieOffsetX : -n.ieOffsetY : Mt < 2 ? d - n.ieOffsetX : f - n.ieOffsetY,
                                    u[S] = (n[S] = Math.round(i - E * (0 === Mt || 2 === Mt ? 1 : A))) + "px"
                            }
                        }
                    }, Xt = W.set3DTransformRatio = W.setTransformRatio = function(t) {
                        var e, i, n, r, a, o, s, l, h, c, u, p, d, m, g, v, _, y, x, b, w, M, T, S = this.data, E = this.t.style, A = S.rotation, P = S.rotationX, R = S.rotationY, L = S.scaleX, C = S.scaleY, O = S.scaleZ, I = S.x, D = S.y, U = S.z, F = S.svg, z = S.perspective, B = S.force3D, k = S.skewY, G = S.skewX;
                        if (k && (G += k,
                        A += k),
                        ((1 === t || 0 === t) && "auto" === B && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !B) && !U && !z && !R && !P && 1 === O || At && F || !Ot)
                            return void (A || G || F ? (A *= N,
                            M = G * N,
                            T = 1e5,
                            i = Math.cos(A) * L,
                            a = Math.sin(A) * L,
                            n = Math.sin(A - M) * -C,
                            o = Math.cos(A - M) * C,
                            M && "simple" === S.skewType && (e = Math.tan(M - k * N),
                            e = Math.sqrt(1 + e * e),
                            n *= e,
                            o *= e,
                            k && (e = Math.tan(k * N),
                            e = Math.sqrt(1 + e * e),
                            i *= e,
                            a *= e)),
                            F && (I += S.xOrigin - (S.xOrigin * i + S.yOrigin * n) + S.xOffset,
                            D += S.yOrigin - (S.xOrigin * a + S.yOrigin * o) + S.yOffset,
                            At && (S.xPercent || S.yPercent) && (g = this.t.getBBox(),
                            I += .01 * S.xPercent * g.width,
                            D += .01 * S.yPercent * g.height),
                            g = 1e-6,
                            I < g && I > -g && (I = 0),
                            D < g && D > -g && (D = 0)),
                            x = (i * T | 0) / T + "," + (a * T | 0) / T + "," + (n * T | 0) / T + "," + (o * T | 0) / T + "," + I + "," + D + ")",
                            F && At ? this.t.setAttribute("transform", "matrix(" + x) : E[Rt] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix(" : "matrix(") + x) : E[Rt] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix(" : "matrix(") + L + ",0,0," + C + "," + I + "," + D + ")");
                        if (f && (g = 1e-4,
                        L < g && L > -g && (L = O = 2e-5),
                        C < g && C > -g && (C = O = 2e-5),
                        !z || S.z || S.rotationX || S.rotationY || (z = 0)),
                        A || G)
                            A *= N,
                            v = i = Math.cos(A),
                            _ = a = Math.sin(A),
                            G && (A -= G * N,
                            v = Math.cos(A),
                            _ = Math.sin(A),
                            "simple" === S.skewType && (e = Math.tan((G - k) * N),
                            e = Math.sqrt(1 + e * e),
                            v *= e,
                            _ *= e,
                            S.skewY && (e = Math.tan(k * N),
                            e = Math.sqrt(1 + e * e),
                            i *= e,
                            a *= e))),
                            n = -_,
                            o = v;
                        else {
                            if (!(R || P || 1 !== O || z || F))
                                return void (E[Rt] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) translate3d(" : "translate3d(") + I + "px," + D + "px," + U + "px)" + (1 !== L || 1 !== C ? " scale(" + L + "," + C + ")" : ""));
                            i = o = 1,
                            n = a = 0
                        }
                        c = 1,
                        r = s = l = h = u = p = 0,
                        d = z ? -1 / z : 0,
                        m = S.zOrigin,
                        g = 1e-6,
                        b = ",",
                        w = "0",
                        A = R * N,
                        A && (v = Math.cos(A),
                        _ = Math.sin(A),
                        l = -_,
                        u = d * -_,
                        r = i * _,
                        s = a * _,
                        c = v,
                        d *= v,
                        i *= v,
                        a *= v),
                        A = P * N,
                        A && (v = Math.cos(A),
                        _ = Math.sin(A),
                        e = n * v + r * _,
                        y = o * v + s * _,
                        h = c * _,
                        p = d * _,
                        r = n * -_ + r * v,
                        s = o * -_ + s * v,
                        c *= v,
                        d *= v,
                        n = e,
                        o = y),
                        1 !== O && (r *= O,
                        s *= O,
                        c *= O,
                        d *= O),
                        1 !== C && (n *= C,
                        o *= C,
                        h *= C,
                        p *= C),
                        1 !== L && (i *= L,
                        a *= L,
                        l *= L,
                        u *= L),
                        (m || F) && (m && (I += r * -m,
                        D += s * -m,
                        U += c * -m + m),
                        F && (I += S.xOrigin - (S.xOrigin * i + S.yOrigin * n) + S.xOffset,
                        D += S.yOrigin - (S.xOrigin * a + S.yOrigin * o) + S.yOffset),
                        I < g && I > -g && (I = w),
                        D < g && D > -g && (D = w),
                        U < g && U > -g && (U = 0)),
                        x = S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix3d(" : "matrix3d(",
                        x += (i < g && i > -g ? w : i) + b + (a < g && a > -g ? w : a) + b + (l < g && l > -g ? w : l),
                        x += b + (u < g && u > -g ? w : u) + b + (n < g && n > -g ? w : n) + b + (o < g && o > -g ? w : o),
                        P || R || 1 !== O ? (x += b + (h < g && h > -g ? w : h) + b + (p < g && p > -g ? w : p) + b + (r < g && r > -g ? w : r),
                        x += b + (s < g && s > -g ? w : s) + b + (c < g && c > -g ? w : c) + b + (d < g && d > -g ? w : d) + b) : x += ",0,0,0,0,1,0,",
                        x += I + b + D + b + U + b + (z ? 1 + -U / z : 1) + ")",
                        E[Rt] = x
                    }
                    ;
                    c = It.prototype,
                    c.x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0,
                    c.scaleX = c.scaleY = c.scaleZ = 1,
                    St("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                        parser: function(t, e, i, n, a, o, l) {
                            if (n._lastParsedTransform === l)
                                return a;
                            n._lastParsedTransform = l;
                            var h, c = l.scale && "function" == typeof l.scale ? l.scale : 0;
                            "function" == typeof l[i] && (h = l[i],
                            l[i] = e),
                            c && (l.scale = c(_, t));
                            var u, p, d, f, m, g, y, x, b, w = t._gsTransform, M = t.style, T = 1e-6, S = Pt.length, E = l, A = {}, P = "transformOrigin", R = jt(t, r, !0, E.parseTransform), L = E.transform && ("function" == typeof E.transform ? E.transform(_, v) : E.transform);
                            if (n._transform = R,
                            L && "string" == typeof L && Rt)
                                p = H.style,
                                p[Rt] = L,
                                p.display = "block",
                                p.position = "absolute",
                                G.body.appendChild(H),
                                u = jt(H, null, !1),
                                R.svg && (g = R.xOrigin,
                                y = R.yOrigin,
                                u.x -= R.xOffset,
                                u.y -= R.yOffset,
                                (E.transformOrigin || E.svgOrigin) && (L = {},
                                zt(t, lt(E.transformOrigin), L, E.svgOrigin, E.smoothOrigin, !0),
                                g = L.xOrigin,
                                y = L.yOrigin,
                                u.x -= L.xOffset - R.xOffset,
                                u.y -= L.yOffset - R.yOffset),
                                (g || y) && (x = Ht(H, !0),
                                u.x -= g - (g * x[0] + y * x[2]),
                                u.y -= y - (g * x[1] + y * x[3]))),
                                G.body.removeChild(H),
                                u.perspective || (u.perspective = R.perspective),
                                null != E.xPercent && (u.xPercent = ct(E.xPercent, R.xPercent)),
                                null != E.yPercent && (u.yPercent = ct(E.yPercent, R.yPercent));
                            else if ("object" == typeof E) {
                                if (u = {
                                    scaleX: ct(null != E.scaleX ? E.scaleX : E.scale, R.scaleX),
                                    scaleY: ct(null != E.scaleY ? E.scaleY : E.scale, R.scaleY),
                                    scaleZ: ct(E.scaleZ, R.scaleZ),
                                    x: ct(E.x, R.x),
                                    y: ct(E.y, R.y),
                                    z: ct(E.z, R.z),
                                    xPercent: ct(E.xPercent, R.xPercent),
                                    yPercent: ct(E.yPercent, R.yPercent),
                                    perspective: ct(E.transformPerspective, R.perspective)
                                },
                                m = E.directionalRotation,
                                null != m)
                                    if ("object" == typeof m)
                                        for (p in m)
                                            E[p] = m[p];
                                    else
                                        E.rotation = m;
                                "string" == typeof E.x && E.x.indexOf("%") !== -1 && (u.x = 0,
                                u.xPercent = ct(E.x, R.xPercent)),
                                "string" == typeof E.y && E.y.indexOf("%") !== -1 && (u.y = 0,
                                u.yPercent = ct(E.y, R.yPercent)),
                                u.rotation = ut("rotation"in E ? E.rotation : "shortRotation"in E ? E.shortRotation + "_short" : "rotationZ"in E ? E.rotationZ : R.rotation, R.rotation, "rotation", A),
                                Ot && (u.rotationX = ut("rotationX"in E ? E.rotationX : "shortRotationX"in E ? E.shortRotationX + "_short" : R.rotationX || 0, R.rotationX, "rotationX", A),
                                u.rotationY = ut("rotationY"in E ? E.rotationY : "shortRotationY"in E ? E.shortRotationY + "_short" : R.rotationY || 0, R.rotationY, "rotationY", A)),
                                u.skewX = ut(E.skewX, R.skewX),
                                u.skewY = ut(E.skewY, R.skewY)
                            }
                            for (Ot && null != E.force3D && (R.force3D = E.force3D,
                            f = !0),
                            R.skewType = E.skewType || R.skewType || s.defaultSkewType,
                            d = R.force3D || R.z || R.rotationX || R.rotationY || u.z || u.rotationX || u.rotationY || u.perspective,
                            d || null == E.scale || (u.scaleZ = 1); --S > -1; )
                                b = Pt[S],
                                L = u[b] - R[b],
                                (L > T || L < -T || null != E[b] || null != B[b]) && (f = !0,
                                a = new xt(R,b,R[b],L,a),
                                b in A && (a.e = A[b]),
                                a.xs0 = 0,
                                a.plugin = o,
                                n._overwriteProps.push(a.n));
                            return L = E.transformOrigin,
                            R.svg && (L || E.svgOrigin) && (g = R.xOffset,
                            y = R.yOffset,
                            zt(t, lt(L), u, E.svgOrigin, E.smoothOrigin),
                            a = bt(R, "xOrigin", (w ? R : u).xOrigin, u.xOrigin, a, P),
                            a = bt(R, "yOrigin", (w ? R : u).yOrigin, u.yOrigin, a, P),
                            g === R.xOffset && y === R.yOffset || (a = bt(R, "xOffset", w ? g : R.xOffset, R.xOffset, a, P),
                            a = bt(R, "yOffset", w ? y : R.yOffset, R.yOffset, a, P)),
                            L = "0px 0px"),
                            (L || Ot && d && R.zOrigin) && (Rt ? (f = !0,
                            b = Ct,
                            L = (L || tt(t, b, r, !1, "50% 50%")) + "",
                            a = new xt(M,b,0,0,a,-1,P),
                            a.b = M[b],
                            a.plugin = o,
                            Ot ? (p = R.zOrigin,
                            L = L.split(" "),
                            R.zOrigin = (L.length > 2 && (0 === p || "0px" !== L[2]) ? parseFloat(L[2]) : p) || 0,
                            a.xs0 = a.e = L[0] + " " + (L[1] || "50%") + " 0px",
                            a = new xt(R,"zOrigin",0,0,a,-1,a.n),
                            a.b = p,
                            a.xs0 = a.e = R.zOrigin) : a.xs0 = a.e = L) : lt(L + "", R)),
                            f && (n._transformType = R.svg && At || !d && 3 !== this._transformType ? 2 : 3),
                            h && (l[i] = h),
                            c && (l.scale = c),
                            a
                        },
                        prefix: !0
                    }),
                    St("boxShadow", {
                        defaultValue: "0px 0px 0px 0px #999",
                        prefix: !0,
                        color: !0,
                        multi: !0,
                        keyword: "inset"
                    }),
                    St("borderRadius", {
                        defaultValue: "0px",
                        parser: function(t, e, i, a, o, s) {
                            e = this.format(e);
                            var l, h, c, u, p, d, f, m, g, v, _, y, x, b, w, M, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], S = t.style;
                            for (g = parseFloat(t.offsetWidth),
                            v = parseFloat(t.offsetHeight),
                            l = e.split(" "),
                            h = 0; h < T.length; h++)
                                this.p.indexOf("border") && (T[h] = K(T[h])),
                                p = u = tt(t, T[h], r, !1, "0px"),
                                p.indexOf(" ") !== -1 && (u = p.split(" "),
                                p = u[0],
                                u = u[1]),
                                d = c = l[h],
                                f = parseFloat(p),
                                y = p.substr((f + "").length),
                                x = "=" === d.charAt(1),
                                x ? (m = parseInt(d.charAt(0) + "1", 10),
                                d = d.substr(2),
                                m *= parseFloat(d),
                                _ = d.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(d),
                                _ = d.substr((m + "").length)),
                                "" === _ && (_ = n[i] || y),
                                _ !== y && (b = et(t, "borderLeft", f, y),
                                w = et(t, "borderTop", f, y),
                                "%" === _ ? (p = b / g * 100 + "%",
                                u = w / v * 100 + "%") : "em" === _ ? (M = et(t, "borderLeft", 1, "em"),
                                p = b / M + "em",
                                u = w / M + "em") : (p = b + "px",
                                u = w + "px"),
                                x && (d = parseFloat(p) + m + _,
                                c = parseFloat(u) + m + _)),
                                o = wt(S, T[h], p + " " + u, d + " " + c, !1, "0px", o);
                            return o
                        },
                        prefix: !0,
                        formatter: vt("0px 0px 0px 0px", !1, !0)
                    }),
                    St("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                        defaultValue: "0px",
                        parser: function(t, e, i, n, a, o) {
                            return wt(t.style, i, this.format(tt(t, i, r, !1, "0px 0px")), this.format(e), !1, "0px", a)
                        },
                        prefix: !0,
                        formatter: vt("0px 0px", !1, !0)
                    }),
                    St("backgroundPosition", {
                        defaultValue: "0 0",
                        parser: function(t, e, i, n, a, o) {
                            var s, l, h, c, u, p, d = "background-position", f = r || $(t, null), m = this.format((f ? g ? f.getPropertyValue(d + "-x") + " " + f.getPropertyValue(d + "-y") : f.getPropertyValue(d) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"), v = this.format(e);
                            if (m.indexOf("%") !== -1 != (v.indexOf("%") !== -1) && v.split(",").length < 2 && (p = tt(t, "backgroundImage").replace(L, ""),
                            p && "none" !== p)) {
                                for (s = m.split(" "),
                                l = v.split(" "),
                                j.setAttribute("src", p),
                                h = 2; --h > -1; )
                                    m = s[h],
                                    c = m.indexOf("%") !== -1,
                                    c !== (l[h].indexOf("%") !== -1) && (u = 0 === h ? t.offsetWidth - j.width : t.offsetHeight - j.height,
                                    s[h] = c ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                m = s.join(" ")
                            }
                            return this.parseComplex(t.style, m, v, a, o)
                        },
                        formatter: lt
                    }),
                    St("backgroundSize", {
                        defaultValue: "0 0",
                        formatter: function(t) {
                            return t += "",
                            lt(t.indexOf(" ") === -1 ? t + " " + t : t)
                        }
                    }),
                    St("perspective", {
                        defaultValue: "0px",
                        prefix: !0
                    }),
                    St("perspectiveOrigin", {
                        defaultValue: "50% 50%",
                        prefix: !0
                    }),
                    St("transformStyle", {
                        prefix: !0
                    }),
                    St("backfaceVisibility", {
                        prefix: !0
                    }),
                    St("userSelect", {
                        prefix: !0
                    }),
                    St("margin", {
                        parser: _t("marginTop,marginRight,marginBottom,marginLeft")
                    }),
                    St("padding", {
                        parser: _t("paddingTop,paddingRight,paddingBottom,paddingLeft")
                    }),
                    St("clip", {
                        defaultValue: "rect(0px,0px,0px,0px)",
                        parser: function(t, e, i, n, a, o) {
                            var s, l, h;
                            return g < 9 ? (l = t.currentStyle,
                            h = g < 8 ? " " : ",",
                            s = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")",
                            e = this.format(e).split(",").join(h)) : (s = this.format(tt(t, this.p, r, !1, this.dflt)),
                            e = this.format(e)),
                            this.parseComplex(t.style, s, e, a, o)
                        }
                    }),
                    St("textShadow", {
                        defaultValue: "0px 0px 0px #999",
                        color: !0,
                        multi: !0
                    }),
                    St("autoRound,strictUnits", {
                        parser: function(t, e, i, n, r) {
                            return r
                        }
                    }),
                    St("border", {
                        defaultValue: "0px solid #000",
                        parser: function(t, e, i, n, a, o) {
                            var s = tt(t, "borderTopWidth", r, !1, "0px")
                              , l = this.format(e).split(" ")
                              , h = l[0].replace(M, "");
                            return "px" !== h && (s = parseFloat(s) / et(t, "borderTopWidth", 1, h) + h),
                            this.parseComplex(t.style, this.format(s + " " + tt(t, "borderTopStyle", r, !1, "solid") + " " + tt(t, "borderTopColor", r, !1, "#000")), l.join(" "), a, o)
                        },
                        color: !0,
                        formatter: function(t) {
                            var e = t.split(" ");
                            return e[0] + " " + (e[1] || "solid") + " " + (t.match(gt) || ["#000"])[0]
                        }
                    }),
                    St("borderWidth", {
                        parser: _t("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                    }),
                    St("float,cssFloat,styleFloat", {
                        parser: function(t, e, i, n, r, a) {
                            var o = t.style
                              , s = "cssFloat"in o ? "cssFloat" : "styleFloat";
                            return new xt(o,s,0,0,r,-1,i,!1,0,o[s],e)
                        }
                    });
                    var Yt = function(t) {
                        var e, i = this.t, n = i.filter || tt(this.data, "filter") || "", r = this.s + this.c * t | 0;
                        100 === r && (n.indexOf("atrix(") === -1 && n.indexOf("radient(") === -1 && n.indexOf("oader(") === -1 ? (i.removeAttribute("filter"),
                        e = !tt(this.data, "filter")) : (i.filter = n.replace(E, ""),
                        e = !0)),
                        e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"),
                        n.indexOf("pacity") === -1 ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(T, "opacity=" + r))
                    };
                    St("opacity,alpha,autoAlpha", {
                        defaultValue: "1",
                        parser: function(t, e, i, n, a, o) {
                            var s = parseFloat(tt(t, "opacity", r, !1, "1"))
                              , l = t.style
                              , h = "autoAlpha" === i;
                            return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s),
                            h && 1 === s && "hidden" === tt(t, "visibility", r) && 0 !== e && (s = 0),
                            Y ? a = new xt(l,"opacity",s,e - s,a) : (a = new xt(l,"opacity",100 * s,100 * (e - s),a),
                            a.xn1 = h ? 1 : 0,
                            l.zoom = 1,
                            a.type = 2,
                            a.b = "alpha(opacity=" + a.s + ")",
                            a.e = "alpha(opacity=" + (a.s + a.c) + ")",
                            a.data = t,
                            a.plugin = o,
                            a.setRatio = Yt),
                            h && (a = new xt(l,"visibility",0,0,a,-1,null,!1,0,0 !== s ? "inherit" : "hidden",0 === e ? "hidden" : "inherit"),
                            a.xs0 = "inherit",
                            n._overwriteProps.push(a.n),
                            n._overwriteProps.push(i)),
                            a
                        }
                    });
                    var qt = function(t, e) {
                        e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
                        t.removeProperty(e.replace(P, "-$1").toLowerCase())) : t.removeAttribute(e))
                    }
                      , Zt = function(t) {
                        if (this.t._gsClassPT = this,
                        1 === t || 0 === t) {
                            this.t.setAttribute("class", 0 === t ? this.b : this.e);
                            for (var e = this.data, i = this.t.style; e; )
                                e.v ? i[e.p] = e.v : qt(i, e.p),
                                e = e._next;
                            1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                        } else
                            this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                    };
                    St("className", {
                        parser: function(t, e, n, a, o, s, l) {
                            var h, c, u, p, d, f = t.getAttribute("class") || "", m = t.style.cssText;
                            if (o = a._classNamePT = new xt(t,n,0,0,o,2),
                            o.setRatio = Zt,
                            o.pr = -11,
                            i = !0,
                            o.b = f,
                            c = nt(t, r),
                            u = t._gsClassPT) {
                                for (p = {},
                                d = u.data; d; )
                                    p[d.p] = 1,
                                    d = d._next;
                                u.setRatio(1)
                            }
                            return t._gsClassPT = o,
                            o.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""),
                            t.setAttribute("class", o.e),
                            h = rt(t, c, nt(t), l, p),
                            t.setAttribute("class", f),
                            o.data = h.firstMPT,
                            t.style.cssText = m,
                            o = o.xfirst = a.parse(t, h.difs, o, s)
                        }
                    });
                    var Qt = function(t) {
                        if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                            var e, i, n, r, a, o = this.t.style, s = h.transform.parse;
                            if ("all" === this.e)
                                o.cssText = "",
                                r = !0;
                            else
                                for (e = this.e.split(" ").join("").split(","),
                                n = e.length; --n > -1; )
                                    i = e[n],
                                    h[i] && (h[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Ct : h[i].p),
                                    qt(o, i);
                            r && (qt(o, Rt),
                            a = this.t._gsTransform,
                            a && (a.svg && (this.t.removeAttribute("data-svg-origin"),
                            this.t.removeAttribute("transform")),
                            delete this.t._gsTransform))
                        }
                    };
                    for (St("clearProps", {
                        parser: function(t, e, n, r, a) {
                            return a = new xt(t,n,0,0,a,2),
                            a.setRatio = Qt,
                            a.e = e,
                            a.pr = -10,
                            a.data = r._tween,
                            i = !0,
                            a
                        }
                    }),
                    c = "bezier,throwProps,physicsProps,physics2D".split(","),
                    Mt = c.length; Mt--; )
                        Et(c[Mt]);
                    c = s.prototype,
                    c._firstPT = c._lastParsedTransform = c._transform = null,
                    c._onInitTween = function(t, e, o, l) {
                        if (!t.nodeType)
                            return !1;
                        this._target = v = t,
                        this._tween = o,
                        this._vars = e,
                        _ = l,
                        u = e.autoRound,
                        i = !1,
                        n = e.suffixMap || s.suffixMap,
                        r = $(t, ""),
                        a = this._overwriteProps;
                        var c, f, g, y, x, b, w, M, T, E = t.style;
                        if (p && "" === E.zIndex && (c = tt(t, "zIndex", r),
                        "auto" !== c && "" !== c || this._addLazySet(E, "zIndex", 0)),
                        "string" == typeof e && (y = E.cssText,
                        c = nt(t, r),
                        E.cssText = y + ";" + e,
                        c = rt(t, c, nt(t)).difs,
                        !Y && S.test(e) && (c.opacity = parseFloat(RegExp.$1)),
                        e = c,
                        E.cssText = y),
                        e.className ? this._firstPT = f = h.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null),
                        this._transformType) {
                            for (T = 3 === this._transformType,
                            Rt ? d && (p = !0,
                            "" === E.zIndex && (w = tt(t, "zIndex", r),
                            "auto" !== w && "" !== w || this._addLazySet(E, "zIndex", 0)),
                            m && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : E.zoom = 1,
                            g = f; g && g._next; )
                                g = g._next;
                            M = new xt(t,"transform",0,0,null,2),
                            this._linkCSSP(M, null, g),
                            M.setRatio = Rt ? Xt : Wt,
                            M.data = this._transform || jt(t, r, !0),
                            M.tween = o,
                            M.pr = -1,
                            a.pop()
                        }
                        if (i) {
                            for (; f; ) {
                                for (b = f._next,
                                g = y; g && g.pr > f.pr; )
                                    g = g._next;
                                (f._prev = g ? g._prev : x) ? f._prev._next = f : y = f,
                                (f._next = g) ? g._prev = f : x = f,
                                f = b
                            }
                            this._firstPT = y
                        }
                        return !0
                    }
                    ,
                    c.parse = function(t, e, i, a) {
                        var o, s, l, c, p, d, f, m, g, y, x = t.style;
                        for (o in e)
                            d = e[o],
                            "function" == typeof d && (d = d(_, v)),
                            s = h[o],
                            s ? i = s.parse(t, d, o, this, i, a, e) : (p = tt(t, o, r) + "",
                            g = "string" == typeof d,
                            "color" === o || "fill" === o || "stroke" === o || o.indexOf("Color") !== -1 || g && A.test(d) ? (g || (d = ft(d),
                            d = (d.length > 3 ? "rgba(" : "rgb(") + d.join(",") + ")"),
                            i = wt(x, o, p, d, !0, "transparent", i, 0, a)) : g && F.test(d) ? i = wt(x, o, p, d, !0, null, i, 0, a) : (l = parseFloat(p),
                            f = l || 0 === l ? p.substr((l + "").length) : "",
                            "" !== p && "auto" !== p || ("width" === o || "height" === o ? (l = st(t, o, r),
                            f = "px") : "left" === o || "top" === o ? (l = it(t, o, r),
                            f = "px") : (l = "opacity" !== o ? 0 : 1,
                            f = "")),
                            y = g && "=" === d.charAt(1),
                            y ? (c = parseInt(d.charAt(0) + "1", 10),
                            d = d.substr(2),
                            c *= parseFloat(d),
                            m = d.replace(M, "")) : (c = parseFloat(d),
                            m = g ? d.replace(M, "") : ""),
                            "" === m && (m = o in n ? n[o] : f),
                            d = c || 0 === c ? (y ? c + l : c) + m : e[o],
                            f !== m && "" !== m && (c || 0 === c) && l && (l = et(t, o, l, f),
                            "%" === m ? (l /= et(t, o, 100, "%") / 100,
                            e.strictUnits !== !0 && (p = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= et(t, o, 1, m) : "px" !== m && (c = et(t, o, c, m),
                            m = "px"),
                            y && (c || 0 === c) && (d = c + l + m)),
                            y && (c += l),
                            !l && 0 !== l || !c && 0 !== c ? void 0 !== x[o] && (d || d + "" != "NaN" && null != d) ? (i = new xt(x,o,c || l || 0,0,i,-1,o,!1,0,p,d),
                            i.xs0 = "none" !== d || "display" !== o && o.indexOf("Style") === -1 ? d : p) : Z("invalid " + o + " tween value: " + e[o]) : (i = new xt(x,o,l,c - l,i,0,o,u !== !1 && ("px" === m || "zIndex" === o),0,p,d),
                            i.xs0 = m))),
                            a && i && !i.plugin && (i.plugin = a);
                        return i
                    }
                    ,
                    c.setRatio = function(t) {
                        var e, i, n, r = this._firstPT, a = 1e-6;
                        if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                            if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                                for (; r; ) {
                                    if (e = r.c * t + r.s,
                                    r.r ? e = Math.round(e) : e < a && e > -a && (e = 0),
                                    r.type)
                                        if (1 === r.type)
                                            if (n = r.l,
                                            2 === n)
                                                r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                            else if (3 === n)
                                                r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                            else if (4 === n)
                                                r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                            else if (5 === n)
                                                r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                            else {
                                                for (i = r.xs0 + e + r.xs1,
                                                n = 1; n < r.l; n++)
                                                    i += r["xn" + n] + r["xs" + (n + 1)];
                                                r.t[r.p] = i
                                            }
                                        else
                                            r.type === -1 ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                    else
                                        r.t[r.p] = e + r.xs0;
                                    r = r._next
                                }
                            else
                                for (; r; )
                                    2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t),
                                    r = r._next;
                        else
                            for (; r; ) {
                                if (2 !== r.type)
                                    if (r.r && r.type !== -1)
                                        if (e = Math.round(r.s + r.c),
                                        r.type) {
                                            if (1 === r.type) {
                                                for (n = r.l,
                                                i = r.xs0 + e + r.xs1,
                                                n = 1; n < r.l; n++)
                                                    i += r["xn" + n] + r["xs" + (n + 1)];
                                                r.t[r.p] = i
                                            }
                                        } else
                                            r.t[r.p] = e + r.xs0;
                                    else
                                        r.t[r.p] = r.e;
                                else
                                    r.setRatio(t);
                                r = r._next
                            }
                    }
                    ,
                    c._enableTransforms = function(t) {
                        this._transform = this._transform || jt(this._target, r, !0),
                        this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3
                    }
                    ;
                    var Jt = function(t) {
                        this.t[this.p] = this.e,
                        this.data._linkCSSP(this, this._next, null, !0)
                    };
                    c._addLazySet = function(t, e, i) {
                        var n = this._firstPT = new xt(t,e,0,0,this._firstPT,2);
                        n.e = i,
                        n.setRatio = Jt,
                        n.data = this
                    }
                    ,
                    c._linkCSSP = function(t, e, i, n) {
                        return t && (e && (e._prev = t),
                        t._next && (t._next._prev = t._prev),
                        t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next,
                        n = !0),
                        i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t),
                        t._next = e,
                        t._prev = i),
                        t
                    }
                    ,
                    c._mod = function(t) {
                        for (var e = this._firstPT; e; )
                            "function" == typeof t[e.p] && t[e.p] === Math.round && (e.r = 1),
                            e = e._next
                    }
                    ,
                    c._kill = function(e) {
                        var i, n, r, a = e;
                        if (e.autoAlpha || e.alpha) {
                            a = {};
                            for (n in e)
                                a[n] = e[n];
                            a.opacity = 1,
                            a.autoAlpha && (a.visibility = 1)
                        }
                        for (e.className && (i = this._classNamePT) && (r = i.xfirst,
                        r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next),
                        i._next && this._linkCSSP(i._next, i._next._next, r._prev),
                        this._classNamePT = null),
                        i = this._firstPT; i; )
                            i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e),
                            n = i.plugin),
                            i = i._next;
                        return t.prototype._kill.call(this, a)
                    }
                    ;
                    var Kt = function(t, e, i) {
                        var n, r, a, o;
                        if (t.slice)
                            for (r = t.length; --r > -1; )
                                Kt(t[r], e, i);
                        else
                            for (n = t.childNodes,
                            r = n.length; --r > -1; )
                                a = n[r],
                                o = a.type,
                                a.style && (e.push(nt(a)),
                                i && i.push(a)),
                                1 !== o && 9 !== o && 11 !== o || !a.childNodes.length || Kt(a, e, i)
                    };
                    return s.cascadeTo = function(t, i, n) {
                        var r, a, o, s, l = e.to(t, i, n), h = [l], c = [], u = [], p = [], d = e._internals.reservedProps;
                        for (t = l._targets || l.target,
                        Kt(t, c, p),
                        l.render(i, !0, !0),
                        Kt(t, u),
                        l.render(0, !0, !0),
                        l._enabled(!0),
                        r = p.length; --r > -1; )
                            if (a = rt(p[r], c[r], u[r]),
                            a.firstMPT) {
                                a = a.difs;
                                for (o in n)
                                    d[o] && (a[o] = n[o]);
                                s = {};
                                for (o in a)
                                    s[o] = c[r][o];
                                h.push(e.fromTo(p[r], i, s, a))
                            }
                        return h
                    }
                    ,
                    t.activate([s]),
                    s
                }, !0),
                function() {
                    var t = o._gsDefine.plugin({
                        propName: "roundProps",
                        version: "1.6.0",
                        priority: -1,
                        API: 2,
                        init: function(t, e, i) {
                            return this._tween = i,
                            !0
                        }
                    })
                      , e = function(t) {
                        for (; t; )
                            t.f || t.blob || (t.m = Math.round),
                            t = t._next
                    }
                      , i = t.prototype;
                    i._onInitAllProps = function() {
                        for (var t, i, n, r = this._tween, a = r.vars.roundProps.join ? r.vars.roundProps : r.vars.roundProps.split(","), o = a.length, s = {}, l = r._propLookup.roundProps; --o > -1; )
                            s[a[o]] = Math.round;
                        for (o = a.length; --o > -1; )
                            for (t = a[o],
                            i = r._firstPT; i; )
                                n = i._next,
                                i.pg ? i.t._mod(s) : i.n === t && (2 === i.f && i.t ? e(i.t._firstPT) : (this._add(i.t, t, i.s, i.c),
                                n && (n._prev = i._prev),
                                i._prev ? i._prev._next = n : r._firstPT === i && (r._firstPT = n),
                                i._next = i._prev = null,
                                r._propLookup[t] = l)),
                                i = n;
                        return !1
                    }
                    ,
                    i._add = function(t, e, i, n) {
                        this._addTween(t, e, i, i + n, e, Math.round),
                        this._overwriteProps.push(e)
                    }
                }(),
                function() {
                    o._gsDefine.plugin({
                        propName: "attr",
                        API: 2,
                        version: "0.6.0",
                        init: function(t, e, i, n) {
                            var r, a;
                            if ("function" != typeof t.setAttribute)
                                return !1;
                            for (r in e)
                                a = e[r],
                                "function" == typeof a && (a = a(n, t)),
                                this._addTween(t, "setAttribute", t.getAttribute(r) + "", a + "", r, !1, r),
                                this._overwriteProps.push(r);
                            return !0
                        }
                    })
                }(),
                o._gsDefine.plugin({
                    propName: "directionalRotation",
                    version: "0.3.0",
                    API: 2,
                    init: function(t, e, i, n) {
                        "object" != typeof e && (e = {
                            rotation: e
                        }),
                        this.finals = {};
                        var r, a, o, s, l, h, c = e.useRadians === !0 ? 2 * Math.PI : 360, u = 1e-6;
                        for (r in e)
                            "useRadians" !== r && (s = e[r],
                            "function" == typeof s && (s = s(n, t)),
                            h = (s + "").split("_"),
                            a = h[0],
                            o = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()),
                            s = this.finals[r] = "string" == typeof a && "=" === a.charAt(1) ? o + parseInt(a.charAt(0) + "1", 10) * Number(a.substr(2)) : Number(a) || 0,
                            l = s - o,
                            h.length && (a = h.join("_"),
                            a.indexOf("short") !== -1 && (l %= c,
                            l !== l % (c / 2) && (l = l < 0 ? l + c : l - c)),
                            a.indexOf("_cw") !== -1 && l < 0 ? l = (l + 9999999999 * c) % c - (l / c | 0) * c : a.indexOf("ccw") !== -1 && l > 0 && (l = (l - 9999999999 * c) % c - (l / c | 0) * c)),
                            (l > u || l < -u) && (this._addTween(t, r, o, o + l, r),
                            this._overwriteProps.push(r)));
                        return !0
                    },
                    set: function(t) {
                        var e;
                        if (1 !== t)
                            this._super.setRatio.call(this, t);
                        else
                            for (e = this._firstPT; e; )
                                e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p],
                                e = e._next
                    }
                })._autoCSS = !0,
                o._gsDefine("easing.Back", ["easing.Ease"], function(t) {
                    var e, i, n, r = o.GreenSockGlobals || o, a = r.com.greensock, s = 2 * Math.PI, l = Math.PI / 2, h = a._class, c = function(e, i) {
                        var n = h("easing." + e, function() {}, !0)
                          , r = n.prototype = new t;
                        return r.constructor = n,
                        r.getRatio = i,
                        n
                    }, u = t.register || function() {}
                    , p = function(t, e, i, n, r) {
                        var a = h("easing." + t, {
                            easeOut: new e,
                            easeIn: new i,
                            easeInOut: new n
                        }, !0);
                        return u(a, t),
                        a
                    }, d = function(t, e, i) {
                        this.t = t,
                        this.v = e,
                        i && (this.next = i,
                        i.prev = this,
                        this.c = i.v - e,
                        this.gap = i.t - t)
                    }, f = function(e, i) {
                        var n = h("easing." + e, function(t) {
                            this._p1 = t || 0 === t ? t : 1.70158,
                            this._p2 = 1.525 * this._p1
                        }, !0)
                          , r = n.prototype = new t;
                        return r.constructor = n,
                        r.getRatio = i,
                        r.config = function(t) {
                            return new n(t)
                        }
                        ,
                        n
                    }, m = p("Back", f("BackOut", function(t) {
                        return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                    }), f("BackIn", function(t) {
                        return t * t * ((this._p1 + 1) * t - this._p1)
                    }), f("BackInOut", function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                    })), g = h("easing.SlowMo", function(t, e, i) {
                        e = e || 0 === e ? e : .7,
                        null == t ? t = .7 : t > 1 && (t = 1),
                        this._p = 1 !== t ? e : 0,
                        this._p1 = (1 - t) / 2,
                        this._p2 = t,
                        this._p3 = this._p1 + this._p2,
                        this._calcEnd = i === !0
                    }, !0), v = g.prototype = new t;
                    return v.constructor = g,
                    v.getRatio = function(t) {
                        var e = t + (.5 - t) * this._p;
                        return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                    }
                    ,
                    g.ease = new g(.7,.7),
                    v.config = g.config = function(t, e, i) {
                        return new g(t,e,i)
                    }
                    ,
                    e = h("easing.SteppedEase", function(t) {
                        t = t || 1,
                        this._p1 = 1 / t,
                        this._p2 = t + 1
                    }, !0),
                    v = e.prototype = new t,
                    v.constructor = e,
                    v.getRatio = function(t) {
                        return t < 0 ? t = 0 : t >= 1 && (t = .999999999),
                        (this._p2 * t >> 0) * this._p1
                    }
                    ,
                    v.config = e.config = function(t) {
                        return new e(t)
                    }
                    ,
                    i = h("easing.RoughEase", function(e) {
                        e = e || {};
                        for (var i, n, r, a, o, s, l = e.taper || "none", h = [], c = 0, u = 0 | (e.points || 20), p = u, f = e.randomize !== !1, m = e.clamp === !0, g = e.template instanceof t ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --p > -1; )
                            i = f ? Math.random() : 1 / u * p,
                            n = g ? g.getRatio(i) : i,
                            "none" === l ? r = v : "out" === l ? (a = 1 - i,
                            r = a * a * v) : "in" === l ? r = i * i * v : i < .5 ? (a = 2 * i,
                            r = a * a * .5 * v) : (a = 2 * (1 - i),
                            r = a * a * .5 * v),
                            f ? n += Math.random() * r - .5 * r : p % 2 ? n += .5 * r : n -= .5 * r,
                            m && (n > 1 ? n = 1 : n < 0 && (n = 0)),
                            h[c++] = {
                                x: i,
                                y: n
                            };
                        for (h.sort(function(t, e) {
                            return t.x - e.x
                        }),
                        s = new d(1,1,null),
                        p = u; --p > -1; )
                            o = h[p],
                            s = new d(o.x,o.y,s);
                        this._prev = new d(0,0,0 !== s.t ? s : s.next)
                    }, !0),
                    v = i.prototype = new t,
                    v.constructor = i,
                    v.getRatio = function(t) {
                        var e = this._prev;
                        if (t > e.t) {
                            for (; e.next && t >= e.t; )
                                e = e.next;
                            e = e.prev
                        } else
                            for (; e.prev && t <= e.t; )
                                e = e.prev;
                        return this._prev = e,
                        e.v + (t - e.t) / e.gap * e.c
                    }
                    ,
                    v.config = function(t) {
                        return new i(t)
                    }
                    ,
                    i.ease = new i,
                    p("Bounce", c("BounceOut", function(t) {
                        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                    }), c("BounceIn", function(t) {
                        return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                    }), c("BounceInOut", function(t) {
                        var e = t < .5;
                        return t = e ? 1 - 2 * t : 2 * t - 1,
                        t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
                        e ? .5 * (1 - t) : .5 * t + .5
                    })),
                    p("Circ", c("CircOut", function(t) {
                        return Math.sqrt(1 - (t -= 1) * t)
                    }), c("CircIn", function(t) {
                        return -(Math.sqrt(1 - t * t) - 1)
                    }), c("CircInOut", function(t) {
                        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                    })),
                    n = function(e, i, n) {
                        var r = h("easing." + e, function(t, e) {
                            this._p1 = t >= 1 ? t : 1,
                            this._p2 = (e || n) / (t < 1 ? t : 1),
                            this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0),
                            this._p2 = s / this._p2
                        }, !0)
                          , a = r.prototype = new t;
                        return a.constructor = r,
                        a.getRatio = i,
                        a.config = function(t, e) {
                            return new r(t,e)
                        }
                        ,
                        r
                    }
                    ,
                    p("Elastic", n("ElasticOut", function(t) {
                        return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
                    }, .3), n("ElasticIn", function(t) {
                        return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2))
                    }, .3), n("ElasticInOut", function(t) {
                        return (t *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
                    }, .45)),
                    p("Expo", c("ExpoOut", function(t) {
                        return 1 - Math.pow(2, -10 * t)
                    }), c("ExpoIn", function(t) {
                        return Math.pow(2, 10 * (t - 1)) - .001
                    }), c("ExpoInOut", function(t) {
                        return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                    })),
                    p("Sine", c("SineOut", function(t) {
                        return Math.sin(t * l)
                    }), c("SineIn", function(t) {
                        return -Math.cos(t * l) + 1
                    }), c("SineInOut", function(t) {
                        return -.5 * (Math.cos(Math.PI * t) - 1)
                    })),
                    h("easing.EaseLookup", {
                        find: function(e) {
                            return t.map[e]
                        }
                    }, !0),
                    u(r.SlowMo, "SlowMo", "ease,"),
                    u(i, "RoughEase", "ease,"),
                    u(e, "SteppedEase", "ease,"),
                    m
                }, !0)
            }),
            o._gsDefine && o._gsQueue.pop()(),
            function(a, o) {
                "use strict";
                var s = {}
                  , l = a.document
                  , h = a.GreenSockGlobals = a.GreenSockGlobals || a;
                if (!h.TweenLite) {
                    var c, u, p, d, f, m = function(t) {
                        var e, i = t.split("."), n = h;
                        for (e = 0; e < i.length; e++)
                            n[i[e]] = n = n[i[e]] || {};
                        return n
                    }, g = m("com.greensock"), v = 1e-10, _ = function(t) {
                        var e, i = [], n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]))
                            ;
                        return i
                    }, y = function() {}, x = function() {
                        var t = Object.prototype.toString
                          , e = t.call([]);
                        return function(i) {
                            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                        }
                    }(), b = {}, w = function(a, l, c, u) {
                        this.sc = b[a] ? b[a].sc : [],
                        b[a] = this,
                        this.gsClass = null,
                        this.func = c;
                        var p = [];
                        this.check = function(d) {
                            for (var f, g, v, _, y, x = l.length, M = x; --x > -1; )
                                (f = b[l[x]] || new w(l[x],[])).gsClass ? (p[x] = f.gsClass,
                                M--) : d && f.sc.push(this);
                            if (0 === M && c) {
                                if (g = ("com.greensock." + a).split("."),
                                v = g.pop(),
                                _ = m(g.join("."))[v] = this.gsClass = c.apply(c, p),
                                u)
                                    if (h[v] = s[v] = _,
                                    y = "undefined" != typeof t && t.exports,
                                    !y && i(608))
                                        n = [],
                                        r = function() {
                                            return _
                                        }
                                        .apply(e, n),
                                        !(void 0 !== r && (t.exports = r));
                                    else if (y)
                                        if (a === o) {
                                            t.exports = s[o] = _;
                                            for (x in s)
                                                _[x] = s[x]
                                        } else
                                            s[o] && (s[o][v] = _);
                                for (x = 0; x < this.sc.length; x++)
                                    this.sc[x].check()
                            }
                        }
                        ,
                        this.check(!0)
                    }, M = a._gsDefine = function(t, e, i, n) {
                        return new w(t,e,i,n)
                    }
                    , T = g._class = function(t, e, i) {
                        return e = e || function() {}
                        ,
                        M(t, [], function() {
                            return e
                        }, i),
                        e
                    }
                    ;
                    M.globals = h;
                    var S = [0, 0, 1, 1]
                      , E = T("easing.Ease", function(t, e, i, n) {
                        this._func = t,
                        this._type = i || 0,
                        this._power = n || 0,
                        this._params = e ? S.concat(e) : S
                    }, !0)
                      , A = E.map = {}
                      , P = E.register = function(t, e, i, n) {
                        for (var r, a, o, s, l = e.split(","), h = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --h > -1; )
                            for (a = l[h],
                            r = n ? T("easing." + a, null, !0) : g.easing[a] || {},
                            o = c.length; --o > -1; )
                                s = c[o],
                                A[a + "." + s] = A[s + a] = r[s] = t.getRatio ? t : t[s] || new t
                    }
                    ;
                    for (p = E.prototype,
                    p._calcEnd = !1,
                    p.getRatio = function(t) {
                        if (this._func)
                            return this._params[0] = t,
                            this._func.apply(null, this._params);
                        var e = this._type
                          , i = this._power
                          , n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n),
                        1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                    }
                    ,
                    c = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"],
                    u = c.length; --u > -1; )
                        p = c[u] + ",Power" + u,
                        P(new E(null,null,1,u), p, "easeOut", !0),
                        P(new E(null,null,2,u), p, "easeIn" + (0 === u ? ",easeNone" : "")),
                        P(new E(null,null,3,u), p, "easeInOut");
                    A.linear = g.easing.Linear.easeIn,
                    A.swing = g.easing.Quad.easeInOut;
                    var R = T("events.EventDispatcher", function(t) {
                        this._listeners = {},
                        this._eventTarget = t || this
                    });
                    p = R.prototype,
                    p.addEventListener = function(t, e, i, n, r) {
                        r = r || 0;
                        var a, o, s = this._listeners[t], l = 0;
                        for (this !== d || f || d.wake(),
                        null == s && (this._listeners[t] = s = []),
                        o = s.length; --o > -1; )
                            a = s[o],
                            a.c === e && a.s === i ? s.splice(o, 1) : 0 === l && a.pr < r && (l = o + 1);
                        s.splice(l, 0, {
                            c: e,
                            s: i,
                            up: n,
                            pr: r
                        })
                    }
                    ,
                    p.removeEventListener = function(t, e) {
                        var i, n = this._listeners[t];
                        if (n)
                            for (i = n.length; --i > -1; )
                                if (n[i].c === e)
                                    return void n.splice(i, 1)
                    }
                    ,
                    p.dispatchEvent = function(t) {
                        var e, i, n, r = this._listeners[t];
                        if (r)
                            for (e = r.length,
                            e > 1 && (r = r.slice(0)),
                            i = this._eventTarget; --e > -1; )
                                n = r[e],
                                n && (n.up ? n.c.call(n.s || i, {
                                    type: t,
                                    target: i
                                }) : n.c.call(n.s || i))
                    }
                    ;
                    var L = a.requestAnimationFrame
                      , C = a.cancelAnimationFrame
                      , O = Date.now || function() {
                        return (new Date).getTime()
                    }
                      , I = O();
                    for (c = ["ms", "moz", "webkit", "o"],
                    u = c.length; --u > -1 && !L; )
                        L = a[c[u] + "RequestAnimationFrame"],
                        C = a[c[u] + "CancelAnimationFrame"] || a[c[u] + "CancelRequestAnimationFrame"];
                    T("Ticker", function(t, e) {
                        var i, n, r, a, o, s = this, h = O(), c = !(e === !1 || !L) && "auto", u = 500, p = 33, m = "tick", g = function(t) {
                            var e, l, c = O() - I;
                            c > u && (h += c - p),
                            I += c,
                            s.time = (I - h) / 1e3,
                            e = s.time - o,
                            (!i || e > 0 || t === !0) && (s.frame++,
                            o += e + (e >= a ? .004 : a - e),
                            l = !0),
                            t !== !0 && (r = n(g)),
                            l && s.dispatchEvent(m)
                        };
                        R.call(s),
                        s.time = s.frame = 0,
                        s.tick = function() {
                            g(!0)
                        }
                        ,
                        s.lagSmoothing = function(t, e) {
                            u = t || 1 / v,
                            p = Math.min(e, u, 0)
                        }
                        ,
                        s.sleep = function() {
                            null != r && (c && C ? C(r) : clearTimeout(r),
                            n = y,
                            r = null,
                            s === d && (f = !1))
                        }
                        ,
                        s.wake = function(t) {
                            null !== r ? s.sleep() : t ? h += -I + (I = O()) : s.frame > 10 && (I = O() - u + 5),
                            n = 0 === i ? y : c && L ? L : function(t) {
                                return setTimeout(t, 1e3 * (o - s.time) + 1 | 0)
                            }
                            ,
                            s === d && (f = !0),
                            g(2)
                        }
                        ,
                        s.fps = function(t) {
                            return arguments.length ? (i = t,
                            a = 1 / (i || 60),
                            o = this.time + a,
                            void s.wake()) : i
                        }
                        ,
                        s.useRAF = function(t) {
                            return arguments.length ? (s.sleep(),
                            c = t,
                            void s.fps(i)) : c
                        }
                        ,
                        s.fps(t),
                        setTimeout(function() {
                            "auto" === c && s.frame < 5 && "hidden" !== l.visibilityState && s.useRAF(!1)
                        }, 1500)
                    }),
                    p = g.Ticker.prototype = new g.events.EventDispatcher,
                    p.constructor = g.Ticker;
                    var D = T("core.Animation", function(t, e) {
                        if (this.vars = e = e || {},
                        this._duration = this._totalDuration = t || 0,
                        this._delay = Number(e.delay) || 0,
                        this._timeScale = 1,
                        this._active = e.immediateRender === !0,
                        this.data = e.data,
                        this._reversed = e.reversed === !0,
                        $) {
                            f || d.wake();
                            var i = this.vars.useFrames ? K : $;
                            i.add(this, i._time),
                            this.vars.paused && this.paused(!0)
                        }
                    });
                    d = D.ticker = new g.Ticker,
                    p = D.prototype,
                    p._dirty = p._gc = p._initted = p._paused = !1,
                    p._totalTime = p._time = 0,
                    p._rawPrevTime = -1,
                    p._next = p._last = p._onUpdate = p._timeline = p.timeline = null,
                    p._paused = !1;
                    var U = function() {
                        f && O() - I > 2e3 && d.wake(),
                        setTimeout(U, 2e3)
                    };
                    U(),
                    p.play = function(t, e) {
                        return null != t && this.seek(t, e),
                        this.reversed(!1).paused(!1)
                    }
                    ,
                    p.pause = function(t, e) {
                        return null != t && this.seek(t, e),
                        this.paused(!0)
                    }
                    ,
                    p.resume = function(t, e) {
                        return null != t && this.seek(t, e),
                        this.paused(!1)
                    }
                    ,
                    p.seek = function(t, e) {
                        return this.totalTime(Number(t), e !== !1)
                    }
                    ,
                    p.restart = function(t, e) {
                        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
                    }
                    ,
                    p.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e),
                        this.reversed(!0).paused(!1)
                    }
                    ,
                    p.render = function(t, e, i) {}
                    ,
                    p.invalidate = function() {
                        return this._time = this._totalTime = 0,
                        this._initted = this._gc = !1,
                        this._rawPrevTime = -1,
                        !this._gc && this.timeline || this._enabled(!0),
                        this
                    }
                    ,
                    p.isActive = function() {
                        var t, e = this._timeline, i = this._startTime;
                        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale
                    }
                    ,
                    p._enabled = function(t, e) {
                        return f || d.wake(),
                        this._gc = !t,
                        this._active = this.isActive(),
                        e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)),
                        !1
                    }
                    ,
                    p._kill = function(t, e) {
                        return this._enabled(!1, !1)
                    }
                    ,
                    p.kill = function(t, e) {
                        return this._kill(t, e),
                        this
                    }
                    ,
                    p._uncache = function(t) {
                        for (var e = t ? this : this.timeline; e; )
                            e._dirty = !0,
                            e = e.timeline;
                        return this
                    }
                    ,
                    p._swapSelfInParams = function(t) {
                        for (var e = t.length, i = t.concat(); --e > -1; )
                            "{self}" === t[e] && (i[e] = this);
                        return i
                    }
                    ,
                    p._callback = function(t) {
                        var e = this.vars
                          , i = e[t]
                          , n = e[t + "Params"]
                          , r = e[t + "Scope"] || e.callbackScope || this
                          , a = n ? n.length : 0;
                        switch (a) {
                        case 0:
                            i.call(r);
                            break;
                        case 1:
                            i.call(r, n[0]);
                            break;
                        case 2:
                            i.call(r, n[0], n[1]);
                            break;
                        default:
                            i.apply(r, n)
                        }
                    }
                    ,
                    p.eventCallback = function(t, e, i, n) {
                        if ("on" === (t || "").substr(0, 2)) {
                            var r = this.vars;
                            if (1 === arguments.length)
                                return r[t];
                            null == e ? delete r[t] : (r[t] = e,
                            r[t + "Params"] = x(i) && i.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(i) : i,
                            r[t + "Scope"] = n),
                            "onUpdate" === t && (this._onUpdate = e)
                        }
                        return this
                    }
                    ,
                    p.delay = function(t) {
                        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay),
                        this._delay = t,
                        this) : this._delay
                    }
                    ,
                    p.duration = function(t) {
                        return arguments.length ? (this._duration = this._totalDuration = t,
                        this._uncache(!0),
                        this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0),
                        this) : (this._dirty = !1,
                        this._duration)
                    }
                    ,
                    p.totalDuration = function(t) {
                        return this._dirty = !1,
                        arguments.length ? this.duration(t) : this._totalDuration
                    }
                    ,
                    p.time = function(t, e) {
                        return arguments.length ? (this._dirty && this.totalDuration(),
                        this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                    }
                    ,
                    p.totalTime = function(t, e, i) {
                        if (f || d.wake(),
                        !arguments.length)
                            return this._totalTime;
                        if (this._timeline) {
                            if (t < 0 && !i && (t += this.totalDuration()),
                            this._timeline.smoothChildTiming) {
                                this._dirty && this.totalDuration();
                                var n = this._totalDuration
                                  , r = this._timeline;
                                if (t > n && !i && (t = n),
                                this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale,
                                r._dirty || this._uncache(!1),
                                r._timeline)
                                    for (; r._timeline; )
                                        r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0),
                                        r = r._timeline
                            }
                            this._gc && this._enabled(!0, !1),
                            this._totalTime === t && 0 !== this._duration || (k.length && et(),
                            this.render(t, e, !1),
                            k.length && et())
                        }
                        return this
                    }
                    ,
                    p.progress = p.totalProgress = function(t, e) {
                        var i = this.duration();
                        return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                    }
                    ,
                    p.startTime = function(t) {
                        return arguments.length ? (t !== this._startTime && (this._startTime = t,
                        this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)),
                        this) : this._startTime
                    }
                    ,
                    p.endTime = function(t) {
                        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                    }
                    ,
                    p.timeScale = function(t) {
                        if (!arguments.length)
                            return this._timeScale;
                        if (t = t || v,
                        this._timeline && this._timeline.smoothChildTiming) {
                            var e = this._pauseTime
                              , i = e || 0 === e ? e : this._timeline.totalTime();
                            this._startTime = i - (i - this._startTime) * this._timeScale / t
                        }
                        return this._timeScale = t,
                        this._uncache(!1)
                    }
                    ,
                    p.reversed = function(t) {
                        return arguments.length ? (t != this._reversed && (this._reversed = t,
                        this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)),
                        this) : this._reversed
                    }
                    ,
                    p.paused = function(t) {
                        if (!arguments.length)
                            return this._paused;
                        var e, i, n = this._timeline;
                        return t != this._paused && n && (f || t || d.wake(),
                        e = n.rawTime(),
                        i = e - this._pauseTime,
                        !t && n.smoothChildTiming && (this._startTime += i,
                        this._uncache(!1)),
                        this._pauseTime = t ? e : null,
                        this._paused = t,
                        this._active = this.isActive(),
                        !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale,
                        this.render(e, e === this._totalTime, !0))),
                        this._gc && !t && this._enabled(!0, !1),
                        this
                    }
                    ;
                    var F = T("core.SimpleTimeline", function(t) {
                        D.call(this, 0, t),
                        this.autoRemoveChildren = this.smoothChildTiming = !0
                    });
                    p = F.prototype = new D,
                    p.constructor = F,
                    p.kill()._gc = !1,
                    p._first = p._last = p._recent = null,
                    p._sortChildren = !1,
                    p.add = p.insert = function(t, e, i, n) {
                        var r, a;
                        if (t._startTime = Number(e || 0) + t._delay,
                        t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale),
                        t.timeline && t.timeline._remove(t, !0),
                        t.timeline = t._timeline = this,
                        t._gc && t._enabled(!0, !0),
                        r = this._last,
                        this._sortChildren)
                            for (a = t._startTime; r && r._startTime > a; )
                                r = r._prev;
                        return r ? (t._next = r._next,
                        r._next = t) : (t._next = this._first,
                        this._first = t),
                        t._next ? t._next._prev = t : this._last = t,
                        t._prev = r,
                        this._recent = t,
                        this._timeline && this._uncache(!0),
                        this
                    }
                    ,
                    p._remove = function(t, e) {
                        return t.timeline === this && (e || t._enabled(!1, !0),
                        t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next),
                        t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev),
                        t._next = t._prev = t.timeline = null,
                        t === this._recent && (this._recent = this._last),
                        this._timeline && this._uncache(!0)),
                        this
                    }
                    ,
                    p.render = function(t, e, i) {
                        var n, r = this._first;
                        for (this._totalTime = this._time = this._rawPrevTime = t; r; )
                            n = r._next,
                            (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)),
                            r = n
                    }
                    ,
                    p.rawTime = function() {
                        return f || d.wake(),
                        this._totalTime
                    }
                    ;
                    var N = T("TweenLite", function(t, e, i) {
                        if (D.call(this, e, i),
                        this.render = N.prototype.render,
                        null == t)
                            throw "Cannot tween a null target.";
                        this.target = t = "string" != typeof t ? t : N.selector(t) || t;
                        var n, r, o, s = t.jquery || t.length && t !== a && t[0] && (t[0] === a || t[0].nodeType && t[0].style && !t.nodeType), l = this.vars.overwrite;
                        if (this._overwrite = l = null == l ? J[N.defaultOverwrite] : "number" == typeof l ? l >> 0 : J[l],
                        (s || t instanceof Array || t.push && x(t)) && "number" != typeof t[0])
                            for (this._targets = o = _(t),
                            this._propLookup = [],
                            this._siblings = [],
                            n = 0; n < o.length; n++)
                                r = o[n],
                                r ? "string" != typeof r ? r.length && r !== a && r[0] && (r[0] === a || r[0].nodeType && r[0].style && !r.nodeType) ? (o.splice(n--, 1),
                                this._targets = o = o.concat(_(r))) : (this._siblings[n] = it(r, this, !1),
                                1 === l && this._siblings[n].length > 1 && rt(r, this, null, 1, this._siblings[n])) : (r = o[n--] = N.selector(r),
                                "string" == typeof r && o.splice(n + 1, 1)) : o.splice(n--, 1);
                        else
                            this._propLookup = {},
                            this._siblings = it(t, this, !1),
                            1 === l && this._siblings.length > 1 && rt(t, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === e && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -v,
                        this.render(Math.min(0, -this._delay)))
                    }, !0)
                      , z = function(t) {
                        return t && t.length && t !== a && t[0] && (t[0] === a || t[0].nodeType && t[0].style && !t.nodeType)
                    }
                      , B = function(t, e) {
                        var i, n = {};
                        for (i in t)
                            Q[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!Y[i] || Y[i] && Y[i]._autoCSS) || (n[i] = t[i],
                            delete t[i]);
                        t.css = n
                    };
                    p = N.prototype = new D,
                    p.constructor = N,
                    p.kill()._gc = !1,
                    p.ratio = 0,
                    p._firstPT = p._targets = p._overwrittenProps = p._startAt = null,
                    p._notifyPluginsOfEnabled = p._lazy = !1,
                    N.version = "1.19.1",
                    N.defaultEase = p._ease = new E(null,null,1,1),
                    N.defaultOverwrite = "auto",
                    N.ticker = d,
                    N.autoSleep = 120,
                    N.lagSmoothing = function(t, e) {
                        d.lagSmoothing(t, e)
                    }
                    ,
                    N.selector = a.$ || a.jQuery || function(t) {
                        var e = a.$ || a.jQuery;
                        return e ? (N.selector = e,
                        e(t)) : "undefined" == typeof l ? t : l.querySelectorAll ? l.querySelectorAll(t) : l.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
                    }
                    ;
                    var k = []
                      , G = {}
                      , V = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi
                      , H = function(t) {
                        for (var e, i = this._firstPT, n = 1e-6; i; )
                            e = i.blob ? 1 === t ? this.end : t ? this.join("") : this.start : i.c * t + i.s,
                            i.m ? e = i.m(e, this._target || i.t) : e < n && e > -n && !i.blob && (e = 0),
                            i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e,
                            i = i._next
                    }
                      , j = function(t, e, i, n) {
                        var r, a, o, s, l, h, c, u = [], p = 0, d = "", f = 0;
                        for (u.start = t,
                        u.end = e,
                        t = u[0] = t + "",
                        e = u[1] = e + "",
                        i && (i(u),
                        t = u[0],
                        e = u[1]),
                        u.length = 0,
                        r = t.match(V) || [],
                        a = e.match(V) || [],
                        n && (n._next = null,
                        n.blob = 1,
                        u._firstPT = u._applyPT = n),
                        l = a.length,
                        s = 0; s < l; s++)
                            c = a[s],
                            h = e.substr(p, e.indexOf(c, p) - p),
                            d += h || !s ? h : ",",
                            p += h.length,
                            f ? f = (f + 1) % 5 : "rgba(" === h.substr(-5) && (f = 1),
                            c === r[s] || r.length <= s ? d += c : (d && (u.push(d),
                            d = ""),
                            o = parseFloat(r[s]),
                            u.push(o),
                            u._firstPT = {
                                _next: u._firstPT,
                                t: u,
                                p: u.length - 1,
                                s: o,
                                c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - o) || 0,
                                f: 0,
                                m: f && f < 4 ? Math.round : 0
                            }),
                            p += c.length;
                        return d += e.substr(p),
                        d && u.push(d),
                        u.setRatio = H,
                        u
                    }
                      , W = function(t, e, i, n, r, a, o, s, l) {
                        "function" == typeof n && (n = n(l || 0, t));
                        var h, c = typeof t[e], u = "function" !== c ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3), p = "get" !== i ? i : u ? o ? t[u](o) : t[u]() : t[e], d = "string" == typeof n && "=" === n.charAt(1), f = {
                            t: t,
                            p: e,
                            s: p,
                            f: "function" === c,
                            pg: 0,
                            n: r || e,
                            m: a ? "function" == typeof a ? a : Math.round : 0,
                            pr: 0,
                            c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - p || 0
                        };
                        if (("number" != typeof p || "number" != typeof n && !d) && (o || isNaN(p) || !d && isNaN(n) || "boolean" == typeof p || "boolean" == typeof n ? (f.fp = o,
                        h = j(p, d ? f.s + f.c : n, s || N.defaultStringFilter, f),
                        f = {
                            t: h,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 2,
                            pg: 0,
                            n: r || e,
                            pr: 0,
                            m: 0
                        }) : (f.s = parseFloat(p),
                        d || (f.c = parseFloat(n) - f.s || 0))),
                        f.c)
                            return (f._next = this._firstPT) && (f._next._prev = f),
                            this._firstPT = f,
                            f
                    }
                      , X = N._internals = {
                        isArray: x,
                        isSelector: z,
                        lazyTweens: k,
                        blobDif: j
                    }
                      , Y = N._plugins = {}
                      , q = X.tweenLookup = {}
                      , Z = 0
                      , Q = X.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1
                    }
                      , J = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    }
                      , K = D._rootFramesTimeline = new F
                      , $ = D._rootTimeline = new F
                      , tt = 30
                      , et = X.lazyRender = function() {
                        var t, e = k.length;
                        for (G = {}; --e > -1; )
                            t = k[e],
                            t && t._lazy !== !1 && (t.render(t._lazy[0], t._lazy[1], !0),
                            t._lazy = !1);
                        k.length = 0
                    }
                    ;
                    $._startTime = d.time,
                    K._startTime = d.frame,
                    $._active = K._active = !0,
                    setTimeout(et, 1),
                    D._updateRoot = N.render = function() {
                        var t, e, i;
                        if (k.length && et(),
                        $.render((d.time - $._startTime) * $._timeScale, !1, !1),
                        K.render((d.frame - K._startTime) * K._timeScale, !1, !1),
                        k.length && et(),
                        d.frame >= tt) {
                            tt = d.frame + (parseInt(N.autoSleep, 10) || 120);
                            for (i in q) {
                                for (e = q[i].tweens,
                                t = e.length; --t > -1; )
                                    e[t]._gc && e.splice(t, 1);
                                0 === e.length && delete q[i]
                            }
                            if (i = $._first,
                            (!i || i._paused) && N.autoSleep && !K._first && 1 === d._listeners.tick.length) {
                                for (; i && i._paused; )
                                    i = i._next;
                                i || d.sleep()
                            }
                        }
                    }
                    ,
                    d.addEventListener("tick", D._updateRoot);
                    var it = function(t, e, i) {
                        var n, r, a = t._gsTweenID;
                        if (q[a || (t._gsTweenID = a = "t" + Z++)] || (q[a] = {
                            target: t,
                            tweens: []
                        }),
                        e && (n = q[a].tweens,
                        n[r = n.length] = e,
                        i))
                            for (; --r > -1; )
                                n[r] === e && n.splice(r, 1);
                        return q[a].tweens
                    }
                      , nt = function(t, e, i, n) {
                        var r, a, o = t.vars.onOverwrite;
                        return o && (r = o(t, e, i, n)),
                        o = N.onOverwrite,
                        o && (a = o(t, e, i, n)),
                        r !== !1 && a !== !1
                    }
                      , rt = function(t, e, i, n, r) {
                        var a, o, s, l;
                        if (1 === n || n >= 4) {
                            for (l = r.length,
                            a = 0; a < l; a++)
                                if ((s = r[a]) !== e)
                                    s._gc || s._kill(null, t, e) && (o = !0);
                                else if (5 === n)
                                    break;
                            return o
                        }
                        var h, c = e._startTime + v, u = [], p = 0, d = 0 === e._duration;
                        for (a = r.length; --a > -1; )
                            (s = r[a]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (h = h || at(e, 0, d),
                            0 === at(s, h, d) && (u[p++] = s)) : s._startTime <= c && s._startTime + s.totalDuration() / s._timeScale > c && ((d || !s._initted) && c - s._startTime <= 2e-10 || (u[p++] = s)));
                        for (a = p; --a > -1; )
                            if (s = u[a],
                            2 === n && s._kill(i, t, e) && (o = !0),
                            2 !== n || !s._firstPT && s._initted) {
                                if (2 !== n && !nt(s, e))
                                    continue;
                                s._enabled(!1, !1) && (o = !0)
                            }
                        return o
                    }
                      , at = function(t, e, i) {
                        for (var n = t._timeline, r = n._timeScale, a = t._startTime; n._timeline; ) {
                            if (a += n._startTime,
                            r *= n._timeScale,
                            n._paused)
                                return -100;
                            n = n._timeline
                        }
                        return a /= r,
                        a > e ? a - e : i && a === e || !t._initted && a - e < 2 * v ? v : (a += t.totalDuration() / t._timeScale / r) > e + v ? 0 : a - e - v
                    };
                    p._init = function() {
                        var t, e, i, n, r, a, o = this.vars, s = this._overwrittenProps, l = this._duration, h = !!o.immediateRender, c = o.ease;
                        if (o.startAt) {
                            this._startAt && (this._startAt.render(-1, !0),
                            this._startAt.kill()),
                            r = {};
                            for (n in o.startAt)
                                r[n] = o.startAt[n];
                            if (r.overwrite = !1,
                            r.immediateRender = !0,
                            r.lazy = h && o.lazy !== !1,
                            r.startAt = r.delay = null,
                            this._startAt = N.to(this.target, 0, r),
                            h)
                                if (this._time > 0)
                                    this._startAt = null;
                                else if (0 !== l)
                                    return
                        } else if (o.runBackwards && 0 !== l)
                            if (this._startAt)
                                this._startAt.render(-1, !0),
                                this._startAt.kill(),
                                this._startAt = null;
                            else {
                                0 !== this._time && (h = !1),
                                i = {};
                                for (n in o)
                                    Q[n] && "autoCSS" !== n || (i[n] = o[n]);
                                if (i.overwrite = 0,
                                i.data = "isFromStart",
                                i.lazy = h && o.lazy !== !1,
                                i.immediateRender = h,
                                this._startAt = N.to(this.target, 0, i),
                                h) {
                                    if (0 === this._time)
                                        return
                                } else
                                    this._startAt._init(),
                                    this._startAt._enabled(!1),
                                    this.vars.immediateRender && (this._startAt = null)
                            }
                        if (this._ease = c = c ? c instanceof E ? c : "function" == typeof c ? new E(c,o.easeParams) : A[c] || N.defaultEase : N.defaultEase,
                        o.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, o.easeParams)),
                        this._easeType = this._ease._type,
                        this._easePower = this._ease._power,
                        this._firstPT = null,
                        this._targets)
                            for (a = this._targets.length,
                            t = 0; t < a; t++)
                                this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                        else
                            e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                        if (e && N._onPluginEvent("_onInitAllProps", this),
                        s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)),
                        o.runBackwards)
                            for (i = this._firstPT; i; )
                                i.s += i.c,
                                i.c = -i.c,
                                i = i._next;
                        this._onUpdate = o.onUpdate,
                        this._initted = !0
                    }
                    ,
                    p._initProps = function(t, e, i, n, r) {
                        var o, s, l, h, c, u;
                        if (null == t)
                            return !1;
                        G[t._gsTweenID] && et(),
                        this.vars.css || t.style && t !== a && t.nodeType && Y.css && this.vars.autoCSS !== !1 && B(this.vars, t);
                        for (o in this.vars)
                            if (u = this.vars[o],
                            Q[o])
                                u && (u instanceof Array || u.push && x(u)) && u.join("").indexOf("{self}") !== -1 && (this.vars[o] = u = this._swapSelfInParams(u, this));
                            else if (Y[o] && (h = new Y[o])._onInitTween(t, this.vars[o], this, r)) {
                                for (this._firstPT = c = {
                                    _next: this._firstPT,
                                    t: h,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 1,
                                    n: o,
                                    pg: 1,
                                    pr: h._priority,
                                    m: 0
                                },
                                s = h._overwriteProps.length; --s > -1; )
                                    e[h._overwriteProps[s]] = this._firstPT;
                                (h._priority || h._onInitAllProps) && (l = !0),
                                (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0),
                                c._next && (c._next._prev = c)
                            } else
                                e[o] = W.call(this, t, o, "get", u, o, 0, null, this.vars.stringFilter, r);
                        return n && this._kill(n, t) ? this._initProps(t, e, i, n, r) : this._overwrite > 1 && this._firstPT && i.length > 1 && rt(t, this, e, this._overwrite, i) ? (this._kill(e, t),
                        this._initProps(t, e, i, n, r)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (G[t._gsTweenID] = !0),
                        l)
                    }
                    ,
                    p.render = function(t, e, i) {
                        var n, r, a, o, s = this._time, l = this._duration, h = this._rawPrevTime;
                        if (t >= l - 1e-7 && t >= 0)
                            this._totalTime = this._time = l,
                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1,
                            this._reversed || (n = !0,
                            r = "onComplete",
                            i = i || this._timeline.autoRemoveChildren),
                            0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0),
                            (h < 0 || t <= 0 && t >= -1e-7 || h === v && "isPause" !== this.data) && h !== t && (i = !0,
                            h > v && (r = "onReverseComplete")),
                            this._rawPrevTime = o = !e || t || h === t ? t : v);
                        else if (t < 1e-7)
                            this._totalTime = this._time = 0,
                            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
                            (0 !== s || 0 === l && h > 0) && (r = "onReverseComplete",
                            n = this._reversed),
                            t < 0 && (this._active = !1,
                            0 === l && (this._initted || !this.vars.lazy || i) && (h >= 0 && (h !== v || "isPause" !== this.data) && (i = !0),
                            this._rawPrevTime = o = !e || t || h === t ? t : v)),
                            this._initted || (i = !0);
                        else if (this._totalTime = this._time = t,
                        this._easeType) {
                            var c = t / l
                              , u = this._easeType
                              , p = this._easePower;
                            (1 === u || 3 === u && c >= .5) && (c = 1 - c),
                            3 === u && (c *= 2),
                            1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c),
                            1 === u ? this.ratio = 1 - c : 2 === u ? this.ratio = c : t / l < .5 ? this.ratio = c / 2 : this.ratio = 1 - c / 2
                        } else
                            this.ratio = this._ease.getRatio(t / l);
                        if (this._time !== s || i) {
                            if (!this._initted) {
                                if (this._init(),
                                !this._initted || this._gc)
                                    return;
                                if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration))
                                    return this._time = this._totalTime = s,
                                    this._rawPrevTime = h,
                                    k.push(this),
                                    void (this._lazy = [t, e]);
                                this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                            }
                            for (this._lazy !== !1 && (this._lazy = !1),
                            this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0),
                            0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")),
                            this.vars.onStart && (0 === this._time && 0 !== l || e || this._callback("onStart"))),
                            a = this._firstPT; a; )
                                a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s,
                                a = a._next;
                            this._onUpdate && (t < 0 && this._startAt && t !== -1e-4 && this._startAt.render(t, e, i),
                            e || (this._time !== s || n || i) && this._callback("onUpdate")),
                            r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, e, i),
                            n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                            this._active = !1),
                            !e && this.vars[r] && this._callback(r),
                            0 === l && this._rawPrevTime === v && o !== v && (this._rawPrevTime = 0)))
                        }
                    }
                    ,
                    p._kill = function(t, e, i) {
                        if ("all" === t && (t = null),
                        null == t && (null == e || e === this.target))
                            return this._lazy = !1,
                            this._enabled(!1, !1);
                        e = "string" != typeof e ? e || this._targets || this.target : N.selector(e) || e;
                        var n, r, a, o, s, l, h, c, u, p = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                        if ((x(e) || z(e)) && "number" != typeof e[0])
                            for (n = e.length; --n > -1; )
                                this._kill(t, e[n], i) && (l = !0);
                        else {
                            if (this._targets) {
                                for (n = this._targets.length; --n > -1; )
                                    if (e === this._targets[n]) {
                                        s = this._propLookup[n] || {},
                                        this._overwrittenProps = this._overwrittenProps || [],
                                        r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                        break
                                    }
                            } else {
                                if (e !== this.target)
                                    return !1;
                                s = this._propLookup,
                                r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                            }
                            if (s) {
                                if (h = t || s,
                                c = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill),
                                i && (N.onOverwrite || this.vars.onOverwrite)) {
                                    for (a in h)
                                        s[a] && (u || (u = []),
                                        u.push(a));
                                    if ((u || !t) && !nt(this, i, e, u))
                                        return !1
                                }
                                for (a in h)
                                    (o = s[a]) && (p && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s,
                                    l = !0),
                                    o.pg && o.t._kill(h) && (l = !0),
                                    o.pg && 0 !== o.t._overwriteProps.length || (o._prev ? o._prev._next = o._next : o === this._firstPT && (this._firstPT = o._next),
                                    o._next && (o._next._prev = o._prev),
                                    o._next = o._prev = null),
                                    delete s[a]),
                                    c && (r[a] = 1);
                                !this._firstPT && this._initted && this._enabled(!1, !1)
                            }
                        }
                        return l
                    }
                    ,
                    p.invalidate = function() {
                        return this._notifyPluginsOfEnabled && N._onPluginEvent("_onDisable", this),
                        this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null,
                        this._notifyPluginsOfEnabled = this._active = this._lazy = !1,
                        this._propLookup = this._targets ? {} : [],
                        D.prototype.invalidate.call(this),
                        this.vars.immediateRender && (this._time = -v,
                        this.render(Math.min(0, -this._delay))),
                        this
                    }
                    ,
                    p._enabled = function(t, e) {
                        if (f || d.wake(),
                        t && this._gc) {
                            var i, n = this._targets;
                            if (n)
                                for (i = n.length; --i > -1; )
                                    this._siblings[i] = it(n[i], this, !0);
                            else
                                this._siblings = it(this.target, this, !0)
                        }
                        return D.prototype._enabled.call(this, t, e),
                        !(!this._notifyPluginsOfEnabled || !this._firstPT) && N._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                    }
                    ,
                    N.to = function(t, e, i) {
                        return new N(t,e,i)
                    }
                    ,
                    N.from = function(t, e, i) {
                        return i.runBackwards = !0,
                        i.immediateRender = 0 != i.immediateRender,
                        new N(t,e,i)
                    }
                    ,
                    N.fromTo = function(t, e, i, n) {
                        return n.startAt = i,
                        n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender,
                        new N(t,e,n)
                    }
                    ,
                    N.delayedCall = function(t, e, i, n, r) {
                        return new N(e,0,{
                            delay: t,
                            onComplete: e,
                            onCompleteParams: i,
                            callbackScope: n,
                            onReverseComplete: e,
                            onReverseCompleteParams: i,
                            immediateRender: !1,
                            lazy: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }
                    ,
                    N.set = function(t, e) {
                        return new N(t,0,e)
                    }
                    ,
                    N.getTweensOf = function(t, e) {
                        if (null == t)
                            return [];
                        t = "string" != typeof t ? t : N.selector(t) || t;
                        var i, n, r, a;
                        if ((x(t) || z(t)) && "number" != typeof t[0]) {
                            for (i = t.length,
                            n = []; --i > -1; )
                                n = n.concat(N.getTweensOf(t[i], e));
                            for (i = n.length; --i > -1; )
                                for (a = n[i],
                                r = i; --r > -1; )
                                    a === n[r] && n.splice(i, 1)
                        } else
                            for (n = it(t).concat(),
                            i = n.length; --i > -1; )
                                (n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                        return n
                    }
                    ,
                    N.killTweensOf = N.killDelayedCallsTo = function(t, e, i) {
                        "object" == typeof e && (i = e,
                        e = !1);
                        for (var n = N.getTweensOf(t, e), r = n.length; --r > -1; )
                            n[r]._kill(i, t)
                    }
                    ;
                    var ot = T("plugins.TweenPlugin", function(t, e) {
                        this._overwriteProps = (t || "").split(","),
                        this._propName = this._overwriteProps[0],
                        this._priority = e || 0,
                        this._super = ot.prototype
                    }, !0);
                    if (p = ot.prototype,
                    ot.version = "1.19.0",
                    ot.API = 2,
                    p._firstPT = null,
                    p._addTween = W,
                    p.setRatio = H,
                    p._kill = function(t) {
                        var e, i = this._overwriteProps, n = this._firstPT;
                        if (null != t[this._propName])
                            this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1; )
                                null != t[i[e]] && i.splice(e, 1);
                        for (; n; )
                            null != t[n.n] && (n._next && (n._next._prev = n._prev),
                            n._prev ? (n._prev._next = n._next,
                            n._prev = null) : this._firstPT === n && (this._firstPT = n._next)),
                            n = n._next;
                        return !1
                    }
                    ,
                    p._mod = p._roundProps = function(t) {
                        for (var e, i = this._firstPT; i; )
                            e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")],
                            e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e),
                            i = i._next
                    }
                    ,
                    N._onPluginEvent = function(t, e) {
                        var i, n, r, a, o, s = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; s; ) {
                                for (o = s._next,
                                n = r; n && n.pr > s.pr; )
                                    n = n._next;
                                (s._prev = n ? n._prev : a) ? s._prev._next = s : r = s,
                                (s._next = n) ? n._prev = s : a = s,
                                s = o
                            }
                            s = e._firstPT = r
                        }
                        for (; s; )
                            s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0),
                            s = s._next;
                        return i
                    }
                    ,
                    ot.activate = function(t) {
                        for (var e = t.length; --e > -1; )
                            t[e].API === ot.API && (Y[(new t[e])._propName] = t[e]);
                        return !0
                    }
                    ,
                    M.plugin = function(t) {
                        if (!(t && t.propName && t.init && t.API))
                            throw "illegal plugin definition.";
                        var e, i = t.propName, n = t.priority || 0, r = t.overwriteProps, a = {
                            init: "_onInitTween",
                            set: "setRatio",
                            kill: "_kill",
                            round: "_mod",
                            mod: "_mod",
                            initAll: "_onInitAllProps"
                        }, o = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                            ot.call(this, i, n),
                            this._overwriteProps = r || []
                        }, t.global === !0), s = o.prototype = new ot(i);
                        s.constructor = o,
                        o.API = t.API;
                        for (e in a)
                            "function" == typeof t[e] && (s[a[e]] = t[e]);
                        return o.version = t.version,
                        ot.activate([o]),
                        o
                    }
                    ,
                    c = a._gsQueue) {
                        for (u = 0; u < c.length; u++)
                            c[u]();
                        for (p in b)
                            b[p].func || a.console.log("GSAP encountered missing dependency: " + p)
                    }
                    f = !1
                }
            }("undefined" != typeof t && t.exports && "undefined" != typeof a ? a : this || window, "TweenMax")
        }
        ).call(e, function() {
            return this
        }())
    },
    608: function(t, e) {
        (function(e) {
            t.exports = e
        }
        ).call(e, {})
    },
    612: function(t, e, i, n) {
        (function(t) {
            !function(t, i) {
                i(e)
            }(this, function(e) {
                "use strict";
                function i() {}
                function n(t, e) {
                    this.x = t || 0,
                    this.y = e || 0
                }
                function r(t, i, o, s, l, h, c, u, p, d) {
                    Object.defineProperty(this, "id", {
                        value: a()
                    }),
                    this.uuid = e.Math.generateUUID(),
                    this.name = "",
                    this.sourceFile = "",
                    this.image = void 0 !== t ? t : r.DEFAULT_IMAGE,
                    this.mipmaps = [],
                    this.mapping = void 0 !== i ? i : r.DEFAULT_MAPPING,
                    this.wrapS = void 0 !== o ? o : ba,
                    this.wrapT = void 0 !== s ? s : ba,
                    this.magFilter = void 0 !== l ? l : Ea,
                    this.minFilter = void 0 !== h ? h : Pa,
                    this.anisotropy = void 0 !== p ? p : 1,
                    this.format = void 0 !== c ? c : Ha,
                    this.type = void 0 !== u ? u : Ra,
                    this.offset = new n(0,0),
                    this.repeat = new n(1,1),
                    this.generateMipmaps = !0,
                    this.premultiplyAlpha = !1,
                    this.flipY = !0,
                    this.unpackAlignment = 4,
                    this.encoding = void 0 !== d ? d : vo,
                    this.version = 0,
                    this.onUpdate = null
                }
                function a() {
                    return Ao++
                }
                function o() {
                    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
                    arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                function s(t, e, i, n) {
                    this._x = t || 0,
                    this._y = e || 0,
                    this._z = i || 0,
                    this._w = void 0 !== n ? n : 1
                }
                function l(t, e, i) {
                    this.x = t || 0,
                    this.y = e || 0,
                    this.z = i || 0
                }
                function h(t, e) {
                    function i() {
                        var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1])
                          , e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        o = f.createBuffer(),
                        h = f.createBuffer(),
                        f.bindBuffer(f.ARRAY_BUFFER, o),
                        f.bufferData(f.ARRAY_BUFFER, t, f.STATIC_DRAW),
                        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, h),
                        f.bufferData(f.ELEMENT_ARRAY_BUFFER, e, f.STATIC_DRAW),
                        c = n(),
                        u = {
                            position: f.getAttribLocation(c, "position"),
                            uv: f.getAttribLocation(c, "uv")
                        },
                        p = {
                            uvOffset: f.getUniformLocation(c, "uvOffset"),
                            uvScale: f.getUniformLocation(c, "uvScale"),
                            rotation: f.getUniformLocation(c, "rotation"),
                            scale: f.getUniformLocation(c, "scale"),
                            color: f.getUniformLocation(c, "color"),
                            map: f.getUniformLocation(c, "map"),
                            opacity: f.getUniformLocation(c, "opacity"),
                            modelViewMatrix: f.getUniformLocation(c, "modelViewMatrix"),
                            projectionMatrix: f.getUniformLocation(c, "projectionMatrix"),
                            fogType: f.getUniformLocation(c, "fogType"),
                            fogDensity: f.getUniformLocation(c, "fogDensity"),
                            fogNear: f.getUniformLocation(c, "fogNear"),
                            fogFar: f.getUniformLocation(c, "fogFar"),
                            fogColor: f.getUniformLocation(c, "fogColor"),
                            alphaTest: f.getUniformLocation(c, "alphaTest")
                        };
                        var i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        i.width = 8,
                        i.height = 8;
                        var a = i.getContext("2d");
                        a.fillStyle = "white",
                        a.fillRect(0, 0, 8, 8),
                        d = new r(i),
                        d.needsUpdate = !0
                    }
                    function n() {
                        var e = f.createProgram()
                          , i = f.createShader(f.VERTEX_SHADER)
                          , n = f.createShader(f.FRAGMENT_SHADER);
                        return f.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")),
                        f.shaderSource(n, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")),
                        f.compileShader(i),
                        f.compileShader(n),
                        f.attachShader(e, i),
                        f.attachShader(e, n),
                        f.linkProgram(e),
                        e
                    }
                    function a(t, e) {
                        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
                    }
                    var o, h, c, u, p, d, f = t.context, m = t.state, g = new l, v = new s, _ = new l;
                    this.render = function(n, r) {
                        if (0 !== e.length) {
                            void 0 === c && i(),
                            f.useProgram(c),
                            m.initAttributes(),
                            m.enableAttribute(u.position),
                            m.enableAttribute(u.uv),
                            m.disableUnusedAttributes(),
                            m.disable(f.CULL_FACE),
                            m.enable(f.BLEND),
                            f.bindBuffer(f.ARRAY_BUFFER, o),
                            f.vertexAttribPointer(u.position, 2, f.FLOAT, !1, 16, 0),
                            f.vertexAttribPointer(u.uv, 2, f.FLOAT, !1, 16, 8),
                            f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, h),
                            f.uniformMatrix4fv(p.projectionMatrix, !1, r.projectionMatrix.elements),
                            m.activeTexture(f.TEXTURE0),
                            f.uniform1i(p.map, 0);
                            var s = 0
                              , l = 0
                              , y = n.fog;
                            y ? (f.uniform3f(p.fogColor, y.color.r, y.color.g, y.color.b),
                            y && y.isFog ? (f.uniform1f(p.fogNear, y.near),
                            f.uniform1f(p.fogFar, y.far),
                            f.uniform1i(p.fogType, 1),
                            s = 1,
                            l = 1) : y && y.isFogExp2 && (f.uniform1f(p.fogDensity, y.density),
                            f.uniform1i(p.fogType, 2),
                            s = 2,
                            l = 2)) : (f.uniform1i(p.fogType, 0),
                            s = 0,
                            l = 0);
                            for (var x = 0, b = e.length; x < b; x++) {
                                var w = e[x];
                                w.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, w.matrixWorld),
                                w.z = -w.modelViewMatrix.elements[14]
                            }
                            e.sort(a);
                            for (var M = [], x = 0, b = e.length; x < b; x++) {
                                var w = e[x]
                                  , T = w.material;
                                if (T.visible !== !1) {
                                    f.uniform1f(p.alphaTest, T.alphaTest),
                                    f.uniformMatrix4fv(p.modelViewMatrix, !1, w.modelViewMatrix.elements),
                                    w.matrixWorld.decompose(g, v, _),
                                    M[0] = _.x,
                                    M[1] = _.y;
                                    var S = 0;
                                    n.fog && T.fog && (S = l),
                                    s !== S && (f.uniform1i(p.fogType, S),
                                    s = S),
                                    null !== T.map ? (f.uniform2f(p.uvOffset, T.map.offset.x, T.map.offset.y),
                                    f.uniform2f(p.uvScale, T.map.repeat.x, T.map.repeat.y)) : (f.uniform2f(p.uvOffset, 0, 0),
                                    f.uniform2f(p.uvScale, 1, 1)),
                                    f.uniform1f(p.opacity, T.opacity),
                                    f.uniform3f(p.color, T.color.r, T.color.g, T.color.b),
                                    f.uniform1f(p.rotation, T.rotation),
                                    f.uniform2fv(p.scale, M),
                                    m.setBlending(T.blending, T.blendEquation, T.blendSrc, T.blendDst),
                                    m.setDepthTest(T.depthTest),
                                    m.setDepthWrite(T.depthWrite),
                                    T.map ? t.setTexture2D(T.map, 0) : t.setTexture2D(d, 0),
                                    f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0)
                                }
                            }
                            m.enable(f.CULL_FACE),
                            t.resetGLState()
                        }
                    }
                }
                function c(t, e) {
                    this.min = void 0 !== t ? t : new n(+(1 / 0),+(1 / 0)),
                    this.max = void 0 !== e ? e : new n(-(1 / 0),-(1 / 0))
                }
                function u(t, e) {
                    function i() {
                        var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1])
                          , e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        a = m.createBuffer(),
                        o = m.createBuffer(),
                        m.bindBuffer(m.ARRAY_BUFFER, a),
                        m.bufferData(m.ARRAY_BUFFER, t, m.STATIC_DRAW),
                        m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, o),
                        m.bufferData(m.ELEMENT_ARRAY_BUFFER, e, m.STATIC_DRAW),
                        d = m.createTexture(),
                        f = m.createTexture(),
                        g.bindTexture(m.TEXTURE_2D, d),
                        m.texImage2D(m.TEXTURE_2D, 0, m.RGB, 16, 16, 0, m.RGB, m.UNSIGNED_BYTE, null),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                        g.bindTexture(m.TEXTURE_2D, f),
                        m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 16, 16, 0, m.RGBA, m.UNSIGNED_BYTE, null),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                        s = {
                            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                        },
                        h = r(s),
                        u = {
                            vertex: m.getAttribLocation(h, "position"),
                            uv: m.getAttribLocation(h, "uv")
                        },
                        p = {
                            renderType: m.getUniformLocation(h, "renderType"),
                            map: m.getUniformLocation(h, "map"),
                            occlusionMap: m.getUniformLocation(h, "occlusionMap"),
                            opacity: m.getUniformLocation(h, "opacity"),
                            color: m.getUniformLocation(h, "color"),
                            scale: m.getUniformLocation(h, "scale"),
                            rotation: m.getUniformLocation(h, "rotation"),
                            screenPosition: m.getUniformLocation(h, "screenPosition")
                        }
                    }
                    function r(e) {
                        var i = m.createProgram()
                          , n = m.createShader(m.FRAGMENT_SHADER)
                          , r = m.createShader(m.VERTEX_SHADER)
                          , a = "precision " + t.getPrecision() + " float;\n";
                        return m.shaderSource(n, a + e.fragmentShader),
                        m.shaderSource(r, a + e.vertexShader),
                        m.compileShader(n),
                        m.compileShader(r),
                        m.attachShader(i, n),
                        m.attachShader(i, r),
                        m.linkProgram(i),
                        i
                    }
                    var a, o, s, h, u, p, d, f, m = t.context, g = t.state;
                    this.render = function(r, s, v) {
                        if (0 !== e.length) {
                            var _ = new l
                              , y = v.w / v.z
                              , x = .5 * v.z
                              , b = .5 * v.w
                              , w = 16 / v.w
                              , M = new n(w * y,w)
                              , T = new l(1,1,0)
                              , S = new n(1,1)
                              , E = new c;
                            E.min.set(0, 0),
                            E.max.set(v.z - 16, v.w - 16),
                            void 0 === h && i(),
                            m.useProgram(h),
                            g.initAttributes(),
                            g.enableAttribute(u.vertex),
                            g.enableAttribute(u.uv),
                            g.disableUnusedAttributes(),
                            m.uniform1i(p.occlusionMap, 0),
                            m.uniform1i(p.map, 1),
                            m.bindBuffer(m.ARRAY_BUFFER, a),
                            m.vertexAttribPointer(u.vertex, 2, m.FLOAT, !1, 16, 0),
                            m.vertexAttribPointer(u.uv, 2, m.FLOAT, !1, 16, 8),
                            m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, o),
                            g.disable(m.CULL_FACE),
                            g.setDepthWrite(!1);
                            for (var A = 0, P = e.length; A < P; A++) {
                                w = 16 / v.w,
                                M.set(w * y, w);
                                var R = e[A];
                                if (_.set(R.matrixWorld.elements[12], R.matrixWorld.elements[13], R.matrixWorld.elements[14]),
                                _.applyMatrix4(s.matrixWorldInverse),
                                _.applyProjection(s.projectionMatrix),
                                T.copy(_),
                                S.x = v.x + T.x * x + x - 8,
                                S.y = v.y + T.y * b + b - 8,
                                E.containsPoint(S) === !0) {
                                    g.activeTexture(m.TEXTURE0),
                                    g.bindTexture(m.TEXTURE_2D, null),
                                    g.activeTexture(m.TEXTURE1),
                                    g.bindTexture(m.TEXTURE_2D, d),
                                    m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGB, S.x, S.y, 16, 16, 0),
                                    m.uniform1i(p.renderType, 0),
                                    m.uniform2f(p.scale, M.x, M.y),
                                    m.uniform3f(p.screenPosition, T.x, T.y, T.z),
                                    g.disable(m.BLEND),
                                    g.enable(m.DEPTH_TEST),
                                    m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                                    g.activeTexture(m.TEXTURE0),
                                    g.bindTexture(m.TEXTURE_2D, f),
                                    m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGBA, S.x, S.y, 16, 16, 0),
                                    m.uniform1i(p.renderType, 1),
                                    g.disable(m.DEPTH_TEST),
                                    g.activeTexture(m.TEXTURE1),
                                    g.bindTexture(m.TEXTURE_2D, d),
                                    m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                                    R.positionScreen.copy(T),
                                    R.customUpdateCallback ? R.customUpdateCallback(R) : R.updateLensFlares(),
                                    m.uniform1i(p.renderType, 2),
                                    g.enable(m.BLEND);
                                    for (var L = 0, C = R.lensFlares.length; L < C; L++) {
                                        var O = R.lensFlares[L];
                                        O.opacity > .001 && O.scale > .001 && (T.x = O.x,
                                        T.y = O.y,
                                        T.z = O.z,
                                        w = O.size * O.scale / v.w,
                                        M.x = w * y,
                                        M.y = w,
                                        m.uniform3f(p.screenPosition, T.x, T.y, T.z),
                                        m.uniform2f(p.scale, M.x, M.y),
                                        m.uniform1f(p.rotation, O.rotation),
                                        m.uniform1f(p.opacity, O.opacity),
                                        m.uniform3f(p.color, O.color.r, O.color.g, O.color.b),
                                        g.setBlending(O.blending, O.blendEquation, O.blendSrc, O.blendDst),
                                        t.setTexture2D(O.texture, 1),
                                        m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0))
                                    }
                                }
                            }
                            g.enable(m.CULL_FACE),
                            g.enable(m.DEPTH_TEST),
                            g.setDepthWrite(!0),
                            t.resetGLState()
                        }
                    }
                }
                function p(t, e, i, n, a, o, s, l, h, c) {
                    t = void 0 !== t ? t : [],
                    e = void 0 !== e ? e : da,
                    r.call(this, t, e, i, n, a, o, s, l, h, c),
                    this.flipY = !1
                }
                function d() {
                    this.seq = [],
                    this.map = {}
                }
                function f(t, e, i) {
                    var n = t[0];
                    if (n <= 0 || n > 0)
                        return t;
                    var r = e * i
                      , a = Lo[r];
                    if (void 0 === a && (a = new Float32Array(r),
                    Lo[r] = a),
                    0 !== e) {
                        n.toArray(a, 0);
                        for (var o = 1, s = 0; o !== e; ++o)
                            s += i,
                            t[o].toArray(a, s)
                    }
                    return a
                }
                function m(t, e) {
                    var i = Co[e];
                    void 0 === i && (i = new Int32Array(e),
                    Co[e] = i);
                    for (var n = 0; n !== e; ++n)
                        i[n] = t.allocTextureUnit();
                    return i
                }
                function g(t, e) {
                    t.uniform1f(this.addr, e)
                }
                function v(t, e) {
                    t.uniform1i(this.addr, e)
                }
                function _(t, e) {
                    void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
                }
                function y(t, e) {
                    void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
                }
                function x(t, e) {
                    void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
                }
                function b(t, e) {
                    t.uniformMatrix2fv(this.addr, !1, e.elements || e)
                }
                function w(t, e) {
                    t.uniformMatrix3fv(this.addr, !1, e.elements || e)
                }
                function M(t, e) {
                    t.uniformMatrix4fv(this.addr, !1, e.elements || e)
                }
                function T(t, e, i) {
                    var n = i.allocTextureUnit();
                    t.uniform1i(this.addr, n),
                    i.setTexture2D(e || Po, n)
                }
                function S(t, e, i) {
                    var n = i.allocTextureUnit();
                    t.uniform1i(this.addr, n),
                    i.setTextureCube(e || Ro, n)
                }
                function E(t, e) {
                    t.uniform2iv(this.addr, e)
                }
                function A(t, e) {
                    t.uniform3iv(this.addr, e)
                }
                function P(t, e) {
                    t.uniform4iv(this.addr, e)
                }
                function R(t) {
                    switch (t) {
                    case 5126:
                        return g;
                    case 35664:
                        return _;
                    case 35665:
                        return y;
                    case 35666:
                        return x;
                    case 35674:
                        return b;
                    case 35675:
                        return w;
                    case 35676:
                        return M;
                    case 35678:
                        return T;
                    case 35680:
                        return S;
                    case 5124:
                    case 35670:
                        return v;
                    case 35667:
                    case 35671:
                        return E;
                    case 35668:
                    case 35672:
                        return A;
                    case 35669:
                    case 35673:
                        return P
                    }
                }
                function L(t, e) {
                    t.uniform1fv(this.addr, e)
                }
                function C(t, e) {
                    t.uniform1iv(this.addr, e)
                }
                function O(t, e) {
                    t.uniform2fv(this.addr, f(e, this.size, 2))
                }
                function I(t, e) {
                    t.uniform3fv(this.addr, f(e, this.size, 3))
                }
                function D(t, e) {
                    t.uniform4fv(this.addr, f(e, this.size, 4))
                }
                function U(t, e) {
                    t.uniformMatrix2fv(this.addr, !1, f(e, this.size, 4))
                }
                function F(t, e) {
                    t.uniformMatrix3fv(this.addr, !1, f(e, this.size, 9))
                }
                function N(t, e) {
                    t.uniformMatrix4fv(this.addr, !1, f(e, this.size, 16))
                }
                function z(t, e, i) {
                    var n = e.length
                      , r = m(i, n);
                    t.uniform1iv(this.addr, r);
                    for (var a = 0; a !== n; ++a)
                        i.setTexture2D(e[a] || Po, r[a])
                }
                function B(t, e, i) {
                    var n = e.length
                      , r = m(i, n);
                    t.uniform1iv(this.addr, r);
                    for (var a = 0; a !== n; ++a)
                        i.setTextureCube(e[a] || Ro, r[a])
                }
                function k(t) {
                    switch (t) {
                    case 5126:
                        return L;
                    case 35664:
                        return O;
                    case 35665:
                        return I;
                    case 35666:
                        return D;
                    case 35674:
                        return U;
                    case 35675:
                        return F;
                    case 35676:
                        return N;
                    case 35678:
                        return z;
                    case 35680:
                        return B;
                    case 5124:
                    case 35670:
                        return C;
                    case 35667:
                    case 35671:
                        return E;
                    case 35668:
                    case 35672:
                        return A;
                    case 35669:
                    case 35673:
                        return P
                    }
                }
                function G(t, e, i) {
                    this.id = t,
                    this.addr = i,
                    this.setValue = R(e.type)
                }
                function V(t, e, i) {
                    this.id = t,
                    this.addr = i,
                    this.size = e.size,
                    this.setValue = k(e.type)
                }
                function H(t) {
                    this.id = t,
                    d.call(this)
                }
                function j(t, e) {
                    t.seq.push(e),
                    t.map[e.id] = e
                }
                function W(t, e, i) {
                    var n = t.name
                      , r = n.length;
                    for (Oo.lastIndex = 0; ; ) {
                        var a = Oo.exec(n)
                          , o = Oo.lastIndex
                          , s = a[1]
                          , l = "]" === a[2]
                          , h = a[3];
                        if (l && (s |= 0),
                        void 0 === h || "[" === h && o + 2 === r) {
                            j(i, void 0 === h ? new G(s,t,e) : new V(s,t,e));
                            break
                        }
                        var c = i.map
                          , u = c[s];
                        void 0 === u && (u = new H(s),
                        j(i, u)),
                        i = u
                    }
                }
                function X(t, e, i) {
                    d.call(this),
                    this.renderer = i;
                    for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r !== n; ++r) {
                        var a = t.getActiveUniform(e, r)
                          , o = a.name
                          , s = t.getUniformLocation(e, o);
                        W(a, s, this)
                    }
                }
                function Y(t, i, n, r, a, o, s) {
                    function l(t, e) {
                        if (t.width > e || t.height > e) {
                            var i = e / Math.max(t.width, t.height)
                              , n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                            n.width = Math.floor(t.width * i),
                            n.height = Math.floor(t.height * i);
                            var r = n.getContext("2d");
                            return r.drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height),
                            console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height, t),
                            n
                        }
                        return t
                    }
                    function h(t) {
                        return e.Math.isPowerOfTwo(t.width) && e.Math.isPowerOfTwo(t.height)
                    }
                    function c(t) {
                        if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
                            var i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                            i.width = e.Math.nearestPowerOfTwo(t.width),
                            i.height = e.Math.nearestPowerOfTwo(t.height);
                            var n = i.getContext("2d");
                            return n.drawImage(t, 0, 0, i.width, i.height),
                            console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t),
                            i
                        }
                        return t
                    }
                    function u(t) {
                        return t.wrapS !== ba || t.wrapT !== ba || t.minFilter !== Ma && t.minFilter !== Ea
                    }
                    function p(e) {
                        return e === Ma || e === Ta || e === Sa ? t.NEAREST : t.LINEAR
                    }
                    function d(t) {
                        var e = t.target;
                        e.removeEventListener("dispose", d),
                        m(e),
                        P.textures--
                    }
                    function f(t) {
                        var e = t.target;
                        e.removeEventListener("dispose", f),
                        g(e),
                        P.textures--
                    }
                    function m(e) {
                        var i = r.get(e);
                        if (e.image && i.__image__webglTextureCube)
                            t.deleteTexture(i.__image__webglTextureCube);
                        else {
                            if (void 0 === i.__webglInit)
                                return;
                            t.deleteTexture(i.__webglTexture)
                        }
                        r.delete(e)
                    }
                    function g(e) {
                        var i = r.get(e)
                          , n = r.get(e.texture);
                        if (e) {
                            if (void 0 !== n.__webglTexture && t.deleteTexture(n.__webglTexture),
                            e.depthTexture && e.depthTexture.dispose(),
                            e && e.isWebGLRenderTargetCube)
                                for (var a = 0; a < 6; a++)
                                    t.deleteFramebuffer(i.__webglFramebuffer[a]),
                                    i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[a]);
                            else
                                t.deleteFramebuffer(i.__webglFramebuffer),
                                i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                            r.delete(e.texture),
                            r.delete(e)
                        }
                    }
                    function v(e, i) {
                        var a = r.get(e);
                        if (e.version > 0 && a.__version !== e.version) {
                            var o = e.image;
                            if (void 0 === o)
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                            else {
                                if (o.complete !== !1)
                                    return void b(a, e, i);
                                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                            }
                        }
                        n.activeTexture(t.TEXTURE0 + i),
                        n.bindTexture(t.TEXTURE_2D, a.__webglTexture)
                    }
                    function _(e, i) {
                        var s = r.get(e);
                        if (6 === e.image.length)
                            if (e.version > 0 && s.__version !== e.version) {
                                s.__image__webglTextureCube || (e.addEventListener("dispose", d),
                                s.__image__webglTextureCube = t.createTexture(),
                                P.textures++),
                                n.activeTexture(t.TEXTURE0 + i),
                                n.bindTexture(t.TEXTURE_CUBE_MAP, s.__image__webglTextureCube),
                                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                                for (var c = e && e.isCompressedTexture, u = e.image[0] && e.image[0].isDataTexture, p = [], f = 0; f < 6; f++)
                                    c || u ? p[f] = u ? e.image[f].image : e.image[f] : p[f] = l(e.image[f], a.maxCubemapSize);
                                var m = p[0]
                                  , g = h(m)
                                  , v = o(e.format)
                                  , _ = o(e.type);
                                x(t.TEXTURE_CUBE_MAP, e, g);
                                for (var f = 0; f < 6; f++)
                                    if (c)
                                        for (var y, b = p[f].mipmaps, w = 0, M = b.length; w < M; w++)
                                            y = b[w],
                                            e.format !== Ha && e.format !== Va ? n.getCompressedTextureFormats().indexOf(v) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, w, v, y.width, y.height, 0, y.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, w, v, y.width, y.height, 0, v, _, y.data);
                                    else
                                        u ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, v, p[f].width, p[f].height, 0, v, _, p[f].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, v, v, _, p[f]);
                                e.generateMipmaps && g && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                                s.__version = e.version,
                                e.onUpdate && e.onUpdate(e)
                            } else
                                n.activeTexture(t.TEXTURE0 + i),
                                n.bindTexture(t.TEXTURE_CUBE_MAP, s.__image__webglTextureCube)
                    }
                    function y(e, i) {
                        n.activeTexture(t.TEXTURE0 + i),
                        n.bindTexture(t.TEXTURE_CUBE_MAP, r.get(e).__webglTexture)
                    }
                    function x(e, n, s) {
                        var l;
                        if (s ? (t.texParameteri(e, t.TEXTURE_WRAP_S, o(n.wrapS)),
                        t.texParameteri(e, t.TEXTURE_WRAP_T, o(n.wrapT)),
                        t.texParameteri(e, t.TEXTURE_MAG_FILTER, o(n.magFilter)),
                        t.texParameteri(e, t.TEXTURE_MIN_FILTER, o(n.minFilter))) : (t.texParameteri(e, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                        t.texParameteri(e, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                        n.wrapS === ba && n.wrapT === ba || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", n),
                        t.texParameteri(e, t.TEXTURE_MAG_FILTER, p(n.magFilter)),
                        t.texParameteri(e, t.TEXTURE_MIN_FILTER, p(n.minFilter)),
                        n.minFilter !== Ma && n.minFilter !== Ea && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", n)),
                        l = i.get("EXT_texture_filter_anisotropic")) {
                            if (n.type === Ua && null === i.get("OES_texture_float_linear"))
                                return;
                            if (n.type === Fa && null === i.get("OES_texture_half_float_linear"))
                                return;
                            (n.anisotropy > 1 || r.get(n).__currentAnisotropy) && (t.texParameterf(e, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(n.anisotropy, a.getMaxAnisotropy())),
                            r.get(n).__currentAnisotropy = n.anisotropy)
                        }
                    }
                    function b(e, i, r) {
                        void 0 === e.__webglInit && (e.__webglInit = !0,
                        i.addEventListener("dispose", d),
                        e.__webglTexture = t.createTexture(),
                        P.textures++),
                        n.activeTexture(t.TEXTURE0 + r),
                        n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
                        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
                        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
                        t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
                        var s = l(i.image, a.maxTextureSize);
                        u(i) && h(s) === !1 && (s = c(s));
                        var p = h(s)
                          , f = o(i.format)
                          , m = o(i.type);
                        x(t.TEXTURE_2D, i, p);
                        var g, v = i.mipmaps;
                        if (i && i.isDepthTexture) {
                            var _ = t.DEPTH_COMPONENT;
                            if (i.type === Ua) {
                                if (!R)
                                    throw new Error("Float Depth Texture only supported in WebGL2.0");
                                _ = t.DEPTH_COMPONENT32F
                            } else
                                R && (_ = t.DEPTH_COMPONENT16);
                            i.format === qa && (_ = t.DEPTH_STENCIL),
                            n.texImage2D(t.TEXTURE_2D, 0, _, s.width, s.height, 0, f, m, null)
                        } else if (i && i.isDataTexture)
                            if (v.length > 0 && p) {
                                for (var y = 0, b = v.length; y < b; y++)
                                    g = v[y],
                                    n.texImage2D(t.TEXTURE_2D, y, f, g.width, g.height, 0, f, m, g.data);
                                i.generateMipmaps = !1
                            } else
                                n.texImage2D(t.TEXTURE_2D, 0, f, s.width, s.height, 0, f, m, s.data);
                        else if (i && i.isCompressedTexture)
                            for (var y = 0, b = v.length; y < b; y++)
                                g = v[y],
                                i.format !== Ha && i.format !== Va ? n.getCompressedTextureFormats().indexOf(f) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, y, f, g.width, g.height, 0, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, y, f, g.width, g.height, 0, f, m, g.data);
                        else if (v.length > 0 && p) {
                            for (var y = 0, b = v.length; y < b; y++)
                                g = v[y],
                                n.texImage2D(t.TEXTURE_2D, y, f, f, m, g);
                            i.generateMipmaps = !1
                        } else
                            n.texImage2D(t.TEXTURE_2D, 0, f, f, m, s);
                        i.generateMipmaps && p && t.generateMipmap(t.TEXTURE_2D),
                        e.__version = i.version,
                        i.onUpdate && i.onUpdate(i)
                    }
                    function w(e, i, a, s) {
                        var l = o(i.texture.format)
                          , h = o(i.texture.type);
                        n.texImage2D(s, 0, l, i.width, i.height, 0, l, h, null),
                        t.bindFramebuffer(t.FRAMEBUFFER, e),
                        t.framebufferTexture2D(t.FRAMEBUFFER, a, s, r.get(i.texture).__webglTexture, 0),
                        t.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                    function M(e, i) {
                        t.bindRenderbuffer(t.RENDERBUFFER, e),
                        i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, i.width, i.height),
                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, i.width, i.height),
                        t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, i.width, i.height),
                        t.bindRenderbuffer(t.RENDERBUFFER, null)
                    }
                    function T(e, i) {
                        var n = i && i.isWebGLRenderTargetCube;
                        if (n)
                            throw new Error("Depth Texture with cube render targets is not supported!");
                        if (t.bindFramebuffer(t.FRAMEBUFFER, e),
                        !i.depthTexture || !i.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
                        i.depthTexture.image.height = i.height,
                        i.depthTexture.needsUpdate = !0),
                        v(i.depthTexture, 0);
                        var a = r.get(i.depthTexture).__webglTexture;
                        if (i.depthTexture.format === Ya)
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0);
                        else {
                            if (i.depthTexture.format !== qa)
                                throw new Error("Unknown depthTexture format");
                            t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0)
                        }
                    }
                    function S(e) {
                        var i = r.get(e)
                          , n = e && e.isWebGLRenderTargetCube;
                        if (e.depthTexture) {
                            if (n)
                                throw new Error("target.depthTexture not supported in Cube render targets");
                            T(i.__webglFramebuffer, e)
                        } else if (n) {
                            i.__webglDepthbuffer = [];
                            for (var a = 0; a < 6; a++)
                                t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer[a]),
                                i.__webglDepthbuffer[a] = t.createRenderbuffer(),
                                M(i.__webglDepthbuffer[a], e)
                        } else
                            t.bindFramebuffer(t.FRAMEBUFFER, i.__webglFramebuffer),
                            i.__webglDepthbuffer = t.createRenderbuffer(),
                            M(i.__webglDepthbuffer, e);
                        t.bindFramebuffer(t.FRAMEBUFFER, null)
                    }
                    function E(e) {
                        var i = r.get(e)
                          , a = r.get(e.texture);
                        e.addEventListener("dispose", f),
                        a.__webglTexture = t.createTexture(),
                        P.textures++;
                        var o = e && e.isWebGLRenderTargetCube
                          , s = h(e);
                        if (o) {
                            i.__webglFramebuffer = [];
                            for (var l = 0; l < 6; l++)
                                i.__webglFramebuffer[l] = t.createFramebuffer()
                        } else
                            i.__webglFramebuffer = t.createFramebuffer();
                        if (o) {
                            n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture),
                            x(t.TEXTURE_CUBE_MAP, e.texture, s);
                            for (var l = 0; l < 6; l++)
                                w(i.__webglFramebuffer[l], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + l);
                            e.texture.generateMipmaps && s && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                            n.bindTexture(t.TEXTURE_CUBE_MAP, null)
                        } else
                            n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
                            x(t.TEXTURE_2D, e.texture, s),
                            w(i.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
                            e.texture.generateMipmaps && s && t.generateMipmap(t.TEXTURE_2D),
                            n.bindTexture(t.TEXTURE_2D, null);
                        e.depthBuffer && S(e)
                    }
                    function A(e) {
                        var i = e.texture;
                        if (i.generateMipmaps && h(e) && i.minFilter !== Ma && i.minFilter !== Ea) {
                            var a = e && e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D
                              , o = r.get(i).__webglTexture;
                            n.bindTexture(a, o),
                            t.generateMipmap(a),
                            n.bindTexture(a, null)
                        }
                    }
                    var P = s.memory
                      , R = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
                    this.setTexture2D = v,
                    this.setTextureCube = _,
                    this.setTextureCubeDynamic = y,
                    this.setupRenderTarget = E,
                    this.updateRenderTargetMipmap = A
                }
                function q(t, e, i, n) {
                    this.x = t || 0,
                    this.y = e || 0,
                    this.z = i || 0,
                    this.w = void 0 !== n ? n : 1
                }
                function Z(t, e, i) {
                    function n() {
                        var e = !1
                          , i = new q
                          , n = null
                          , r = new q;
                        return {
                            setMask: function(i) {
                                n === i || e || (t.colorMask(i, i, i, i),
                                n = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, n, a, o) {
                                i.set(e, n, a, o),
                                r.equals(i) === !1 && (t.clearColor(e, n, a, o),
                                r.copy(i))
                            },
                            reset: function() {
                                e = !1,
                                n = null,
                                r.set(0, 0, 0, 1)
                            }
                        }
                    }
                    function r() {
                        var e = !1
                          , i = null
                          , n = null
                          , r = null;
                        return {
                            setTest: function(e) {
                                e ? p(t.DEPTH_TEST) : d(t.DEPTH_TEST)
                            },
                            setMask: function(n) {
                                i === n || e || (t.depthMask(n),
                                i = n)
                            },
                            setFunc: function(e) {
                                if (n !== e) {
                                    if (e)
                                        switch (e) {
                                        case Qr:
                                            t.depthFunc(t.NEVER);
                                            break;
                                        case Jr:
                                            t.depthFunc(t.ALWAYS);
                                            break;
                                        case Kr:
                                            t.depthFunc(t.LESS);
                                            break;
                                        case $r:
                                            t.depthFunc(t.LEQUAL);
                                            break;
                                        case ta:
                                            t.depthFunc(t.EQUAL);
                                            break;
                                        case ea:
                                            t.depthFunc(t.GEQUAL);
                                            break;
                                        case ia:
                                            t.depthFunc(t.GREATER);
                                            break;
                                        case na:
                                            t.depthFunc(t.NOTEQUAL);
                                            break;
                                        default:
                                            t.depthFunc(t.LEQUAL)
                                        }
                                    else
                                        t.depthFunc(t.LEQUAL);
                                    n = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                r !== e && (t.clearDepth(e),
                                r = e)
                            },
                            reset: function() {
                                e = !1,
                                i = null,
                                n = null,
                                r = null
                            }
                        }
                    }
                    function a() {
                        var e = !1
                          , i = null
                          , n = null
                          , r = null
                          , a = null
                          , o = null
                          , s = null
                          , l = null
                          , h = null;
                        return {
                            setTest: function(e) {
                                e ? p(t.STENCIL_TEST) : d(t.STENCIL_TEST)
                            },
                            setMask: function(n) {
                                i === n || e || (t.stencilMask(n),
                                i = n)
                            },
                            setFunc: function(e, i, o) {
                                n === e && r === i && a === o || (t.stencilFunc(e, i, o),
                                n = e,
                                r = i,
                                a = o)
                            },
                            setOp: function(e, i, n) {
                                o === e && s === i && l === n || (t.stencilOp(e, i, n),
                                o = e,
                                s = i,
                                l = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                h !== e && (t.clearStencil(e),
                                h = e)
                            },
                            reset: function() {
                                e = !1,
                                i = null,
                                n = null,
                                r = null,
                                a = null,
                                o = null,
                                s = null,
                                l = null,
                                h = null
                            }
                        }
                    }
                    function o(e, i, n) {
                        var r = new Uint8Array(4)
                          , a = t.createTexture();
                        t.bindTexture(e, a),
                        t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
                        t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                        for (var o = 0; o < n; o++)
                            t.texImage2D(i + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                        return a
                    }
                    function s() {
                        D(0, 0, 0, 1),
                        U(1),
                        F(0),
                        p(t.DEPTH_TEST),
                        y($r),
                        T(!1),
                        S(pr),
                        p(t.CULL_FACE),
                        p(t.BLEND),
                        m(Rr)
                    }
                    function l() {
                        for (var t = 0, e = j.length; t < e; t++)
                            j[t] = 0
                    }
                    function h(i) {
                        if (j[i] = 1,
                        0 === W[i] && (t.enableVertexAttribArray(i),
                        W[i] = 1),
                        0 !== X[i]) {
                            var n = e.get("ANGLE_instanced_arrays");
                            n.vertexAttribDivisorANGLE(i, 0),
                            X[i] = 0
                        }
                    }
                    function c(e, i, n) {
                        j[e] = 1,
                        0 === W[e] && (t.enableVertexAttribArray(e),
                        W[e] = 1),
                        X[e] !== i && (n.vertexAttribDivisorANGLE(e, i),
                        X[e] = i)
                    }
                    function u() {
                        for (var e = 0, i = W.length; e !== i; ++e)
                            W[e] !== j[e] && (t.disableVertexAttribArray(e),
                            W[e] = 0)
                    }
                    function p(e) {
                        Y[e] !== !0 && (t.enable(e),
                        Y[e] = !0)
                    }
                    function d(e) {
                        Y[e] !== !1 && (t.disable(e),
                        Y[e] = !1)
                    }
                    function f() {
                        if (null === Z && (Z = [],
                        e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))
                            for (var i = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), n = 0; n < i.length; n++)
                                Z.push(i[n]);
                        return Z
                    }
                    function m(e, n, r, a, o, s, l, h) {
                        return e === Pr ? (d(t.BLEND),
                        void (Q = e)) : (p(t.BLEND),
                        e === Q && h === nt || (e === Lr ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD),
                        t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === Cr ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
                        t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === Or ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD),
                        t.blendFunc(t.ZERO, t.SRC_COLOR)) : h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                        t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)),
                        Q = e,
                        nt = h),
                        void (e === Ir ? (o = o || n,
                        s = s || r,
                        l = l || a,
                        n === J && o === tt || (t.blendEquationSeparate(i(n), i(o)),
                        J = n,
                        tt = o),
                        r === K && a === $ && s === et && l === it || (t.blendFuncSeparate(i(r), i(a), i(s), i(l)),
                        K = r,
                        $ = a,
                        et = s,
                        it = l)) : (J = null,
                        K = null,
                        $ = null,
                        tt = null,
                        et = null,
                        it = null)))
                    }
                    function g(t) {
                        k.setMask(t)
                    }
                    function v(t) {
                        G.setTest(t)
                    }
                    function _(t) {
                        G.setMask(t)
                    }
                    function y(t) {
                        G.setFunc(t)
                    }
                    function x(t) {
                        V.setTest(t)
                    }
                    function b(t) {
                        V.setMask(t)
                    }
                    function w(t, e, i) {
                        V.setFunc(t, e, i)
                    }
                    function M(t, e, i) {
                        V.setOp(t, e, i)
                    }
                    function T(e) {
                        rt !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW),
                        rt = e)
                    }
                    function S(e) {
                        e !== ur ? (p(t.CULL_FACE),
                        e !== at && (e === pr ? t.cullFace(t.BACK) : e === dr ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : d(t.CULL_FACE),
                        at = e
                    }
                    function E(e) {
                        e !== ot && (t.lineWidth(e),
                        ot = e)
                    }
                    function A(e, i, n) {
                        e ? (p(t.POLYGON_OFFSET_FILL),
                        st === i && lt === n || (t.polygonOffset(i, n),
                        st = i,
                        lt = n)) : d(t.POLYGON_OFFSET_FILL)
                    }
                    function P() {
                        return ht
                    }
                    function R(e) {
                        ht = e,
                        e ? p(t.SCISSOR_TEST) : d(t.SCISSOR_TEST)
                    }
                    function L(e) {
                        void 0 === e && (e = t.TEXTURE0 + ct - 1),
                        ut !== e && (t.activeTexture(e),
                        ut = e)
                    }
                    function C(e, i) {
                        null === ut && L();
                        var n = pt[ut];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        },
                        pt[ut] = n),
                        n.type === e && n.texture === i || (t.bindTexture(e, i || mt[e]),
                        n.type = e,
                        n.texture = i)
                    }
                    function O() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error(t)
                        }
                    }
                    function I() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error(t)
                        }
                    }
                    function D(t, e, i, n) {
                        k.setClear(t, e, i, n)
                    }
                    function U(t) {
                        G.setClear(t)
                    }
                    function F(t) {
                        V.setClear(t)
                    }
                    function N(e) {
                        dt.equals(e) === !1 && (t.scissor(e.x, e.y, e.z, e.w),
                        dt.copy(e))
                    }
                    function z(e) {
                        ft.equals(e) === !1 && (t.viewport(e.x, e.y, e.z, e.w),
                        ft.copy(e))
                    }
                    function B() {
                        for (var e = 0; e < W.length; e++)
                            1 === W[e] && (t.disableVertexAttribArray(e),
                            W[e] = 0);
                        Y = {},
                        Z = null,
                        ut = null,
                        pt = {},
                        Q = null,
                        rt = null,
                        at = null,
                        k.reset(),
                        G.reset(),
                        V.reset()
                    }
                    var k = new n
                      , G = new r
                      , V = new a
                      , H = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                      , j = new Uint8Array(H)
                      , W = new Uint8Array(H)
                      , X = new Uint8Array(H)
                      , Y = {}
                      , Z = null
                      , Q = null
                      , J = null
                      , K = null
                      , $ = null
                      , tt = null
                      , et = null
                      , it = null
                      , nt = !1
                      , rt = null
                      , at = null
                      , ot = null
                      , st = null
                      , lt = null
                      , ht = null
                      , ct = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                      , ut = null
                      , pt = {}
                      , dt = new q
                      , ft = new q
                      , mt = {};
                    return mt[t.TEXTURE_2D] = o(t.TEXTURE_2D, t.TEXTURE_2D, 1),
                    mt[t.TEXTURE_CUBE_MAP] = o(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                    {
                        buffers: {
                            color: k,
                            depth: G,
                            stencil: V
                        },
                        init: s,
                        initAttributes: l,
                        enableAttribute: h,
                        enableAttributeAndDivisor: c,
                        disableUnusedAttributes: u,
                        enable: p,
                        disable: d,
                        getCompressedTextureFormats: f,
                        setBlending: m,
                        setColorWrite: g,
                        setDepthTest: v,
                        setDepthWrite: _,
                        setDepthFunc: y,
                        setStencilTest: x,
                        setStencilWrite: b,
                        setStencilFunc: w,
                        setStencilOp: M,
                        setFlipSided: T,
                        setCullFace: S,
                        setLineWidth: E,
                        setPolygonOffset: A,
                        getScissorTest: P,
                        setScissorTest: R,
                        activeTexture: L,
                        bindTexture: C,
                        compressedTexImage2D: O,
                        texImage2D: I,
                        clearColor: D,
                        clearDepth: U,
                        clearStencil: F,
                        scissor: N,
                        viewport: z,
                        reset: B
                    }
                }
                function Q(t, i, n) {
                    this.uuid = e.Math.generateUUID(),
                    this.width = t,
                    this.height = i,
                    this.scissor = new q(0,0,t,i),
                    this.scissorTest = !1,
                    this.viewport = new q(0,0,t,i),
                    n = n || {},
                    void 0 === n.minFilter && (n.minFilter = Ea),
                    this.texture = new r(void 0,void 0,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
                    this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
                    this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer,
                    this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                }
                function J() {
                    Object.defineProperty(this, "id", {
                        value: K()
                    }),
                    this.uuid = e.Math.generateUUID(),
                    this.name = "",
                    this.type = "Material",
                    this.fog = !0,
                    this.lights = !0,
                    this.blending = Rr,
                    this.side = xr,
                    this.shading = Tr,
                    this.vertexColors = Sr,
                    this.opacity = 1,
                    this.transparent = !1,
                    this.blendSrc = Hr,
                    this.blendDst = jr,
                    this.blendEquation = Dr,
                    this.blendSrcAlpha = null,
                    this.blendDstAlpha = null,
                    this.blendEquationAlpha = null,
                    this.depthFunc = $r,
                    this.depthTest = !0,
                    this.depthWrite = !0,
                    this.clippingPlanes = null,
                    this.clipShadows = !1,
                    this.colorWrite = !0,
                    this.precision = null,
                    this.polygonOffset = !1,
                    this.polygonOffsetFactor = 0,
                    this.polygonOffsetUnits = 0,
                    this.alphaTest = 0,
                    this.premultipliedAlpha = !1,
                    this.overdraw = 0,
                    this.visible = !0,
                    this._needsUpdate = !0
                }
                function K() {
                    return Io++
                }
                function $(t) {
                    J.call(this),
                    this.type = "ShaderMaterial",
                    this.defines = {},
                    this.uniforms = {},
                    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                    this.linewidth = 1,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.clipping = !1,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    },
                    this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    },
                    this.index0AttributeName = void 0,
                    void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
                    this.setValues(t))
                }
                function tt(t, e, i) {
                    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
                }
                function et(t) {
                    J.call(this),
                    this.type = "MeshDepthMaterial",
                    this.depthPacking = So,
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.setValues(t)
                }
                function it(t, e) {
                    this.min = void 0 !== t ? t : new l(+(1 / 0),+(1 / 0),+(1 / 0)),
                    this.max = void 0 !== e ? e : new l(-(1 / 0),-(1 / 0),-(1 / 0))
                }
                function nt(t, e) {
                    this.center = void 0 !== t ? t : new l,
                    this.radius = void 0 !== e ? e : 0
                }
                function rt() {
                    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
                    arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                function at(t, e) {
                    this.normal = void 0 !== t ? t : new l(1,0,0),
                    this.constant = void 0 !== e ? e : 0
                }
                function ot(t, e, i, n, r, a) {
                    this.planes = [void 0 !== t ? t : new at, void 0 !== e ? e : new at, void 0 !== i ? i : new at, void 0 !== n ? n : new at, void 0 !== r ? r : new at, void 0 !== a ? a : new at]
                }
                function st(t, i, r, a) {
                    function s(e, i, n, r) {
                        var a = e.geometry
                          , o = null
                          , s = M
                          , l = e.customDepthMaterial;
                        if (n && (s = T,
                        l = e.customDistanceMaterial),
                        l)
                            o = l;
                        else {
                            var h = !1;
                            i.morphTargets && (a && a.isBufferGeometry ? h = a.morphAttributes && a.morphAttributes.position && a.morphAttributes.position.length > 0 : a && a.isGeometry && (h = a.morphTargets && a.morphTargets.length > 0));
                            var c = e.isSkinnedMesh && i.skinning
                              , u = 0;
                            h && (u |= x),
                            c && (u |= b),
                            o = s[u]
                        }
                        if (t.localClippingEnabled && i.clipShadows === !0 && 0 !== i.clippingPlanes.length) {
                            var p = o.uuid
                              , d = i.uuid
                              , f = S[p];
                            void 0 === f && (f = {},
                            S[p] = f);
                            var m = f[d];
                            void 0 === m && (m = o.clone(),
                            f[d] = m),
                            o = m
                        }
                        o.visible = i.visible,
                        o.wireframe = i.wireframe;
                        var g = i.side;
                        return N.renderSingleSided && g == wr && (g = xr),
                        N.renderReverseSided && (g === xr ? g = br : g === br && (g = xr)),
                        o.side = g,
                        o.clipShadows = i.clipShadows,
                        o.clippingPlanes = i.clippingPlanes,
                        o.wireframeLinewidth = i.wireframeLinewidth,
                        o.linewidth = i.linewidth,
                        n && void 0 !== o.uniforms.lightPos && o.uniforms.lightPos.value.copy(r),
                        o
                    }
                    function h(t, e, i) {
                        if (t.visible !== !1) {
                            var n = 0 !== (t.layers.mask & e.layers.mask);
                            if (n && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (t.frustumCulled === !1 || p.intersectsObject(t) === !0)) {
                                var r = t.material;
                                r.visible === !0 && (t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
                                y.push(t))
                            }
                            for (var a = t.children, o = 0, s = a.length; o < s; o++)
                                h(a[o], e, i)
                        }
                    }
                    var c = t.context
                      , u = t.state
                      , p = new ot
                      , d = new o
                      , f = i.shadows
                      , m = new n
                      , g = new n(a.maxTextureSize,a.maxTextureSize)
                      , v = new l
                      , _ = new l
                      , y = []
                      , x = 1
                      , b = 2
                      , w = (x | b) + 1
                      , M = new Array(w)
                      , T = new Array(w)
                      , S = {}
                      , E = [new l(1,0,0), new l(-1,0,0), new l(0,0,1), new l(0,0,-1), new l(0,1,0), new l(0,-1,0)]
                      , A = [new l(0,1,0), new l(0,1,0), new l(0,1,0), new l(0,1,0), new l(0,0,1), new l(0,0,-1)]
                      , P = [new q, new q, new q, new q, new q, new q]
                      , R = new et;
                    R.depthPacking = Eo,
                    R.clipping = !0;
                    for (var L = Il.distanceRGBA, C = e.UniformsUtils.clone(L.uniforms), O = 0; O !== w; ++O) {
                        var I = 0 !== (O & x)
                          , D = 0 !== (O & b)
                          , U = R.clone();
                        U.morphTargets = I,
                        U.skinning = D,
                        M[O] = U;
                        var F = new $({
                            defines: {
                                USE_SHADOWMAP: ""
                            },
                            uniforms: C,
                            vertexShader: L.vertexShader,
                            fragmentShader: L.fragmentShader,
                            morphTargets: I,
                            skinning: D,
                            clipping: !0
                        });
                        T[O] = F
                    }
                    var N = this;
                    this.enabled = !1,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this.type = _r,
                    this.renderReverseSided = !0,
                    this.renderSingleSided = !0,
                    this.render = function(e, i) {
                        if (N.enabled !== !1 && (N.autoUpdate !== !1 || N.needsUpdate !== !1) && 0 !== f.length) {
                            u.clearColor(1, 1, 1, 1),
                            u.disable(c.BLEND),
                            u.setDepthTest(!0),
                            u.setScissorTest(!1);
                            for (var n, a, o = 0, l = f.length; o < l; o++) {
                                var x = f[o]
                                  , b = x.shadow;
                                if (void 0 !== b) {
                                    var w = b.camera;
                                    if (m.copy(b.mapSize),
                                    m.min(g),
                                    x && x.isPointLight) {
                                        n = 6,
                                        a = !0;
                                        var M = m.x
                                          , T = m.y;
                                        P[0].set(2 * M, T, M, T),
                                        P[1].set(0, T, M, T),
                                        P[2].set(3 * M, T, M, T),
                                        P[3].set(M, T, M, T),
                                        P[4].set(3 * M, 0, M, T),
                                        P[5].set(M, 0, M, T),
                                        m.x *= 4,
                                        m.y *= 2
                                    } else
                                        n = 1,
                                        a = !1;
                                    if (null === b.map) {
                                        var S = {
                                            minFilter: Ma,
                                            magFilter: Ma,
                                            format: Ha
                                        };
                                        b.map = new Q(m.x,m.y,S),
                                        w.updateProjectionMatrix()
                                    }
                                    b && b.isSpotLightShadow && b.update(x);
                                    var R = b.map
                                      , L = b.matrix;
                                    _.setFromMatrixPosition(x.matrixWorld),
                                    w.position.copy(_),
                                    t.setRenderTarget(R),
                                    t.clear();
                                    for (var C = 0; C < n; C++) {
                                        if (a) {
                                            v.copy(w.position),
                                            v.add(E[C]),
                                            w.up.copy(A[C]),
                                            w.lookAt(v);
                                            var O = P[C];
                                            u.viewport(O)
                                        } else
                                            v.setFromMatrixPosition(x.target.matrixWorld),
                                            w.lookAt(v);
                                        w.updateMatrixWorld(),
                                        w.matrixWorldInverse.getInverse(w.matrixWorld),
                                        L.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                                        L.multiply(w.projectionMatrix),
                                        L.multiply(w.matrixWorldInverse),
                                        d.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse),
                                        p.setFromMatrix(d),
                                        y.length = 0,
                                        h(e, i, w);
                                        for (var I = 0, D = y.length; I < D; I++) {
                                            var U = y[I]
                                              , F = r.update(U)
                                              , z = U.material;
                                            if (z && z.isMultiMaterial)
                                                for (var B = F.groups, k = z.materials, G = 0, V = B.length; G < V; G++) {
                                                    var H = B[G]
                                                      , j = k[H.materialIndex];
                                                    if (j.visible === !0) {
                                                        var W = s(U, j, a, _);
                                                        t.renderBufferDirect(w, null, F, W, U, H)
                                                    }
                                                }
                                            else {
                                                var W = s(U, z, a, _);
                                                t.renderBufferDirect(w, null, F, W, U, null)
                                            }
                                        }
                                    }
                                } else
                                    console.warn("THREE.WebGLShadowMap:", x, "has no shadow.")
                            }
                            var X = t.getClearColor()
                              , Y = t.getClearAlpha();
                            t.setClearColor(X, Y),
                            N.needsUpdate = !1
                        }
                    }
                }
                function lt(t) {
                    for (var e = t.split("\n"), i = 0; i < e.length; i++)
                        e[i] = i + 1 + ": " + e[i];
                    return e.join("\n")
                }
                function ht(t, e, i) {
                    var n = t.createShader(e);
                    return t.shaderSource(n, i),
                    t.compileShader(n),
                    t.getShaderParameter(n, t.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."),
                    "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), lt(i)),
                    n
                }
                function ct() {
                    var t = {};
                    return {
                        get: function(e) {
                            var i = e.uuid
                              , n = t[i];
                            return void 0 === n && (n = {},
                            t[i] = n),
                            n
                        },
                        delete: function(e) {
                            delete t[e.uuid]
                        },
                        clear: function() {
                            t = {}
                        }
                    }
                }
                function ut(t) {
                    switch (t) {
                    case vo:
                        return ["Linear", "( value )"];
                    case _o:
                        return ["sRGB", "( value )"];
                    case xo:
                        return ["RGBE", "( value )"];
                    case wo:
                        return ["RGBM", "( value, 7.0 )"];
                    case Mo:
                        return ["RGBM", "( value, 16.0 )"];
                    case To:
                        return ["RGBD", "( value, 256.0 )"];
                    case yo:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                    }
                }
                function pt(t, e) {
                    var i = ut(e);
                    return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
                }
                function dt(t, e) {
                    var i = ut(e);
                    return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
                }
                function ft(t, e) {
                    var i;
                    switch (e) {
                    case la:
                        i = "Linear";
                        break;
                    case ha:
                        i = "Reinhard";
                        break;
                    case ca:
                        i = "Uncharted2";
                        break;
                    case ua:
                        i = "OptimizedCineon";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + e)
                    }
                    return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                }
                function mt(t, e, i) {
                    t = t || {};
                    var n = [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                    return n.filter(_t).join("\n")
                }
                function gt(t) {
                    var e = [];
                    for (var i in t) {
                        var n = t[i];
                        n !== !1 && e.push("#define " + i + " " + n)
                    }
                    return e.join("\n")
                }
                function vt(t, e, i) {
                    for (var n = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), a = 0; a < r; a++) {
                        var o = t.getActiveAttrib(e, a)
                          , s = o.name;
                        n[s] = t.getAttribLocation(e, s)
                    }
                    return n
                }
                function _t(t) {
                    return "" !== t
                }
                function yt(t, e) {
                    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                }
                function xt(t) {
                    function e(t, e) {
                        var i = Cl[e];
                        if (void 0 === i)
                            throw new Error("Can not resolve #include <" + e + ">");
                        return xt(i)
                    }
                    var i = /#include +<([\w\d.]+)>/g;
                    return t.replace(i, e)
                }
                function bt(t) {
                    function e(t, e, i, n) {
                        for (var r = "", a = parseInt(e); a < parseInt(i); a++)
                            r += n.replace(/\[ i \]/g, "[ " + a + " ]");
                        return r
                    }
                    var i = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                    return t.replace(i, e)
                }
                function wt(t, e, i, n) {
                    var r = t.context
                      , a = i.extensions
                      , o = i.defines
                      , s = i.__webglShader.vertexShader
                      , l = i.__webglShader.fragmentShader
                      , h = "SHADOWMAP_TYPE_BASIC";
                    n.shadowMapType === _r ? h = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === yr && (h = "SHADOWMAP_TYPE_PCF_SOFT");
                    var c = "ENVMAP_TYPE_CUBE"
                      , u = "ENVMAP_MODE_REFLECTION"
                      , p = "ENVMAP_BLENDING_MULTIPLY";
                    if (n.envMap) {
                        switch (i.envMap.mapping) {
                        case da:
                        case fa:
                            c = "ENVMAP_TYPE_CUBE";
                            break;
                        case _a:
                        case ya:
                            c = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case ma:
                        case ga:
                            c = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case va:
                            c = "ENVMAP_TYPE_SPHERE"
                        }
                        switch (i.envMap.mapping) {
                        case fa:
                        case ga:
                            u = "ENVMAP_MODE_REFRACTION"
                        }
                        switch (i.combine) {
                        case ra:
                            p = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case aa:
                            p = "ENVMAP_BLENDING_MIX";
                            break;
                        case oa:
                            p = "ENVMAP_BLENDING_ADD"
                        }
                    }
                    var d, f, m = t.gammaFactor > 0 ? t.gammaFactor : 1, g = mt(a, n, t.extensions), v = gt(o), _ = r.createProgram();
                    i.isRawShaderMaterial ? (d = [v, "\n"].filter(_t).join("\n"),
                    f = [g, v, "\n"].filter(_t).join("\n")) : (d = ["precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, v, n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + n.maxBones, n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(_t).join("\n"),
                    f = [g, "precision " + n.precision + " float;", "precision " + n.precision + " int;", "#define SHADER_NAME " + i.__webglShader.name, v, n.alphaTest ? "#define ALPHATEST " + n.alphaTest : "", "#define GAMMA_FACTOR " + m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.vertexColors ? "#define USE_COLOR" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + n.numClippingPlanes, n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", n.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", n.toneMapping !== sa ? "#define TONE_MAPPING" : "", n.toneMapping !== sa ? Cl.tonemapping_pars_fragment : "", n.toneMapping !== sa ? ft("toneMapping", n.toneMapping) : "", n.outputEncoding || n.mapEncoding || n.envMapEncoding || n.emissiveMapEncoding ? Cl.encodings_pars_fragment : "", n.mapEncoding ? pt("mapTexelToLinear", n.mapEncoding) : "", n.envMapEncoding ? pt("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMapEncoding ? pt("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.outputEncoding ? dt("linearToOutputTexel", n.outputEncoding) : "", n.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(_t).join("\n")),
                    s = xt(s, n),
                    s = yt(s, n),
                    l = xt(l, n),
                    l = yt(l, n),
                    i.isShaderMaterial || (s = bt(s),
                    l = bt(l));
                    var y = d + s
                      , x = f + l
                      , b = ht(r, r.VERTEX_SHADER, y)
                      , w = ht(r, r.FRAGMENT_SHADER, x);
                    r.attachShader(_, b),
                    r.attachShader(_, w),
                    void 0 !== i.index0AttributeName ? r.bindAttribLocation(_, 0, i.index0AttributeName) : n.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"),
                    r.linkProgram(_);
                    var M = r.getProgramInfoLog(_)
                      , T = r.getShaderInfoLog(b)
                      , S = r.getShaderInfoLog(w)
                      , E = !0
                      , A = !0;
                    r.getProgramParameter(_, r.LINK_STATUS) === !1 ? (E = !1,
                    console.error("THREE.WebGLProgram: shader error: ", r.getError(), "gl.VALIDATE_STATUS", r.getProgramParameter(_, r.VALIDATE_STATUS), "gl.getProgramInfoLog", M, T, S)) : "" !== M ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", M) : "" !== T && "" !== S || (A = !1),
                    A && (this.diagnostics = {
                        runnable: E,
                        material: i,
                        programLog: M,
                        vertexShader: {
                            log: T,
                            prefix: d
                        },
                        fragmentShader: {
                            log: S,
                            prefix: f
                        }
                    }),
                    r.deleteShader(b),
                    r.deleteShader(w);
                    var P;
                    this.getUniforms = function() {
                        return void 0 === P && (P = new X(r,_,t)),
                        P
                    }
                    ;
                    var R;
                    return this.getAttributes = function() {
                        return void 0 === R && (R = vt(r, _)),
                        R
                    }
                    ,
                    this.destroy = function() {
                        r.deleteProgram(_),
                        this.program = void 0
                    }
                    ,
                    Object.defineProperties(this, {
                        uniforms: {
                            get: function() {
                                return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                                this.getUniforms()
                            }
                        },
                        attributes: {
                            get: function() {
                                return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                                this.getAttributes()
                            }
                        }
                    }),
                    this.id = Dl++,
                    this.code = e,
                    this.usedTimes = 1,
                    this.program = _,
                    this.vertexShader = b,
                    this.fragmentShader = w,
                    this
                }
                function Mt(t, e) {
                    function i(t) {
                        if (e.floatVertexTextures && t && t.skeleton && t.skeleton.useVertexTexture)
                            return 1024;
                        var i = e.maxVertexUniforms
                          , n = Math.floor((i - 20) / 4)
                          , r = n;
                        return void 0 !== t && t && t.isSkinnedMesh && (r = Math.min(t.skeleton.bones.length, r),
                        r < t.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + r + " (try OpenGL instead of ANGLE)")),
                        r
                    }
                    function n(t, e) {
                        var i;
                        return t ? t && t.isTexture ? i = t.encoding : t && t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
                        i = t.texture.encoding) : i = vo,
                        i === vo && e && (i = yo),
                        i
                    }
                    var r = []
                      , a = {
                        MeshDepthMaterial: "depth",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points"
                    }
                      , o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"];
                    this.getParameters = function(r, o, s, l, h) {
                        var c = a[r.type]
                          , u = i(h)
                          , p = t.getPrecision();
                        null !== r.precision && (p = e.getMaxPrecision(r.precision),
                        p !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", p, "instead."));
                        var d = t.getCurrentRenderTarget()
                          , f = {
                            shaderID: c,
                            precision: p,
                            supportsVertexTextures: e.vertexTextures,
                            outputEncoding: n(d ? d.texture : null, t.gammaOutput),
                            map: !!r.map,
                            mapEncoding: n(r.map, t.gammaInput),
                            envMap: !!r.envMap,
                            envMapMode: r.envMap && r.envMap.mapping,
                            envMapEncoding: n(r.envMap, t.gammaInput),
                            envMapCubeUV: !!r.envMap && (r.envMap.mapping === _a || r.envMap.mapping === ya),
                            lightMap: !!r.lightMap,
                            aoMap: !!r.aoMap,
                            emissiveMap: !!r.emissiveMap,
                            emissiveMapEncoding: n(r.emissiveMap, t.gammaInput),
                            bumpMap: !!r.bumpMap,
                            normalMap: !!r.normalMap,
                            displacementMap: !!r.displacementMap,
                            roughnessMap: !!r.roughnessMap,
                            metalnessMap: !!r.metalnessMap,
                            specularMap: !!r.specularMap,
                            alphaMap: !!r.alphaMap,
                            combine: r.combine,
                            vertexColors: r.vertexColors,
                            fog: !!s,
                            useFog: r.fog,
                            fogExp: s && s.isFogExp2,
                            flatShading: r.shading === Mr,
                            sizeAttenuation: r.sizeAttenuation,
                            logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                            skinning: r.skinning,
                            maxBones: u,
                            useVertexTexture: e.floatVertexTextures && h && h.skeleton && h.skeleton.useVertexTexture,
                            morphTargets: r.morphTargets,
                            morphNormals: r.morphNormals,
                            maxMorphTargets: t.maxMorphTargets,
                            maxMorphNormals: t.maxMorphNormals,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numHemiLights: o.hemi.length,
                            numClippingPlanes: l,
                            shadowMapEnabled: t.shadowMap.enabled && h.receiveShadow && o.shadows.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: t.toneMapping,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: r.premultipliedAlpha,
                            alphaTest: r.alphaTest,
                            doubleSided: r.side === wr,
                            flipSided: r.side === br,
                            depthPacking: void 0 !== r.depthPacking && r.depthPacking
                        };
                        return f
                    }
                    ,
                    this.getProgramCode = function(t, e) {
                        var i = [];
                        if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader),
                        i.push(t.vertexShader)),
                        void 0 !== t.defines)
                            for (var n in t.defines)
                                i.push(n),
                                i.push(t.defines[n]);
                        for (var r = 0; r < o.length; r++)
                            i.push(e[o[r]]);
                        return i.join()
                    }
                    ,
                    this.acquireProgram = function(e, i, n) {
                        for (var a, o = 0, s = r.length; o < s; o++) {
                            var l = r[o];
                            if (l.code === n) {
                                a = l,
                                ++a.usedTimes;
                                break
                            }
                        }
                        return void 0 === a && (a = new wt(t,n,e,i),
                        r.push(a)),
                        a
                    }
                    ,
                    this.releaseProgram = function(t) {
                        if (0 === --t.usedTimes) {
                            var e = r.indexOf(t);
                            r[e] = r[r.length - 1],
                            r.pop(),
                            t.destroy()
                        }
                    }
                    ,
                    this.programs = r
                }
                function Tt(t, i, n) {
                    if (Array.isArray(t))
                        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.uuid = e.Math.generateUUID(),
                    this.array = t,
                    this.itemSize = i,
                    this.normalized = n === !0,
                    this.dynamic = !1,
                    this.updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.version = 0
                }
                function St(t, e) {
                    return new Tt(new Int8Array(t),e)
                }
                function Et(t, e) {
                    return new Tt(new Uint8Array(t),e)
                }
                function At(t, e) {
                    return new Tt(new Uint8ClampedArray(t),e)
                }
                function Pt(t, e) {
                    return new Tt(new Int16Array(t),e)
                }
                function Rt(t, e) {
                    return new Tt(new Uint16Array(t),e)
                }
                function Lt(t, e) {
                    return new Tt(new Int32Array(t),e)
                }
                function Ct(t, e) {
                    return new Tt(new Uint32Array(t),e)
                }
                function Ot(t, e) {
                    return new Tt(new Float32Array(t),e)
                }
                function It(t, e) {
                    return new Tt(new Float64Array(t),e)
                }
                function Dt(t, e) {
                    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
                    new Tt(t,e).setDynamic(!0)
                }
                function Ut(t, e, i, n, r, a) {
                    this.a = t,
                    this.b = e,
                    this.c = i,
                    this.normal = n && n.isVector3 ? n : new l,
                    this.vertexNormals = Array.isArray(n) ? n : [],
                    this.color = r && r.isColor ? r : new tt,
                    this.vertexColors = Array.isArray(r) ? r : [],
                    this.materialIndex = void 0 !== a ? a : 0
                }
                function Ft(t, e, i, n) {
                    this._x = t || 0,
                    this._y = e || 0,
                    this._z = i || 0,
                    this._order = n || Ft.DefaultOrder
                }
                function Nt() {
                    this.mask = 1
                }
                function zt() {
                    function t() {
                        a.setFromEuler(r, !1)
                    }
                    function i() {
                        r.setFromQuaternion(a, void 0, !1)
                    }
                    Object.defineProperty(this, "id", {
                        value: Bt()
                    }),
                    this.uuid = e.Math.generateUUID(),
                    this.name = "",
                    this.type = "Object3D",
                    this.parent = null,
                    this.children = [],
                    this.up = zt.DefaultUp.clone();
                    var n = new l
                      , r = new Ft
                      , a = new s
                      , h = new l(1,1,1);
                    r.onChange(t),
                    a.onChange(i),
                    Object.defineProperties(this, {
                        position: {
                            enumerable: !0,
                            value: n
                        },
                        rotation: {
                            enumerable: !0,
                            value: r
                        },
                        quaternion: {
                            enumerable: !0,
                            value: a
                        },
                        scale: {
                            enumerable: !0,
                            value: h
                        },
                        modelViewMatrix: {
                            value: new o
                        },
                        normalMatrix: {
                            value: new rt
                        }
                    }),
                    this.matrix = new o,
                    this.matrixWorld = new o,
                    this.matrixAutoUpdate = zt.DefaultMatrixAutoUpdate,
                    this.matrixWorldNeedsUpdate = !1,
                    this.layers = new Nt,
                    this.visible = !0,
                    this.castShadow = !1,
                    this.receiveShadow = !1,
                    this.frustumCulled = !0,
                    this.renderOrder = 0,
                    this.userData = {}
                }
                function Bt() {
                    return Ul++
                }
                function kt() {
                    Object.defineProperty(this, "id", {
                        value: Gt()
                    }),
                    this.uuid = e.Math.generateUUID(),
                    this.name = "",
                    this.type = "Geometry",
                    this.vertices = [],
                    this.colors = [],
                    this.faces = [],
                    this.faceVertexUvs = [[]],
                    this.morphTargets = [],
                    this.morphNormals = [],
                    this.skinWeights = [],
                    this.skinIndices = [],
                    this.lineDistances = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.elementsNeedUpdate = !1,
                    this.verticesNeedUpdate = !1,
                    this.uvsNeedUpdate = !1,
                    this.normalsNeedUpdate = !1,
                    this.colorsNeedUpdate = !1,
                    this.lineDistancesNeedUpdate = !1,
                    this.groupsNeedUpdate = !1
                }
                function Gt() {
                    return Fl++
                }
                function Vt() {
                    Object.defineProperty(this, "id", {
                        value: Gt()
                    }),
                    this.uuid = e.Math.generateUUID(),
                    this.name = "",
                    this.type = "DirectGeometry",
                    this.indices = [],
                    this.vertices = [],
                    this.normals = [],
                    this.colors = [],
                    this.uvs = [],
                    this.uvs2 = [],
                    this.groups = [],
                    this.morphTargets = {},
                    this.skinWeights = [],
                    this.skinIndices = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.verticesNeedUpdate = !1,
                    this.normalsNeedUpdate = !1,
                    this.colorsNeedUpdate = !1,
                    this.uvsNeedUpdate = !1,
                    this.groupsNeedUpdate = !1
                }
                function Ht() {
                    Object.defineProperty(this, "id", {
                        value: Gt()
                    }),
                    this.uuid = e.Math.generateUUID(),
                    this.name = "",
                    this.type = "BufferGeometry",
                    this.index = null,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }
                }
                function jt(t, e, i) {
                    function n(t) {
                        var r = t.target
                          , s = l[r.id];
                        null !== s.index && a(s.index),
                        o(s.attributes),
                        r.removeEventListener("dispose", n),
                        delete l[r.id];
                        var h = e.get(r);
                        h.wireframe && a(h.wireframe),
                        e.delete(r);
                        var c = e.get(s);
                        c.wireframe && a(c.wireframe),
                        e.delete(s),
                        i.memory.geometries--
                    }
                    function r(t) {
                        return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
                    }
                    function a(e) {
                        var i = r(e);
                        void 0 !== i && (t.deleteBuffer(i),
                        s(e))
                    }
                    function o(t) {
                        for (var e in t)
                            a(t[e])
                    }
                    function s(t) {
                        t.isInterleavedBufferAttribute ? e.delete(t.data) : e.delete(t)
                    }
                    var l = {};
                    return {
                        get: function(t) {
                            var e = t.geometry;
                            if (void 0 !== l[e.id])
                                return l[e.id];
                            e.addEventListener("dispose", n);
                            var r;
                            return e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Ht).setFromObject(t)),
                            r = e._bufferGeometry),
                            l[e.id] = r,
                            i.memory.geometries++,
                            r
                        }
                    }
                }
                function Wt(t, e, i) {
                    function n(e) {
                        var i = c.get(e);
                        e.geometry.isGeometry && i.updateFromObject(e);
                        var n = i.index
                          , a = i.attributes;
                        null !== n && r(n, t.ELEMENT_ARRAY_BUFFER);
                        for (var o in a)
                            r(a[o], t.ARRAY_BUFFER);
                        var s = i.morphAttributes;
                        for (var o in s)
                            for (var l = s[o], h = 0, u = l.length; h < u; h++)
                                r(l[h], t.ARRAY_BUFFER);
                        return i
                    }
                    function r(t, i) {
                        var n = t.isInterleavedBufferAttribute ? t.data : t
                          , r = e.get(n);
                        void 0 === r.__webglBuffer ? a(r, n, i) : r.version !== n.version && o(r, n, i)
                    }
                    function a(e, i, n) {
                        e.__webglBuffer = t.createBuffer(),
                        t.bindBuffer(n, e.__webglBuffer);
                        var r = i.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW;
                        t.bufferData(n, i.array, r),
                        e.version = i.version
                    }
                    function o(e, i, n) {
                        t.bindBuffer(n, e.__webglBuffer),
                        i.dynamic === !1 || i.updateRange.count === -1 ? t.bufferSubData(n, 0, i.array) : 0 === i.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, i.updateRange.offset * i.array.BYTES_PER_ELEMENT, i.array.subarray(i.updateRange.offset, i.updateRange.offset + i.updateRange.count)),
                        i.updateRange.count = 0),
                        e.version = i.version
                    }
                    function s(t) {
                        return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
                    }
                    function l(i) {
                        var n = e.get(i);
                        if (void 0 !== n.wireframe)
                            return n.wireframe;
                        var a = []
                          , o = i.index
                          , s = i.attributes
                          , l = s.position;
                        if (null !== o)
                            for (var c = {}, u = o.array, p = 0, d = u.length; p < d; p += 3) {
                                var f = u[p + 0]
                                  , m = u[p + 1]
                                  , g = u[p + 2];
                                h(c, f, m) && a.push(f, m),
                                h(c, m, g) && a.push(m, g),
                                h(c, g, f) && a.push(g, f)
                            }
                        else
                            for (var u = s.position.array, p = 0, d = u.length / 3 - 1; p < d; p += 3) {
                                var f = p + 0
                                  , m = p + 1
                                  , g = p + 2;
                                a.push(f, m, m, g, g, f)
                            }
                        var v = l.count > 65535 ? Uint32Array : Uint16Array
                          , _ = new Tt(new v(a),1);
                        return r(_, t.ELEMENT_ARRAY_BUFFER),
                        n.wireframe = _,
                        _
                    }
                    function h(t, e, i) {
                        if (e > i) {
                            var n = e;
                            e = i,
                            i = n
                        }
                        var r = t[e];
                        return void 0 === r ? (t[e] = [i],
                        !0) : r.indexOf(i) === -1 && (r.push(i),
                        !0)
                    }
                    var c = new jt(t,e,i);
                    return {
                        getAttributeBuffer: s,
                        getWireframeAttribute: l,
                        update: n
                    }
                }
                function Xt() {
                    var t = {};
                    return {
                        get: function(e) {
                            if (void 0 !== t[e.id])
                                return t[e.id];
                            var i;
                            switch (e.type) {
                            case "DirectionalLight":
                                i = {
                                    direction: new l,
                                    color: new tt,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "SpotLight":
                                i = {
                                    position: new l,
                                    direction: new l,
                                    color: new tt,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "PointLight":
                                i = {
                                    position: new l,
                                    color: new tt,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "HemisphereLight":
                                i = {
                                    direction: new l,
                                    skyColor: new tt,
                                    groundColor: new tt
                                }
                            }
                            return t[e.id] = i,
                            i
                        }
                    }
                }
                function Yt(t, e, i) {
                    function n() {
                        if (void 0 !== a)
                            return a;
                        var i = e.get("EXT_texture_filter_anisotropic");
                        return a = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    }
                    function r(e) {
                        if ("highp" === e) {
                            if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
                                return "highp";
                            e = "mediump"
                        }
                        return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                    }
                    var a, o = void 0 !== i.precision ? i.precision : "highp", s = r(o);
                    s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."),
                    o = s);
                    var l = i.logarithmicDepthBuffer === !0 && !!e.get("EXT_frag_depth")
                      , h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
                      , c = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                      , u = t.getParameter(t.MAX_TEXTURE_SIZE)
                      , p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE)
                      , d = t.getParameter(t.MAX_VERTEX_ATTRIBS)
                      , f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS)
                      , m = t.getParameter(t.MAX_VARYING_VECTORS)
                      , g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS)
                      , v = c > 0
                      , _ = !!e.get("OES_texture_float")
                      , y = v && _;
                    return {
                        getMaxAnisotropy: n,
                        getMaxPrecision: r,
                        precision: o,
                        logarithmicDepthBuffer: l,
                        maxTextures: h,
                        maxVertexTextures: c,
                        maxTextureSize: u,
                        maxCubemapSize: p,
                        maxAttributes: d,
                        maxVertexUniforms: f,
                        maxVaryings: m,
                        maxFragmentUniforms: g,
                        vertexTextures: v,
                        floatFragmentTextures: _,
                        floatVertexTextures: y
                    }
                }
                function qt(t) {
                    var e = {};
                    return {
                        get: function(i) {
                            if (void 0 !== e[i])
                                return e[i];
                            var n;
                            switch (i) {
                            case "WEBGL_depth_texture":
                                n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            case "WEBGL_compressed_texture_etc1":
                                n = t.getExtension("WEBGL_compressed_texture_etc1");
                                break;
                            default:
                                n = t.getExtension(i)
                            }
                            return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."),
                            e[i] = n,
                            n
                        }
                    }
                }
                function Zt(t, e, i) {
                    function n(t) {
                        s = t
                    }
                    function r(i) {
                        i.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (l = t.UNSIGNED_INT,
                        h = 4) : (l = t.UNSIGNED_SHORT,
                        h = 2)
                    }
                    function a(e, n) {
                        t.drawElements(s, n, l, e * h),
                        i.calls++,
                        i.vertices += n,
                        s === t.TRIANGLES && (i.faces += n / 3)
                    }
                    function o(n, r, a) {
                        var o = e.get("ANGLE_instanced_arrays");
                        return null === o ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (o.drawElementsInstancedANGLE(s, a, l, r * h, n.maxInstancedCount),
                        i.calls++,
                        i.vertices += a * n.maxInstancedCount,
                        void (s === t.TRIANGLES && (i.faces += n.maxInstancedCount * a / 3)))
                    }
                    var s, l, h;
                    return {
                        setMode: n,
                        setIndex: r,
                        render: a,
                        renderInstances: o
                    }
                }
                function Qt() {
                    function t() {
                        h.value !== n && (h.value = n,
                        h.needsUpdate = r > 0),
                        i.numPlanes = r
                    }
                    function e(t, e, n, r) {
                        var a = null !== t ? t.length : 0
                          , o = null;
                        if (0 !== a) {
                            if (o = h.value,
                            r !== !0 || null === o) {
                                var c = n + 4 * a
                                  , u = e.matrixWorldInverse;
                                l.getNormalMatrix(u),
                                (null === o || o.length < c) && (o = new Float32Array(c));
                                for (var p = 0, d = n; p !== a; ++p,
                                d += 4)
                                    s.copy(t[p]).applyMatrix4(u, l),
                                    s.normal.toArray(o, d),
                                    o[d + 3] = s.constant
                            }
                            h.value = o,
                            h.needsUpdate = !0
                        }
                        return i.numPlanes = a,
                        o
                    }
                    var i = this
                      , n = null
                      , r = 0
                      , a = !1
                      , o = !1
                      , s = new at
                      , l = new rt
                      , h = {
                        value: null,
                        needsUpdate: !1
                    };
                    this.uniform = h,
                    this.numPlanes = 0,
                    this.init = function(t, i, o) {
                        var s = 0 !== t.length || i || 0 !== r || a;
                        return a = i,
                        n = e(t, o, 0),
                        r = t.length,
                        s
                    }
                    ,
                    this.beginShadows = function() {
                        o = !0,
                        e(null)
                    }
                    ,
                    this.endShadows = function() {
                        o = !1,
                        t()
                    }
                    ,
                    this.setState = function(i, s, l, c, u) {
                        if (!a || null === i || 0 === i.length || o && !s)
                            o ? e(null) : t();
                        else {
                            var p = o ? 0 : r
                              , d = 4 * p
                              , f = c.clippingState || null;
                            h.value = f,
                            f = e(i, l, d, u);
                            for (var m = 0; m !== d; ++m)
                                f[m] = n[m];
                            c.clippingState = f,
                            this.numPlanes += p
                        }
                    }
                }
                function Jt(t, e, i) {
                    function n(t) {
                        o = t
                    }
                    function r(e, n) {
                        t.drawArrays(o, e, n),
                        i.calls++,
                        i.vertices += n,
                        o === t.TRIANGLES && (i.faces += n / 3)
                    }
                    function a(n) {
                        var r = e.get("ANGLE_instanced_arrays");
                        if (null === r)
                            return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        var a = n.attributes.position
                          , s = 0;
                        a && a.isInterleavedBufferAttribute ? (s = a.data.count,
                        r.drawArraysInstancedANGLE(o, 0, s, n.maxInstancedCount)) : (s = a.count,
                        r.drawArraysInstancedANGLE(o, 0, s, n.maxInstancedCount)),
                        i.calls++,
                        i.vertices += s * n.maxInstancedCount,
                        o === t.TRIANGLES && (i.faces += n.maxInstancedCount * s / 3)
                    }
                    var o;
                    return {
                        setMode: n,
                        render: r,
                        renderInstances: a
                    }
                }
                function Kt(t, e, i) {
                    Q.call(this, t, e, i),
                    this.activeCubeFace = 0,
                    this.activeMipMapLevel = 0
                }
                function $t(t, e, i, n, r, a) {
                    function o(t, e, i) {
                        var n = 0;
                        return n += (t + 1) * (e + 1) * 2,
                        n += (t + 1) * (i + 1) * 2,
                        n += (i + 1) * (e + 1) * 2
                    }
                    function s(t, e, i) {
                        var n = 0;
                        return n += t * e * 2,
                        n += t * i * 2,
                        n += i * e * 2,
                        6 * n
                    }
                    function h(t, e, i, n, r, a, o, s, h, u, p) {
                        for (var w = a / h, M = o / u, T = a / 2, S = o / 2, E = s / 2, A = h + 1, P = u + 1, R = 0, L = 0, C = new l, O = 0; O < P; O++)
                            for (var I = O * M - S, D = 0; D < A; D++) {
                                var U = D * w - T;
                                C[t] = U * n,
                                C[e] = I * r,
                                C[i] = E,
                                f[v] = C.x,
                                f[v + 1] = C.y,
                                f[v + 2] = C.z,
                                C[t] = 0,
                                C[e] = 0,
                                C[i] = s > 0 ? 1 : -1,
                                m[v] = C.x,
                                m[v + 1] = C.y,
                                m[v + 2] = C.z,
                                g[_] = D / h,
                                g[_ + 1] = 1 - O / u,
                                v += 3,
                                _ += 2,
                                R += 1
                            }
                        for (O = 0; O < u; O++)
                            for (D = 0; D < h; D++) {
                                var F = x + D + A * O
                                  , N = x + D + A * (O + 1)
                                  , z = x + (D + 1) + A * (O + 1)
                                  , B = x + (D + 1) + A * O;
                                d[y] = F,
                                d[y + 1] = N,
                                d[y + 2] = B,
                                d[y + 3] = N,
                                d[y + 4] = z,
                                d[y + 5] = B,
                                y += 6,
                                L += 6
                            }
                        c.addGroup(b, L, p),
                        b += L,
                        x += R
                    }
                    Ht.call(this),
                    this.type = "BoxBufferGeometry",
                    this.parameters = {
                        width: t,
                        height: e,
                        depth: i,
                        widthSegments: n,
                        heightSegments: r,
                        depthSegments: a
                    };
                    var c = this;
                    n = Math.floor(n) || 1,
                    r = Math.floor(r) || 1,
                    a = Math.floor(a) || 1;
                    var u = o(n, r, a)
                      , p = s(n, r, a)
                      , d = new (p > 65535 ? Uint32Array : Uint16Array)(p)
                      , f = new Float32Array(3 * u)
                      , m = new Float32Array(3 * u)
                      , g = new Float32Array(2 * u)
                      , v = 0
                      , _ = 0
                      , y = 0
                      , x = 0
                      , b = 0;
                    h("z", "y", "x", -1, -1, i, e, t, a, r, 0),
                    h("z", "y", "x", 1, -1, i, e, -t, a, r, 1),
                    h("x", "z", "y", 1, 1, t, i, e, n, a, 2),
                    h("x", "z", "y", 1, -1, t, i, -e, n, a, 3),
                    h("x", "y", "z", 1, -1, t, e, i, n, r, 4),
                    h("x", "y", "z", -1, -1, t, e, -i, n, r, 5),
                    this.setIndex(new Tt(d,1)),
                    this.addAttribute("position", new Tt(f,3)),
                    this.addAttribute("normal", new Tt(m,3)),
                    this.addAttribute("uv", new Tt(g,2))
                }
                function te(t, e) {
                    this.origin = void 0 !== t ? t : new l,
                    this.direction = void 0 !== e ? e : new l
                }
                function ee(t, e) {
                    this.start = void 0 !== t ? t : new l,
                    this.end = void 0 !== e ? e : new l
                }
                function ie(t, e, i) {
                    this.a = void 0 !== t ? t : new l,
                    this.b = void 0 !== e ? e : new l,
                    this.c = void 0 !== i ? i : new l
                }
                function ne(t) {
                    J.call(this),
                    this.type = "MeshBasicMaterial",
                    this.color = new tt(16777215),
                    this.map = null,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = ra,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.lights = !1,
                    this.setValues(t)
                }
                function re(t, e) {
                    zt.call(this),
                    this.type = "Mesh",
                    this.geometry = void 0 !== t ? t : new Ht,
                    this.material = void 0 !== e ? e : new ne({
                        color: 16777215 * Math.random()
                    }),
                    this.drawMode = fo,
                    this.updateMorphTargets()
                }
                function ae(t, e, i, n) {
                    Ht.call(this),
                    this.type = "PlaneBufferGeometry",
                    this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: i,
                        heightSegments: n
                    };
                    for (var r = t / 2, a = e / 2, o = Math.floor(i) || 1, s = Math.floor(n) || 1, l = o + 1, h = s + 1, c = t / o, u = e / s, p = new Float32Array(l * h * 3), d = new Float32Array(l * h * 3), f = new Float32Array(l * h * 2), m = 0, g = 0, v = 0; v < h; v++)
                        for (var _ = v * u - a, y = 0; y < l; y++) {
                            var x = y * c - r;
                            p[m] = x,
                            p[m + 1] = -_,
                            d[m + 2] = 1,
                            f[g] = y / o,
                            f[g + 1] = 1 - v / s,
                            m += 3,
                            g += 2
                        }
                    m = 0;
                    for (var b = new (p.length / 3 > 65535 ? Uint32Array : Uint16Array)(o * s * 6), v = 0; v < s; v++)
                        for (var y = 0; y < o; y++) {
                            var w = y + l * v
                              , M = y + l * (v + 1)
                              , T = y + 1 + l * (v + 1)
                              , S = y + 1 + l * v;
                            b[m] = w,
                            b[m + 1] = M,
                            b[m + 2] = S,
                            b[m + 3] = M,
                            b[m + 4] = T,
                            b[m + 5] = S,
                            m += 6
                        }
                    this.setIndex(new Tt(b,1)),
                    this.addAttribute("position", new Tt(p,3)),
                    this.addAttribute("normal", new Tt(d,3)),
                    this.addAttribute("uv", new Tt(f,2))
                }
                function oe() {
                    zt.call(this),
                    this.type = "Camera",
                    this.matrixWorldInverse = new o,
                    this.projectionMatrix = new o
                }
                function se(t, e, i, n) {
                    oe.call(this),
                    this.type = "PerspectiveCamera",
                    this.fov = void 0 !== t ? t : 50,
                    this.zoom = 1,
                    this.near = void 0 !== i ? i : .1,
                    this.far = void 0 !== n ? n : 2e3,
                    this.focus = 10,
                    this.aspect = void 0 !== e ? e : 1,
                    this.view = null,
                    this.filmGauge = 35,
                    this.filmOffset = 0,
                    this.updateProjectionMatrix()
                }
                function le(t, e, i, n, r, a) {
                    oe.call(this),
                    this.type = "OrthographicCamera",
                    this.zoom = 1,
                    this.view = null,
                    this.left = t,
                    this.right = e,
                    this.top = i,
                    this.bottom = n,
                    this.near = void 0 !== r ? r : .1,
                    this.far = void 0 !== a ? a : 2e3,
                    this.updateProjectionMatrix()
                }
                function he(t) {
                    function i() {
                        return null === mt ? Rt : 1
                    }
                    function n(t, e, i, n) {
                        J === !0 && (t *= n,
                        e *= n,
                        i *= n),
                        ee.clearColor(t, e, i, n)
                    }
                    function r() {
                        ee.init(),
                        ee.scissor(xt.copy(Lt).multiplyScalar(Rt)),
                        ee.viewport(wt.copy(Ot).multiplyScalar(Rt)),
                        n(St.r, St.g, St.b, Et)
                    }
                    function a() {
                        ft = null,
                        yt = null,
                        _t = "",
                        vt = -1,
                        ee.reset()
                    }
                    function s(t) {
                        t.preventDefault(),
                        a(),
                        r(),
                        ie.clear()
                    }
                    function c(t) {
                        var e = t.target;
                        e.removeEventListener("dispose", c),
                        p(e)
                    }
                    function p(t) {
                        d(t),
                        ie.delete(t)
                    }
                    function d(t) {
                        var e = ie.get(t).program;
                        t.program = void 0,
                        void 0 !== e && ce.releaseProgram(e)
                    }
                    function f(t, e, i, n) {
                        var r;
                        if (i && i.isInstancedBufferGeometry && (r = Kt.get("ANGLE_instanced_arrays"),
                        null === r))
                            return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        void 0 === n && (n = 0),
                        ee.initAttributes();
                        var a = i.attributes
                          , o = e.getAttributes()
                          , s = t.defaultAttributeValues;
                        for (var l in o) {
                            var h = o[l];
                            if (h >= 0) {
                                var c = a[l];
                                if (void 0 !== c) {
                                    var u = Vt.FLOAT
                                      , p = c.array
                                      , d = c.normalized;
                                    p instanceof Float32Array ? u = Vt.FLOAT : p instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : p instanceof Uint16Array ? u = Vt.UNSIGNED_SHORT : p instanceof Int16Array ? u = Vt.SHORT : p instanceof Uint32Array ? u = Vt.UNSIGNED_INT : p instanceof Int32Array ? u = Vt.INT : p instanceof Int8Array ? u = Vt.BYTE : p instanceof Uint8Array && (u = Vt.UNSIGNED_BYTE);
                                    var f = c.itemSize
                                      , m = he.getAttributeBuffer(c);
                                    if (c && c.isInterleavedBufferAttribute) {
                                        var g = c.data
                                          , v = g.stride
                                          , _ = c.offset;
                                        g && g.isInstancedInterleavedBuffer ? (ee.enableAttributeAndDivisor(h, g.meshPerAttribute, r),
                                        void 0 === i.maxInstancedCount && (i.maxInstancedCount = g.meshPerAttribute * g.count)) : ee.enableAttribute(h),
                                        Vt.bindBuffer(Vt.ARRAY_BUFFER, m),
                                        Vt.vertexAttribPointer(h, f, u, d, v * g.array.BYTES_PER_ELEMENT, (n * v + _) * g.array.BYTES_PER_ELEMENT)
                                    } else
                                        c && c.isInstancedBufferAttribute ? (ee.enableAttributeAndDivisor(h, c.meshPerAttribute, r),
                                        void 0 === i.maxInstancedCount && (i.maxInstancedCount = c.meshPerAttribute * c.count)) : ee.enableAttribute(h),
                                        Vt.bindBuffer(Vt.ARRAY_BUFFER, m),
                                        Vt.vertexAttribPointer(h, f, u, d, 0, n * f * c.array.BYTES_PER_ELEMENT)
                                } else if (void 0 !== s) {
                                    var y = s[l];
                                    if (void 0 !== y)
                                        switch (y.length) {
                                        case 2:
                                            Vt.vertexAttrib2fv(h, y);
                                            break;
                                        case 3:
                                            Vt.vertexAttrib3fv(h, y);
                                            break;
                                        case 4:
                                            Vt.vertexAttrib4fv(h, y);
                                            break;
                                        default:
                                            Vt.vertexAttrib1fv(h, y)
                                        }
                                }
                            }
                        }
                        ee.disableUnusedAttributes()
                    }
                    function m(t, e) {
                        return Math.abs(e[0]) - Math.abs(t[0])
                    }
                    function g(t, e) {
                        return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.program && e.material.program && t.material.program !== e.material.program ? t.material.program.id - e.material.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
                    }
                    function v(t, e) {
                        return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
                    }
                    function _(t, e, i, n, r) {
                        var a, o;
                        i.transparent ? (a = at,
                        o = ++lt) : (a = it,
                        o = ++rt);
                        var s = a[o];
                        void 0 !== s ? (s.id = t.id,
                        s.object = t,
                        s.geometry = e,
                        s.material = i,
                        s.z = Bt.z,
                        s.group = r) : (s = {
                            id: t.id,
                            object: t,
                            geometry: e,
                            material: i,
                            z: Bt.z,
                            group: r
                        },
                        a.push(s))
                    }
                    function y(t) {
                        var e = t.geometry;
                        return null === e.boundingSphere && e.computeBoundingSphere(),
                        Nt.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                        b(Nt)
                    }
                    function x(t) {
                        return Nt.center.set(0, 0, 0),
                        Nt.radius = .7071067811865476,
                        Nt.applyMatrix4(t.matrixWorld),
                        b(Nt)
                    }
                    function b(t) {
                        if (!It.intersectsSphere(t))
                            return !1;
                        var e = Dt.numPlanes;
                        if (0 === e)
                            return !0;
                        var i = dt.clippingPlanes
                          , n = t.center
                          , r = -t.radius
                          , a = 0;
                        do
                            if (i[a].distanceToPoint(n) < r)
                                return !1;
                        while (++a !== e);return !0
                    }
                    function w(t, e) {
                        if (t.visible !== !1) {
                            var i = 0 !== (t.layers.mask & e.layers.mask);
                            if (i)
                                if (t.isLight)
                                    et.push(t);
                                else if (t.isSprite)
                                    t.frustumCulled !== !1 && x(t) !== !0 || ut.push(t);
                                else if (t.isLensFlare)
                                    pt.push(t);
                                else if (t.isImmediateRenderObject)
                                    dt.sortObjects === !0 && (Bt.setFromMatrixPosition(t.matrixWorld),
                                    Bt.applyProjection(zt)),
                                    _(t, null, t.material, Bt.z, null);
                                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(),
                                t.frustumCulled === !1 || y(t) === !0)) {
                                    var n = t.material;
                                    if (n.visible === !0) {
                                        dt.sortObjects === !0 && (Bt.setFromMatrixPosition(t.matrixWorld),
                                        Bt.applyProjection(zt));
                                        var r = he.update(t);
                                        if (n.isMultiMaterial)
                                            for (var a = r.groups, o = n.materials, s = 0, l = a.length; s < l; s++) {
                                                var h = a[s]
                                                  , c = o[h.materialIndex];
                                                c.visible === !0 && _(t, r, c, Bt.z, h)
                                            }
                                        else
                                            _(t, r, n, Bt.z, null)
                                    }
                                }
                            for (var u = t.children, s = 0, l = u.length; s < l; s++)
                                w(u[s], e)
                        }
                    }
                    function M(t, e, i, n) {
                        for (var r = 0, a = t.length; r < a; r++) {
                            var o = t[r]
                              , s = o.object
                              , l = o.geometry
                              , h = void 0 === n ? o.material : n
                              , c = o.group;
                            if (s.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, s.matrixWorld),
                            s.normalMatrix.getNormalMatrix(s.modelViewMatrix),
                            s.isImmediateRenderObject) {
                                S(h);
                                var u = E(e, i, h, s);
                                _t = "",
                                s.render(function(t) {
                                    dt.renderBufferImmediate(t, u, h)
                                })
                            } else
                                dt.renderBufferDirect(e, i, l, h, s, c)
                        }
                    }
                    function T(t, i, n) {
                        var r = ie.get(t)
                          , a = ce.getParameters(t, kt, i, Dt.numPlanes, n)
                          , o = ce.getProgramCode(t, a)
                          , s = r.program
                          , l = !0;
                        if (void 0 === s)
                            t.addEventListener("dispose", c);
                        else if (s.code !== o)
                            d(t);
                        else {
                            if (void 0 !== a.shaderID)
                                return;
                            l = !1
                        }
                        if (l) {
                            if (a.shaderID) {
                                var h = Il[a.shaderID];
                                r.__webglShader = {
                                    name: t.type,
                                    uniforms: e.UniformsUtils.clone(h.uniforms),
                                    vertexShader: h.vertexShader,
                                    fragmentShader: h.fragmentShader
                                }
                            } else
                                r.__webglShader = {
                                    name: t.type,
                                    uniforms: t.uniforms,
                                    vertexShader: t.vertexShader,
                                    fragmentShader: t.fragmentShader
                                };
                            t.__webglShader = r.__webglShader,
                            s = ce.acquireProgram(t, a, o),
                            r.program = s,
                            t.program = s
                        }
                        var u = s.getAttributes();
                        if (t.morphTargets) {
                            t.numSupportedMorphTargets = 0;
                            for (var p = 0; p < dt.maxMorphTargets; p++)
                                u["morphTarget" + p] >= 0 && t.numSupportedMorphTargets++
                        }
                        if (t.morphNormals) {
                            t.numSupportedMorphNormals = 0;
                            for (var p = 0; p < dt.maxMorphNormals; p++)
                                u["morphNormal" + p] >= 0 && t.numSupportedMorphNormals++
                        }
                        var f = r.__webglShader.uniforms;
                        !t.isShaderMaterial && !t.isRawShaderMaterial | t.clipping === !0 && (r.numClippingPlanes = Dt.numPlanes,
                        f.clippingPlanes = Dt.uniform),
                        r.fog = i,
                        r.lightsHash = kt.hash,
                        t.lights && (f.ambientLightColor.value = kt.ambient,
                        f.directionalLights.value = kt.directional,
                        f.spotLights.value = kt.spot,
                        f.pointLights.value = kt.point,
                        f.hemisphereLights.value = kt.hemi,
                        f.directionalShadowMap.value = kt.directionalShadowMap,
                        f.directionalShadowMatrix.value = kt.directionalShadowMatrix,
                        f.spotShadowMap.value = kt.spotShadowMap,
                        f.spotShadowMatrix.value = kt.spotShadowMatrix,
                        f.pointShadowMap.value = kt.pointShadowMap,
                        f.pointShadowMatrix.value = kt.pointShadowMatrix);
                        var m = r.program.getUniforms()
                          , g = X.seqWithValue(m.seq, f);
                        r.uniformsList = g,
                        r.dynamicUniforms = X.splitDynamic(g, f)
                    }
                    function S(t) {
                        t.side === wr ? ee.disable(Vt.CULL_FACE) : ee.enable(Vt.CULL_FACE),
                        ee.setFlipSided(t.side === br),
                        t.transparent === !0 ? ee.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : ee.setBlending(Pr),
                        ee.setDepthFunc(t.depthFunc),
                        ee.setDepthTest(t.depthTest),
                        ee.setDepthWrite(t.depthWrite),
                        ee.setColorWrite(t.colorWrite),
                        ee.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    }
                    function E(t, e, i, n) {
                        Tt = 0;
                        var r = ie.get(i);
                        if (Ut && (Ft || t !== yt)) {
                            var a = t === yt && i.id === vt;
                            Dt.setState(i.clippingPlanes, i.clipShadows, t, r, a)
                        }
                        i.needsUpdate === !1 && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : i.lights && r.lightsHash !== kt.hash ? i.needsUpdate = !0 : void 0 !== r.numClippingPlanes && r.numClippingPlanes !== Dt.numPlanes && (i.needsUpdate = !0)),
                        i.needsUpdate && (T(i, e, n),
                        i.needsUpdate = !1);
                        var o = !1
                          , s = !1
                          , l = !1
                          , h = r.program
                          , c = h.getUniforms()
                          , u = r.__webglShader.uniforms;
                        if (h.id !== ft && (Vt.useProgram(h.program),
                        ft = h.id,
                        o = !0,
                        s = !0,
                        l = !0),
                        i.id !== vt && (vt = i.id,
                        s = !0),
                        o || t !== yt) {
                            if (c.set(Vt, t, "projectionMatrix"),
                            te.logarithmicDepthBuffer && c.setValue(Vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                            t !== yt && (yt = t,
                            s = !0,
                            l = !0),
                            i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                                var p = c.map.cameraPosition;
                                void 0 !== p && p.setValue(Vt, Bt.setFromMatrixPosition(t.matrixWorld))
                            }
                            (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && c.setValue(Vt, "viewMatrix", t.matrixWorldInverse),
                            c.set(Vt, dt, "toneMappingExposure"),
                            c.set(Vt, dt, "toneMappingWhitePoint")
                        }
                        if (i.skinning) {
                            c.setOptional(Vt, n, "bindMatrix"),
                            c.setOptional(Vt, n, "bindMatrixInverse");
                            var d = n.skeleton;
                            d && (te.floatVertexTextures && d.useVertexTexture ? (c.set(Vt, d, "boneTexture"),
                            c.set(Vt, d, "boneTextureWidth"),
                            c.set(Vt, d, "boneTextureHeight")) : c.setOptional(Vt, d, "boneMatrices"))
                        }
                        s && (i.lights && F(u, l),
                        e && i.fog && C(u, e),
                        (i.isMeshBasicMaterial || i.isMeshLambertMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.isMeshDepthMaterial) && A(u, i),
                        i.isLineBasicMaterial ? P(u, i) : i.isLineDashedMaterial ? (P(u, i),
                        R(u, i)) : i.isPointsMaterial ? L(u, i) : i.isMeshLambertMaterial ? O(u, i) : i.isMeshPhongMaterial ? I(u, i) : i.isMeshPhysicalMaterial ? U(u, i) : i.isMeshStandardMaterial ? D(u, i) : i.isMeshDepthMaterial ? i.displacementMap && (u.displacementMap.value = i.displacementMap,
                        u.displacementScale.value = i.displacementScale,
                        u.displacementBias.value = i.displacementBias) : i.isMeshNormalMaterial && (u.opacity.value = i.opacity),
                        X.upload(Vt, r.uniformsList, u, dt)),
                        c.set(Vt, n, "modelViewMatrix"),
                        c.set(Vt, n, "normalMatrix"),
                        c.setValue(Vt, "modelMatrix", n.matrixWorld);
                        var f = r.dynamicUniforms;
                        return null !== f && (X.evalDynamic(f, u, n, t),
                        X.upload(Vt, f, u, dt)),
                        h
                    }
                    function A(t, e) {
                        t.opacity.value = e.opacity,
                        t.diffuse.value = e.color,
                        e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
                        t.map.value = e.map,
                        t.specularMap.value = e.specularMap,
                        t.alphaMap.value = e.alphaMap,
                        e.aoMap && (t.aoMap.value = e.aoMap,
                        t.aoMapIntensity.value = e.aoMapIntensity);
                        var i;
                        if (e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap),
                        void 0 !== i) {
                            i.isWebGLRenderTarget && (i = i.texture);
                            var n = i.offset
                              , r = i.repeat;
                            t.offsetRepeat.value.set(n.x, n.y, r.x, r.y)
                        }
                        t.envMap.value = e.envMap,
                        t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1,
                        t.reflectivity.value = e.reflectivity,
                        t.refractionRatio.value = e.refractionRatio
                    }
                    function P(t, e) {
                        t.diffuse.value = e.color,
                        t.opacity.value = e.opacity
                    }
                    function R(t, e) {
                        t.dashSize.value = e.dashSize,
                        t.totalSize.value = e.dashSize + e.gapSize,
                        t.scale.value = e.scale
                    }
                    function L(t, e) {
                        if (t.diffuse.value = e.color,
                        t.opacity.value = e.opacity,
                        t.size.value = e.size * Rt,
                        t.scale.value = .5 * G.clientHeight,
                        t.map.value = e.map,
                        null !== e.map) {
                            var i = e.map.offset
                              , n = e.map.repeat;
                            t.offsetRepeat.value.set(i.x, i.y, n.x, n.y)
                        }
                    }
                    function C(t, e) {
                        t.fogColor.value = e.color,
                        e.isFog ? (t.fogNear.value = e.near,
                        t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }
                    function O(t, e) {
                        e.lightMap && (t.lightMap.value = e.lightMap,
                        t.lightMapIntensity.value = e.lightMapIntensity),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }
                    function I(t, e) {
                        t.specular.value = e.specular,
                        t.shininess.value = Math.max(e.shininess, 1e-4),
                        e.lightMap && (t.lightMap.value = e.lightMap,
                        t.lightMapIntensity.value = e.lightMapIntensity),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale)),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias)
                    }
                    function D(t, e) {
                        t.roughness.value = e.roughness,
                        t.metalness.value = e.metalness,
                        e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
                        e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
                        e.lightMap && (t.lightMap.value = e.lightMap,
                        t.lightMapIntensity.value = e.lightMapIntensity),
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                        e.bumpMap && (t.bumpMap.value = e.bumpMap,
                        t.bumpScale.value = e.bumpScale),
                        e.normalMap && (t.normalMap.value = e.normalMap,
                        t.normalScale.value.copy(e.normalScale)),
                        e.displacementMap && (t.displacementMap.value = e.displacementMap,
                        t.displacementScale.value = e.displacementScale,
                        t.displacementBias.value = e.displacementBias),
                        e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                    }
                    function U(t, e) {
                        t.clearCoat.value = e.clearCoat,
                        t.clearCoatRoughness.value = e.clearCoatRoughness,
                        D(t, e)
                    }
                    function F(t, e) {
                        t.ambientLightColor.needsUpdate = e,
                        t.directionalLights.needsUpdate = e,
                        t.pointLights.needsUpdate = e,
                        t.spotLights.needsUpdate = e,
                        t.hemisphereLights.needsUpdate = e
                    }
                    function N(t) {
                        for (var e = 0, i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.castShadow && (kt.shadows[e++] = r)
                        }
                        kt.shadows.length = e
                    }
                    function z(t, e) {
                        var i, n, r, a, s, l, h, c = 0, u = 0, p = 0, d = e.matrixWorldInverse, f = 0, m = 0, g = 0, v = 0;
                        for (i = 0,
                        n = t.length; i < n; i++)
                            if (r = t[i],
                            a = r.color,
                            s = r.intensity,
                            l = r.distance,
                            h = r.shadow && r.shadow.map ? r.shadow.map.texture : null,
                            r.isAmbientLight)
                                c += a.r * s,
                                u += a.g * s,
                                p += a.b * s;
                            else if (r.isDirectionalLight) {
                                var _ = ue.get(r);
                                _.color.copy(r.color).multiplyScalar(r.intensity),
                                _.direction.setFromMatrixPosition(r.matrixWorld),
                                Bt.setFromMatrixPosition(r.target.matrixWorld),
                                _.direction.sub(Bt),
                                _.direction.transformDirection(d),
                                _.shadow = r.castShadow,
                                r.castShadow && (_.shadowBias = r.shadow.bias,
                                _.shadowRadius = r.shadow.radius,
                                _.shadowMapSize = r.shadow.mapSize),
                                kt.directionalShadowMap[f] = h,
                                kt.directionalShadowMatrix[f] = r.shadow.matrix,
                                kt.directional[f++] = _
                            } else if (r.isSpotLight) {
                                var _ = ue.get(r);
                                _.position.setFromMatrixPosition(r.matrixWorld),
                                _.position.applyMatrix4(d),
                                _.color.copy(a).multiplyScalar(s),
                                _.distance = l,
                                _.direction.setFromMatrixPosition(r.matrixWorld),
                                Bt.setFromMatrixPosition(r.target.matrixWorld),
                                _.direction.sub(Bt),
                                _.direction.transformDirection(d),
                                _.coneCos = Math.cos(r.angle),
                                _.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)),
                                _.decay = 0 === r.distance ? 0 : r.decay,
                                _.shadow = r.castShadow,
                                r.castShadow && (_.shadowBias = r.shadow.bias,
                                _.shadowRadius = r.shadow.radius,
                                _.shadowMapSize = r.shadow.mapSize),
                                kt.spotShadowMap[g] = h,
                                kt.spotShadowMatrix[g] = r.shadow.matrix,
                                kt.spot[g++] = _
                            } else if (r.isPointLight) {
                                var _ = ue.get(r);
                                _.position.setFromMatrixPosition(r.matrixWorld),
                                _.position.applyMatrix4(d),
                                _.color.copy(r.color).multiplyScalar(r.intensity),
                                _.distance = r.distance,
                                _.decay = 0 === r.distance ? 0 : r.decay,
                                _.shadow = r.castShadow,
                                r.castShadow && (_.shadowBias = r.shadow.bias,
                                _.shadowRadius = r.shadow.radius,
                                _.shadowMapSize = r.shadow.mapSize),
                                kt.pointShadowMap[m] = h,
                                void 0 === kt.pointShadowMatrix[m] && (kt.pointShadowMatrix[m] = new o),
                                Bt.setFromMatrixPosition(r.matrixWorld).negate(),
                                kt.pointShadowMatrix[m].identity().setPosition(Bt),
                                kt.point[m++] = _
                            } else if (r.isHemisphereLight) {
                                var _ = ue.get(r);
                                _.direction.setFromMatrixPosition(r.matrixWorld),
                                _.direction.transformDirection(d),
                                _.direction.normalize(),
                                _.skyColor.copy(r.color).multiplyScalar(s),
                                _.groundColor.copy(r.groundColor).multiplyScalar(s),
                                kt.hemi[v++] = _
                            }
                        kt.ambient[0] = c,
                        kt.ambient[1] = u,
                        kt.ambient[2] = p,
                        kt.directional.length = f,
                        kt.spot.length = g,
                        kt.point.length = m,
                        kt.hemi.length = v,
                        kt.hash = f + "," + m + "," + g + "," + v + "," + kt.shadows.length
                    }
                    function B() {
                        var t = Tt;
                        return t >= te.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + te.maxTextures),
                        Tt += 1,
                        t
                    }
                    function k(t) {
                        var e;
                        if (t === xa)
                            return Vt.REPEAT;
                        if (t === ba)
                            return Vt.CLAMP_TO_EDGE;
                        if (t === wa)
                            return Vt.MIRRORED_REPEAT;
                        if (t === Ma)
                            return Vt.NEAREST;
                        if (t === Ta)
                            return Vt.NEAREST_MIPMAP_NEAREST;
                        if (t === Sa)
                            return Vt.NEAREST_MIPMAP_LINEAR;
                        if (t === Ea)
                            return Vt.LINEAR;
                        if (t === Aa)
                            return Vt.LINEAR_MIPMAP_NEAREST;
                        if (t === Pa)
                            return Vt.LINEAR_MIPMAP_LINEAR;
                        if (t === Ra)
                            return Vt.UNSIGNED_BYTE;
                        if (t === Na)
                            return Vt.UNSIGNED_SHORT_4_4_4_4;
                        if (t === za)
                            return Vt.UNSIGNED_SHORT_5_5_5_1;
                        if (t === Ba)
                            return Vt.UNSIGNED_SHORT_5_6_5;
                        if (t === La)
                            return Vt.BYTE;
                        if (t === Ca)
                            return Vt.SHORT;
                        if (t === Oa)
                            return Vt.UNSIGNED_SHORT;
                        if (t === Ia)
                            return Vt.INT;
                        if (t === Da)
                            return Vt.UNSIGNED_INT;
                        if (t === Ua)
                            return Vt.FLOAT;
                        if (e = Kt.get("OES_texture_half_float"),
                        null !== e && t === Fa)
                            return e.HALF_FLOAT_OES;
                        if (t === Ga)
                            return Vt.ALPHA;
                        if (t === Va)
                            return Vt.RGB;
                        if (t === Ha)
                            return Vt.RGBA;
                        if (t === ja)
                            return Vt.LUMINANCE;
                        if (t === Wa)
                            return Vt.LUMINANCE_ALPHA;
                        if (t === Ya)
                            return Vt.DEPTH_COMPONENT;
                        if (t === qa)
                            return Vt.DEPTH_STENCIL;
                        if (t === Dr)
                            return Vt.FUNC_ADD;
                        if (t === Ur)
                            return Vt.FUNC_SUBTRACT;
                        if (t === Fr)
                            return Vt.FUNC_REVERSE_SUBTRACT;
                        if (t === Br)
                            return Vt.ZERO;
                        if (t === kr)
                            return Vt.ONE;
                        if (t === Gr)
                            return Vt.SRC_COLOR;
                        if (t === Vr)
                            return Vt.ONE_MINUS_SRC_COLOR;
                        if (t === Hr)
                            return Vt.SRC_ALPHA;
                        if (t === jr)
                            return Vt.ONE_MINUS_SRC_ALPHA;
                        if (t === Wr)
                            return Vt.DST_ALPHA;
                        if (t === Xr)
                            return Vt.ONE_MINUS_DST_ALPHA;
                        if (t === Yr)
                            return Vt.DST_COLOR;
                        if (t === qr)
                            return Vt.ONE_MINUS_DST_COLOR;
                        if (t === Zr)
                            return Vt.SRC_ALPHA_SATURATE;
                        if (e = Kt.get("WEBGL_compressed_texture_s3tc"),
                        null !== e) {
                            if (t === Za)
                                return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Qa)
                                return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Ja)
                                return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Ka)
                                return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (e = Kt.get("WEBGL_compressed_texture_pvrtc"),
                        null !== e) {
                            if (t === $a)
                                return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === to)
                                return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === eo)
                                return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === io)
                                return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (e = Kt.get("WEBGL_compressed_texture_etc1"),
                        null !== e && t === no)
                            return e.COMPRESSED_RGB_ETC1_WEBGL;
                        if (e = Kt.get("EXT_blend_minmax"),
                        null !== e) {
                            if (t === Nr)
                                return e.MIN_EXT;
                            if (t === zr)
                                return e.MAX_EXT
                        }
                        return e = Kt.get("WEBGL_depth_texture"),
                        null !== e && t === ka ? e.UNSIGNED_INT_24_8_WEBGL : 0
                    }
                    console.log("THREE.WebGLRenderer", hr),
                    t = t || {};
                    var G = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                      , V = void 0 !== t.context ? t.context : null
                      , H = void 0 !== t.alpha && t.alpha
                      , j = void 0 === t.depth || t.depth
                      , W = void 0 === t.stencil || t.stencil
                      , Q = void 0 !== t.antialias && t.antialias
                      , J = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
                      , K = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
                      , et = []
                      , it = []
                      , rt = -1
                      , at = []
                      , lt = -1
                      , ht = new Float32Array(8)
                      , ut = []
                      , pt = [];
                    this.domElement = G,
                    this.context = null,
                    this.autoClear = !0,
                    this.autoClearColor = !0,
                    this.autoClearDepth = !0,
                    this.autoClearStencil = !0,
                    this.sortObjects = !0,
                    this.clippingPlanes = [],
                    this.localClippingEnabled = !1,
                    this.gammaFactor = 2,
                    this.gammaInput = !1,
                    this.gammaOutput = !1,
                    this.physicallyCorrectLights = !1,
                    this.toneMapping = la,
                    this.toneMappingExposure = 1,
                    this.toneMappingWhitePoint = 1,
                    this.maxMorphTargets = 8,
                    this.maxMorphNormals = 4;
                    var dt = this
                      , ft = null
                      , mt = null
                      , gt = null
                      , vt = -1
                      , _t = ""
                      , yt = null
                      , xt = new q
                      , bt = null
                      , wt = new q
                      , Tt = 0
                      , St = new tt(0)
                      , Et = 0
                      , At = G.width
                      , Pt = G.height
                      , Rt = 1
                      , Lt = new q(0,0,At,Pt)
                      , Ct = !1
                      , Ot = new q(0,0,At,Pt)
                      , It = new ot
                      , Dt = new Qt
                      , Ut = !1
                      , Ft = !1
                      , Nt = new nt
                      , zt = new o
                      , Bt = new l
                      , kt = {
                        hash: "",
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        shadows: []
                    }
                      , Gt = {
                        calls: 0,
                        vertices: 0,
                        faces: 0,
                        points: 0
                    };
                    this.info = {
                        render: Gt,
                        memory: {
                            geometries: 0,
                            textures: 0
                        },
                        programs: null
                    };
                    var Vt;
                    try {
                        var jt = {
                            alpha: H,
                            depth: j,
                            stencil: W,
                            antialias: Q,
                            premultipliedAlpha: J,
                            preserveDrawingBuffer: K
                        };
                        if (Vt = V || G.getContext("webgl", jt) || G.getContext("experimental-webgl", jt),
                        null === Vt)
                            throw null !== G.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                        void 0 === Vt.getShaderPrecisionFormat && (Vt.getShaderPrecisionFormat = function() {
                            return {
                                rangeMin: 1,
                                rangeMax: 1,
                                precision: 1
                            }
                        }
                        ),
                        G.addEventListener("webglcontextlost", s, !1)
                    } catch (t) {
                        console.error("THREE.WebGLRenderer: " + t)
                    }
                    var Kt = new qt(Vt);
                    Kt.get("WEBGL_depth_texture"),
                    Kt.get("OES_texture_float"),
                    Kt.get("OES_texture_float_linear"),
                    Kt.get("OES_texture_half_float"),
                    Kt.get("OES_texture_half_float_linear"),
                    Kt.get("OES_standard_derivatives"),
                    Kt.get("ANGLE_instanced_arrays"),
                    Kt.get("OES_element_index_uint") && (Ht.MaxIndex = 4294967296);
                    var te = new Yt(Vt,Kt,t)
                      , ee = new Z(Vt,Kt,k)
                      , ie = new ct
                      , oe = new Y(Vt,Kt,ee,ie,te,k,this.info)
                      , he = new Wt(Vt,ie,this.info)
                      , ce = new Mt(this,te)
                      , ue = new Xt;
                    this.info.programs = ce.programs;
                    var pe = new Jt(Vt,Kt,Gt)
                      , de = new Zt(Vt,Kt,Gt)
                      , fe = new le(-1,1,1,-1,0,1)
                      , me = new se
                      , ge = new re(new ae(2,2),new ne({
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }))
                      , ve = Il.cube
                      , _e = new re(new $t(5,5,5),new $({
                        uniforms: ve.uniforms,
                        vertexShader: ve.vertexShader,
                        fragmentShader: ve.fragmentShader,
                        side: br,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    }));
                    r(),
                    this.context = Vt,
                    this.capabilities = te,
                    this.extensions = Kt,
                    this.properties = ie,
                    this.state = ee;
                    var ye = new st(this,kt,he,te);
                    this.shadowMap = ye;
                    var xe = new h(this,ut)
                      , be = new u(this,pt);
                    this.getContext = function() {
                        return Vt
                    }
                    ,
                    this.getContextAttributes = function() {
                        return Vt.getContextAttributes()
                    }
                    ,
                    this.forceContextLoss = function() {
                        Kt.get("WEBGL_lose_context").loseContext()
                    }
                    ,
                    this.getMaxAnisotropy = function() {
                        return te.getMaxAnisotropy()
                    }
                    ,
                    this.getPrecision = function() {
                        return te.precision
                    }
                    ,
                    this.getPixelRatio = function() {
                        return Rt
                    }
                    ,
                    this.setPixelRatio = function(t) {
                        void 0 !== t && (Rt = t,
                        this.setSize(Ot.z, Ot.w, !1))
                    }
                    ,
                    this.getSize = function() {
                        return {
                            width: At,
                            height: Pt
                        }
                    }
                    ,
                    this.setSize = function(t, e, i) {
                        At = t,
                        Pt = e,
                        G.width = t * Rt,
                        G.height = e * Rt,
                        i !== !1 && (G.style.width = t + "px",
                        G.style.height = e + "px"),
                        this.setViewport(0, 0, t, e)
                    }
                    ,
                    this.setViewport = function(t, e, i, n) {
                        ee.viewport(Ot.set(t, e, i, n))
                    }
                    ,
                    this.setScissor = function(t, e, i, n) {
                        ee.scissor(Lt.set(t, e, i, n))
                    }
                    ,
                    this.setScissorTest = function(t) {
                        ee.setScissorTest(Ct = t)
                    }
                    ,
                    this.getClearColor = function() {
                        return St
                    }
                    ,
                    this.setClearColor = function(t, e) {
                        St.set(t),
                        Et = void 0 !== e ? e : 1,
                        n(St.r, St.g, St.b, Et)
                    }
                    ,
                    this.getClearAlpha = function() {
                        return Et
                    }
                    ,
                    this.setClearAlpha = function(t) {
                        Et = t,
                        n(St.r, St.g, St.b, Et)
                    }
                    ,
                    this.clear = function(t, e, i) {
                        var n = 0;
                        (void 0 === t || t) && (n |= Vt.COLOR_BUFFER_BIT),
                        (void 0 === e || e) && (n |= Vt.DEPTH_BUFFER_BIT),
                        (void 0 === i || i) && (n |= Vt.STENCIL_BUFFER_BIT),
                        Vt.clear(n)
                    }
                    ,
                    this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }
                    ,
                    this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }
                    ,
                    this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }
                    ,
                    this.clearTarget = function(t, e, i, n) {
                        this.setRenderTarget(t),
                        this.clear(e, i, n)
                    }
                    ,
                    this.resetGLState = a,
                    this.dispose = function() {
                        at = [],
                        lt = -1,
                        it = [],
                        rt = -1,
                        G.removeEventListener("webglcontextlost", s, !1)
                    }
                    ,
                    this.renderBufferImmediate = function(t, e, i) {
                        ee.initAttributes();
                        var n = ie.get(t);
                        t.hasPositions && !n.position && (n.position = Vt.createBuffer()),
                        t.hasNormals && !n.normal && (n.normal = Vt.createBuffer()),
                        t.hasUvs && !n.uv && (n.uv = Vt.createBuffer()),
                        t.hasColors && !n.color && (n.color = Vt.createBuffer());
                        var r = e.getAttributes();
                        if (t.hasPositions && (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.position),
                        Vt.bufferData(Vt.ARRAY_BUFFER, t.positionArray, Vt.DYNAMIC_DRAW),
                        ee.enableAttribute(r.position),
                        Vt.vertexAttribPointer(r.position, 3, Vt.FLOAT, !1, 0, 0)),
                        t.hasNormals) {
                            if (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.normal),
                            !i.isMeshPhongMaterial && !i.isMeshStandardMaterial && i.shading === Mr)
                                for (var a = 0, o = 3 * t.count; a < o; a += 9) {
                                    var s = t.normalArray
                                      , l = (s[a + 0] + s[a + 3] + s[a + 6]) / 3
                                      , h = (s[a + 1] + s[a + 4] + s[a + 7]) / 3
                                      , c = (s[a + 2] + s[a + 5] + s[a + 8]) / 3;
                                    s[a + 0] = l,
                                    s[a + 1] = h,
                                    s[a + 2] = c,
                                    s[a + 3] = l,
                                    s[a + 4] = h,
                                    s[a + 5] = c,
                                    s[a + 6] = l,
                                    s[a + 7] = h,
                                    s[a + 8] = c
                                }
                            Vt.bufferData(Vt.ARRAY_BUFFER, t.normalArray, Vt.DYNAMIC_DRAW),
                            ee.enableAttribute(r.normal),
                            Vt.vertexAttribPointer(r.normal, 3, Vt.FLOAT, !1, 0, 0)
                        }
                        t.hasUvs && i.map && (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.uv),
                        Vt.bufferData(Vt.ARRAY_BUFFER, t.uvArray, Vt.DYNAMIC_DRAW),
                        ee.enableAttribute(r.uv),
                        Vt.vertexAttribPointer(r.uv, 2, Vt.FLOAT, !1, 0, 0)),
                        t.hasColors && i.vertexColors !== Sr && (Vt.bindBuffer(Vt.ARRAY_BUFFER, n.color),
                        Vt.bufferData(Vt.ARRAY_BUFFER, t.colorArray, Vt.DYNAMIC_DRAW),
                        ee.enableAttribute(r.color),
                        Vt.vertexAttribPointer(r.color, 3, Vt.FLOAT, !1, 0, 0)),
                        ee.disableUnusedAttributes(),
                        Vt.drawArrays(Vt.TRIANGLES, 0, t.count),
                        t.count = 0
                    }
                    ,
                    this.renderBufferDirect = function(t, e, n, r, a, o) {
                        S(r);
                        var s = E(t, e, r, a)
                          , l = !1
                          , h = n.id + "_" + s.id + "_" + r.wireframe;
                        h !== _t && (_t = h,
                        l = !0);
                        var c = a.morphTargetInfluences;
                        if (void 0 !== c) {
                            for (var u = [], p = 0, d = c.length; p < d; p++) {
                                var g = c[p];
                                u.push([g, p])
                            }
                            u.sort(m),
                            u.length > 8 && (u.length = 8);
                            for (var v = n.morphAttributes, p = 0, d = u.length; p < d; p++) {
                                var g = u[p];
                                if (ht[p] = g[0],
                                0 !== g[0]) {
                                    var _ = g[1];
                                    r.morphTargets === !0 && v.position && n.addAttribute("morphTarget" + p, v.position[_]),
                                    r.morphNormals === !0 && v.normal && n.addAttribute("morphNormal" + p, v.normal[_])
                                } else
                                    r.morphTargets === !0 && n.removeAttribute("morphTarget" + p),
                                    r.morphNormals === !0 && n.removeAttribute("morphNormal" + p)
                            }
                            s.getUniforms().setValue(Vt, "morphTargetInfluences", ht),
                            l = !0
                        }
                        var _ = n.index
                          , y = n.attributes.position;
                        r.wireframe === !0 && (_ = he.getWireframeAttribute(n));
                        var x;
                        null !== _ ? (x = de,
                        x.setIndex(_)) : x = pe,
                        l && (f(r, s, n),
                        null !== _ && Vt.bindBuffer(Vt.ELEMENT_ARRAY_BUFFER, he.getAttributeBuffer(_)));
                        var b = 0
                          , w = 1 / 0;
                        null !== _ ? w = _.count : void 0 !== y && (w = y.count);
                        var M = n.drawRange.start
                          , T = n.drawRange.count
                          , A = null !== o ? o.start : 0
                          , P = null !== o ? o.count : 1 / 0
                          , R = Math.max(b, M, A)
                          , L = Math.min(b + w, M + T, A + P) - 1
                          , C = Math.max(0, L - R + 1);
                        if (a.isMesh)
                            if (r.wireframe === !0)
                                ee.setLineWidth(r.wireframeLinewidth * i()),
                                x.setMode(Vt.LINES);
                            else
                                switch (a.drawMode) {
                                case fo:
                                    x.setMode(Vt.TRIANGLES);
                                    break;
                                case mo:
                                    x.setMode(Vt.TRIANGLE_STRIP);
                                    break;
                                case go:
                                    x.setMode(Vt.TRIANGLE_FAN)
                                }
                        else if (a.isLine) {
                            var O = r.linewidth;
                            void 0 === O && (O = 1),
                            ee.setLineWidth(O * i()),
                            a.isLineSegments ? x.setMode(Vt.LINES) : x.setMode(Vt.LINE_STRIP)
                        } else
                            a.isPoints && x.setMode(Vt.POINTS);
                        n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && x.renderInstances(n, R, C) : x.render(R, C)
                    }
                    ,
                    this.render = function(t, e, i, r) {
                        if ((e && e.isCamera) === !1)
                            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        var a = t.fog;
                        _t = "",
                        vt = -1,
                        yt = null,
                        t.autoUpdate === !0 && t.updateMatrixWorld(),
                        null === e.parent && e.updateMatrixWorld(),
                        e.matrixWorldInverse.getInverse(e.matrixWorld),
                        zt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                        It.setFromMatrix(zt),
                        et.length = 0,
                        rt = -1,
                        lt = -1,
                        ut.length = 0,
                        pt.length = 0,
                        Ft = this.localClippingEnabled,
                        Ut = Dt.init(this.clippingPlanes, Ft, e),
                        w(t, e),
                        it.length = rt + 1,
                        at.length = lt + 1,
                        dt.sortObjects === !0 && (it.sort(g),
                        at.sort(v)),
                        Ut && Dt.beginShadows(),
                        N(et),
                        ye.render(t, e),
                        z(et, e),
                        Ut && Dt.endShadows(),
                        Gt.calls = 0,
                        Gt.vertices = 0,
                        Gt.faces = 0,
                        Gt.points = 0,
                        void 0 === i && (i = null),
                        this.setRenderTarget(i);
                        var o = t.background;
                        if (null === o ? n(St.r, St.g, St.b, Et) : o && o.isColor && (n(o.r, o.g, o.b, 1),
                        r = !0),
                        (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
                        o && o.isCubeTexture ? (me.projectionMatrix.copy(e.projectionMatrix),
                        me.matrixWorld.extractRotation(e.matrixWorld),
                        me.matrixWorldInverse.getInverse(me.matrixWorld),
                        _e.material.uniforms.tCube.value = o,
                        _e.modelViewMatrix.multiplyMatrices(me.matrixWorldInverse, _e.matrixWorld),
                        he.update(_e),
                        dt.renderBufferDirect(me, null, _e.geometry, _e.material, _e, null)) : o && o.isTexture && (ge.material.map = o,
                        he.update(ge),
                        dt.renderBufferDirect(fe, null, ge.geometry, ge.material, ge, null)),
                        t.overrideMaterial) {
                            var s = t.overrideMaterial;
                            M(it, e, a, s),
                            M(at, e, a, s)
                        } else
                            ee.setBlending(Pr),
                            M(it, e, a),
                            M(at, e, a);
                        xe.render(t, e),
                        be.render(t, e, wt),
                        i && oe.updateRenderTargetMipmap(i),
                        ee.setDepthTest(!0),
                        ee.setDepthWrite(!0),
                        ee.setColorWrite(!0)
                    }
                    ,
                    this.setFaceCulling = function(t, e) {
                        ee.setCullFace(t),
                        ee.setFlipSided(e === mr)
                    }
                    ,
                    this.allocTextureUnit = B,
                    this.setTexture2D = function() {
                        var t = !1;
                        return function(e, i) {
                            e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
                            t = !0),
                            e = e.texture),
                            oe.setTexture2D(e, i)
                        }
                    }(),
                    this.setTexture = function() {
                        var t = !1;
                        return function(e, i) {
                            t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
                            t = !0),
                            oe.setTexture2D(e, i)
                        }
                    }(),
                    this.setTextureCube = function() {
                        var t = !1;
                        return function(e, i) {
                            e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
                            t = !0),
                            e = e.texture),
                            e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? oe.setTextureCube(e, i) : oe.setTextureCubeDynamic(e, i)
                        }
                    }(),
                    this.getCurrentRenderTarget = function() {
                        return mt
                    }
                    ,
                    this.setRenderTarget = function(t) {
                        mt = t,
                        t && void 0 === ie.get(t).__webglFramebuffer && oe.setupRenderTarget(t);
                        var e, i = t && t.isWebGLRenderTargetCube;
                        if (t) {
                            var n = ie.get(t);
                            e = i ? n.__webglFramebuffer[t.activeCubeFace] : n.__webglFramebuffer,
                            xt.copy(t.scissor),
                            bt = t.scissorTest,
                            wt.copy(t.viewport)
                        } else
                            e = null,
                            xt.copy(Lt).multiplyScalar(Rt),
                            bt = Ct,
                            wt.copy(Ot).multiplyScalar(Rt);
                        if (gt !== e && (Vt.bindFramebuffer(Vt.FRAMEBUFFER, e),
                        gt = e),
                        ee.scissor(xt),
                        ee.setScissorTest(bt),
                        ee.viewport(wt),
                        i) {
                            var r = ie.get(t.texture);
                            Vt.framebufferTexture2D(Vt.FRAMEBUFFER, Vt.COLOR_ATTACHMENT0, Vt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                        }
                    }
                    ,
                    this.readRenderTargetPixels = function(t, e, i, n, r, a) {
                        if ((t && t.isWebGLRenderTarget) === !1)
                            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        var o = ie.get(t).__webglFramebuffer;
                        if (o) {
                            var s = !1;
                            o !== gt && (Vt.bindFramebuffer(Vt.FRAMEBUFFER, o),
                            s = !0);
                            try {
                                var l = t.texture
                                  , h = l.format
                                  , c = l.type;
                                if (h !== Ha && k(h) !== Vt.getParameter(Vt.IMPLEMENTATION_COLOR_READ_FORMAT))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(c === Ra || k(c) === Vt.getParameter(Vt.IMPLEMENTATION_COLOR_READ_TYPE) || c === Ua && (Kt.get("OES_texture_float") || Kt.get("WEBGL_color_buffer_float")) || c === Fa && Kt.get("EXT_color_buffer_half_float")))
                                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                Vt.checkFramebufferStatus(Vt.FRAMEBUFFER) === Vt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && Vt.readPixels(e, i, n, r, k(h), k(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && Vt.bindFramebuffer(Vt.FRAMEBUFFER, gt)
                            }
                        }
                    }
                }
                function ce(t, e) {
                    this.name = "",
                    this.color = new tt(t),
                    this.density = void 0 !== e ? e : 25e-5
                }
                function ue(t, e, i) {
                    this.name = "",
                    this.color = new tt(t),
                    this.near = void 0 !== e ? e : 1,
                    this.far = void 0 !== i ? i : 1e3
                }
                function pe() {
                    zt.call(this),
                    this.type = "Scene",
                    this.background = null,
                    this.fog = null,
                    this.overrideMaterial = null,
                    this.autoUpdate = !0
                }
                function de(t, e, i, n, r) {
                    zt.call(this),
                    this.lensFlares = [],
                    this.positionScreen = new l,
                    this.customUpdateCallback = void 0,
                    void 0 !== t && this.add(t, e, i, n, r)
                }
                function fe(t) {
                    J.call(this),
                    this.type = "SpriteMaterial",
                    this.color = new tt(16777215),
                    this.map = null,
                    this.rotation = 0,
                    this.fog = !1,
                    this.lights = !1,
                    this.setValues(t)
                }
                function me(t) {
                    zt.call(this),
                    this.type = "Sprite",
                    this.material = void 0 !== t ? t : new fe
                }
                function ge() {
                    zt.call(this),
                    this.type = "LOD",
                    Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        }
                    })
                }
                function ve(t, e, i, n, a, o, s, l, h, c, u, p) {
                    r.call(this, null, o, s, l, h, c, n, a, u, p),
                    this.image = {
                        data: t,
                        width: e,
                        height: i
                    },
                    this.magFilter = void 0 !== h ? h : Ma,
                    this.minFilter = void 0 !== c ? c : Ma,
                    this.flipY = !1,
                    this.generateMipmaps = !1
                }
                function _e(t, i, n) {
                    if (this.useVertexTexture = void 0 === n || n,
                    this.identityMatrix = new o,
                    t = t || [],
                    this.bones = t.slice(0),
                    this.useVertexTexture) {
                        var r = Math.sqrt(4 * this.bones.length);
                        r = e.Math.nextPowerOfTwo(Math.ceil(r)),
                        r = Math.max(r, 4),
                        this.boneTextureWidth = r,
                        this.boneTextureHeight = r,
                        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4),
                        this.boneTexture = new ve(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,Ha,Ua)
                    } else
                        this.boneMatrices = new Float32Array(16 * this.bones.length);
                    if (void 0 === i)
                        this.calculateInverses();
                    else if (this.bones.length === i.length)
                        this.boneInverses = i.slice(0);
                    else {
                        console.warn("THREE.Skeleton bonInverses is the wrong length."),
                        this.boneInverses = [];
                        for (var a = 0, s = this.bones.length; a < s; a++)
                            this.boneInverses.push(new o)
                    }
                }
                function ye(t) {
                    zt.call(this),
                    this.type = "Bone",
                    this.skin = t
                }
                function xe(t, e, i) {
                    re.call(this, t, e),
                    this.type = "SkinnedMesh",
                    this.bindMode = "attached",
                    this.bindMatrix = new o,
                    this.bindMatrixInverse = new o;
                    var n = [];
                    if (this.geometry && void 0 !== this.geometry.bones) {
                        for (var r, a, s = 0, l = this.geometry.bones.length; s < l; ++s)
                            a = this.geometry.bones[s],
                            r = new ye(this),
                            n.push(r),
                            r.name = a.name,
                            r.position.fromArray(a.pos),
                            r.quaternion.fromArray(a.rotq),
                            void 0 !== a.scl && r.scale.fromArray(a.scl);
                        for (var s = 0, l = this.geometry.bones.length; s < l; ++s)
                            a = this.geometry.bones[s],
                            a.parent !== -1 && null !== a.parent && void 0 !== n[a.parent] ? n[a.parent].add(n[s]) : this.add(n[s])
                    }
                    this.normalizeSkinWeights(),
                    this.updateMatrixWorld(!0),
                    this.bind(new _e(n,void 0,i), this.matrixWorld)
                }
                function be(t) {
                    J.call(this),
                    this.type = "LineBasicMaterial",
                    this.color = new tt(16777215),
                    this.linewidth = 1,
                    this.linecap = "round",
                    this.linejoin = "round",
                    this.lights = !1,
                    this.setValues(t)
                }
                function we(t, e, i) {
                    return 1 === i ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
                    new Me(t,e)) : (zt.call(this),
                    this.type = "Line",
                    this.geometry = void 0 !== t ? t : new Ht,
                    void (this.material = void 0 !== e ? e : new be({
                        color: 16777215 * Math.random()
                    })))
                }
                function Me(t, e) {
                    we.call(this, t, e),
                    this.type = "LineSegments"
                }
                function Te(t) {
                    J.call(this),
                    this.type = "PointsMaterial",
                    this.color = new tt(16777215),
                    this.map = null,
                    this.size = 1,
                    this.sizeAttenuation = !0,
                    this.lights = !1,
                    this.setValues(t)
                }
                function Se(t, e) {
                    zt.call(this),
                    this.type = "Points",
                    this.geometry = void 0 !== t ? t : new Ht,
                    this.material = void 0 !== e ? e : new Te({
                        color: 16777215 * Math.random()
                    })
                }
                function Ee() {
                    zt.call(this),
                    this.type = "Group"
                }
                function Ae(t, e, i, n, a, o, s, l, h) {
                    function c() {
                        requestAnimationFrame(c),
                        t.readyState >= t.HAVE_CURRENT_DATA && (u.needsUpdate = !0)
                    }
                    r.call(this, t, e, i, n, a, o, s, l, h),
                    this.generateMipmaps = !1;
                    var u = this;
                    c()
                }
                function Pe(t, e, i, n, a, o, s, l, h, c, u, p) {
                    r.call(this, null, o, s, l, h, c, n, a, u, p),
                    this.image = {
                        width: e,
                        height: i
                    },
                    this.mipmaps = t,
                    this.flipY = !1,
                    this.generateMipmaps = !1
                }
                function Re(t, e, i, n, a, o, s, l, h) {
                    r.call(this, t, e, i, n, a, o, s, l, h),
                    this.needsUpdate = !0
                }
                function Le(t, e, i, n, a, o, s, l, h, c) {
                    if (c = void 0 !== c ? c : Ya,
                    c !== Ya && c !== qa)
                        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    r.call(this, null, n, a, o, s, l, c, i, h),
                    this.image = {
                        width: t,
                        height: e
                    },
                    this.type = void 0 !== i ? i : Oa,
                    this.magFilter = void 0 !== s ? s : Ma,
                    this.minFilter = void 0 !== l ? l : Ma,
                    this.flipY = !1,
                    this.generateMipmaps = !1
                }
                function Ce() {
                    $.call(this, {
                        uniforms: e.UniformsUtils.merge([Ol.lights, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Cl.shadow_vert,
                        fragmentShader: Cl.shadow_frag
                    }),
                    this.lights = !0,
                    this.transparent = !0,
                    Object.defineProperties(this, {
                        opacity: {
                            enumerable: !0,
                            get: function() {
                                return this.uniforms.opacity.value
                            },
                            set: function(t) {
                                this.uniforms.opacity.value = t
                            }
                        }
                    })
                }
                function Oe(t) {
                    $.call(this, t),
                    this.type = "RawShaderMaterial"
                }
                function Ie(t) {
                    this.uuid = e.Math.generateUUID(),
                    this.type = "MultiMaterial",
                    this.materials = t instanceof Array ? t : [],
                    this.visible = !0
                }
                function De(t) {
                    J.call(this),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.type = "MeshStandardMaterial",
                    this.color = new tt(16777215),
                    this.roughness = .5,
                    this.metalness = .5,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new tt(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalScale = new n(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.roughnessMap = null,
                    this.metalnessMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapIntensity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(t)
                }
                function Ue(t) {
                    De.call(this),
                    this.defines = {
                        PHYSICAL: ""
                    },
                    this.type = "MeshPhysicalMaterial",
                    this.reflectivity = .5,
                    this.clearCoat = 0,
                    this.clearCoatRoughness = 0,
                    this.setValues(t)
                }
                function Fe(t) {
                    J.call(this),
                    this.type = "MeshPhongMaterial",
                    this.color = new tt(16777215),
                    this.specular = new tt(1118481),
                    this.shininess = 30,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new tt(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalScale = new n(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = ra,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(t)
                }
                function Ne(t) {
                    J.call(this, t),
                    this.type = "MeshNormalMaterial",
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.morphTargets = !1,
                    this.setValues(t)
                }
                function ze(t) {
                    J.call(this),
                    this.type = "MeshLambertMaterial",
                    this.color = new tt(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new tt(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.combine = ra,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.skinning = !1,
                    this.morphTargets = !1,
                    this.morphNormals = !1,
                    this.setValues(t)
                }
                function Be(t) {
                    J.call(this),
                    this.type = "LineDashedMaterial",
                    this.color = new tt(16777215),
                    this.linewidth = 1,
                    this.scale = 1,
                    this.dashSize = 3,
                    this.gapSize = 1,
                    this.lights = !1,
                    this.setValues(t)
                }
                function ke(t, e, i) {
                    var n = this
                      , r = !1
                      , a = 0
                      , o = 0;
                    this.onStart = void 0,
                    this.onLoad = t,
                    this.onProgress = e,
                    this.onError = i,
                    this.itemStart = function(t) {
                        o++,
                        r === !1 && void 0 !== n.onStart && n.onStart(t, a, o),
                        r = !0
                    }
                    ,
                    this.itemEnd = function(t) {
                        a++,
                        void 0 !== n.onProgress && n.onProgress(t, a, o),
                        a === o && (r = !1,
                        void 0 !== n.onLoad && n.onLoad())
                    }
                    ,
                    this.itemError = function(t) {
                        void 0 !== n.onError && n.onError(t)
                    }
                }
                function Ge(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function Ve(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager,
                    this._parser = null
                }
                function He(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager,
                    this._parser = null
                }
                function je(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function We(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function Xe(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function Ye(t, e) {
                    zt.call(this),
                    this.type = "Light",
                    this.color = new tt(t),
                    this.intensity = void 0 !== e ? e : 1,
                    this.receiveShadow = void 0
                }
                function qe(t, e, i) {
                    Ye.call(this, t, i),
                    this.type = "HemisphereLight",
                    this.castShadow = void 0,
                    this.position.copy(zt.DefaultUp),
                    this.updateMatrix(),
                    this.groundColor = new tt(e)
                }
                function Ze(t) {
                    this.camera = t,
                    this.bias = 0,
                    this.radius = 1,
                    this.mapSize = new n(512,512),
                    this.map = null,
                    this.matrix = new o
                }
                function Qe() {
                    Ze.call(this, new se(50,1,.5,500))
                }
                function Je(t, e, i, n, r, a) {
                    Ye.call(this, t, e),
                    this.type = "SpotLight",
                    this.position.copy(zt.DefaultUp),
                    this.updateMatrix(),
                    this.target = new zt,
                    Object.defineProperty(this, "power", {
                        get: function() {
                            return this.intensity * Math.PI
                        },
                        set: function(t) {
                            this.intensity = t / Math.PI
                        }
                    }),
                    this.distance = void 0 !== i ? i : 0,
                    this.angle = void 0 !== n ? n : Math.PI / 3,
                    this.penumbra = void 0 !== r ? r : 0,
                    this.decay = void 0 !== a ? a : 1,
                    this.shadow = new Qe
                }
                function Ke(t, e, i, n) {
                    Ye.call(this, t, e),
                    this.type = "PointLight",
                    Object.defineProperty(this, "power", {
                        get: function() {
                            return 4 * this.intensity * Math.PI
                        },
                        set: function(t) {
                            this.intensity = t / (4 * Math.PI)
                        }
                    }),
                    this.distance = void 0 !== i ? i : 0,
                    this.decay = void 0 !== n ? n : 1,
                    this.shadow = new Ze(new se(90,1,.5,500))
                }
                function $e(t) {
                    Ze.call(this, new le(-5,5,5,-5,.5,500))
                }
                function ti(t, e) {
                    Ye.call(this, t, e),
                    this.type = "DirectionalLight",
                    this.position.copy(zt.DefaultUp),
                    this.updateMatrix(),
                    this.target = new zt,
                    this.shadow = new $e
                }
                function ei(t, e) {
                    Ye.call(this, t, e),
                    this.type = "AmbientLight",
                    this.castShadow = void 0
                }
                function ii(t, e, i, n) {
                    this.parameterPositions = t,
                    this._cachedIndex = 0,
                    this.resultBuffer = void 0 !== n ? n : new e.constructor(i),
                    this.sampleValues = e,
                    this.valueSize = i
                }
                function ni(t, e, i, n) {
                    ii.call(this, t, e, i, n),
                    this._weightPrev = -0,
                    this._offsetPrev = -0,
                    this._weightNext = -0,
                    this._offsetNext = -0
                }
                function ri(t, e, i, n) {
                    ii.call(this, t, e, i, n)
                }
                function ai(t, e, i, n) {
                    ii.call(this, t, e, i, n)
                }
                function oi(t, i, n, r) {
                    if (void 0 === t)
                        throw new Error("track name is undefined");
                    if (void 0 === i || 0 === i.length)
                        throw new Error("no keyframes in track named " + t);
                    this.name = t,
                    this.times = e.AnimationUtils.convertArray(i, this.TimeBufferType),
                    this.values = e.AnimationUtils.convertArray(n, this.ValueBufferType),
                    this.setInterpolation(r || this.DefaultInterpolation),
                    this.validate(),
                    this.optimize()
                }
                function si(t, e, i, n) {
                    oi.call(this, t, e, i, n)
                }
                function li(t, e, i, n) {
                    ii.call(this, t, e, i, n)
                }
                function hi(t, e, i, n) {
                    oi.call(this, t, e, i, n)
                }
                function ci(t, e, i, n) {
                    oi.call(this, t, e, i, n)
                }
                function ui(t, e, i, n) {
                    oi.call(this, t, e, i, n)
                }
                function pi(t, e, i) {
                    oi.call(this, t, e, i)
                }
                function di(t, e, i, n) {
                    oi.call(this, t, e, i, n)
                }
                function fi(t, e, i, n) {
                    oi.apply(this, arguments)
                }
                function mi(t, i, n) {
                    this.name = t,
                    this.tracks = n,
                    this.duration = void 0 !== i ? i : -1,
                    this.uuid = e.Math.generateUUID(),
                    this.duration < 0 && this.resetDuration(),
                    this.trim(),
                    this.optimize()
                }
                function gi(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager,
                    this.textures = {}
                }
                function vi(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function _i() {
                    this.onLoadStart = function() {}
                    ,
                    this.onLoadProgress = function() {}
                    ,
                    this.onLoadComplete = function() {}
                }
                function yi(t) {
                    "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),
                    t = void 0),
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager,
                    this.withCredentials = !1
                }
                function xi(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager,
                    this.texturePath = ""
                }
                function bi() {}
                function wi(t, e) {
                    this.v1 = t,
                    this.v2 = e
                }
                function Mi() {
                    this.curves = [],
                    this.autoClose = !1
                }
                function Ti(t, e, i, n, r, a, o, s) {
                    this.aX = t,
                    this.aY = e,
                    this.xRadius = i,
                    this.yRadius = n,
                    this.aStartAngle = r,
                    this.aEndAngle = a,
                    this.aClockwise = o,
                    this.aRotation = s || 0
                }
                function Si(t) {
                    this.points = void 0 === t ? [] : t
                }
                function Ei(t, e, i, n) {
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = i,
                    this.v3 = n
                }
                function Ai(t, e, i) {
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = i
                }
                function Pi(t, e, i, r, a, o) {
                    function s(t, e, i) {
                        return C.vertices.push(new l(t,e,i)) - 1
                    }
                    kt.call(this),
                    this.type = "TubeGeometry",
                    this.parameters = {
                        path: t,
                        segments: e,
                        radius: i,
                        radialSegments: r,
                        closed: a,
                        taper: o
                    },
                    e = e || 64,
                    i = i || 1,
                    r = r || 8,
                    a = a || !1,
                    o = o || Pi.NoTaper;
                    var h, c, u, p, d, f, m, g, v, _, y, x, b, w, M, T, S, E, A, P, R, L = [], C = this, O = e + 1, I = new l, D = new Pi.FrenetFrames(t,e,a), U = D.tangents, F = D.normals, N = D.binormals;
                    for (this.tangents = U,
                    this.normals = F,
                    this.binormals = N,
                    _ = 0; _ < O; _++)
                        for (L[_] = [],
                        p = _ / (O - 1),
                        v = t.getPointAt(p),
                        h = U[_],
                        c = F[_],
                        u = N[_],
                        f = i * o(p),
                        y = 0; y < r; y++)
                            d = y / r * 2 * Math.PI,
                            m = -f * Math.cos(d),
                            g = f * Math.sin(d),
                            I.copy(v),
                            I.x += m * c.x + g * u.x,
                            I.y += m * c.y + g * u.y,
                            I.z += m * c.z + g * u.z,
                            L[_][y] = s(I.x, I.y, I.z);
                    for (_ = 0; _ < e; _++)
                        for (y = 0; y < r; y++)
                            x = a ? (_ + 1) % e : _ + 1,
                            b = (y + 1) % r,
                            w = L[_][y],
                            M = L[x][y],
                            T = L[x][b],
                            S = L[_][b],
                            E = new n(_ / e,y / r),
                            A = new n((_ + 1) / e,y / r),
                            P = new n((_ + 1) / e,(y + 1) / r),
                            R = new n(_ / e,(y + 1) / r),
                            this.faces.push(new Ut(w,M,S)),
                            this.faceVertexUvs[0].push([E, A, R]),
                            this.faces.push(new Ut(M,T,S)),
                            this.faceVertexUvs[0].push([A.clone(), P, R.clone()]);
                    this.computeFaceNormals(),
                    this.computeVertexNormals()
                }
                function Ri(t, e) {
                    return "undefined" == typeof t ? void (t = []) : (kt.call(this),
                    this.type = "ExtrudeGeometry",
                    t = Array.isArray(t) ? t : [t],
                    this.addShapeList(t, e),
                    void this.computeFaceNormals())
                }
                function Li(t, e) {
                    kt.call(this),
                    this.type = "ShapeGeometry",
                    Array.isArray(t) === !1 && (t = [t]),
                    this.addShapeList(t, e),
                    this.computeFaceNormals()
                }
                function Ci() {
                    Oi.apply(this, arguments),
                    this.holes = []
                }
                function Oi(t) {
                    Mi.call(this),
                    this.currentPoint = new n,
                    t && this.fromPoints(t)
                }
                function Ii() {
                    this.subPaths = [],
                    this.currentPath = null
                }
                function Di(t) {
                    this.data = t
                }
                function Ui(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function Fi() {
                    return void 0 === kl && (kl = new (window.AudioContext || window.webkitAudioContext)),
                    kl
                }
                function Ni(t) {
                    this.manager = void 0 !== t ? t : e.DefaultLoadingManager
                }
                function zi() {
                    this.type = "StereoCamera",
                    this.aspect = 1,
                    this.eyeSep = .064,
                    this.cameraL = new se,
                    this.cameraL.layers.enable(1),
                    this.cameraL.matrixAutoUpdate = !1,
                    this.cameraR = new se,
                    this.cameraR.layers.enable(2),
                    this.cameraR.matrixAutoUpdate = !1
                }
                function Bi(t, e, i) {
                    zt.call(this),
                    this.type = "CubeCamera";
                    var n = 90
                      , r = 1
                      , a = new se(n,r,t,e);
                    a.up.set(0, -1, 0),
                    a.lookAt(new l(1,0,0)),
                    this.add(a);
                    var o = new se(n,r,t,e);
                    o.up.set(0, -1, 0),
                    o.lookAt(new l(-1,0,0)),
                    this.add(o);
                    var s = new se(n,r,t,e);
                    s.up.set(0, 0, 1),
                    s.lookAt(new l(0,1,0)),
                    this.add(s);
                    var h = new se(n,r,t,e);
                    h.up.set(0, 0, -1),
                    h.lookAt(new l(0,-1,0)),
                    this.add(h);
                    var c = new se(n,r,t,e);
                    c.up.set(0, -1, 0),
                    c.lookAt(new l(0,0,1)),
                    this.add(c);
                    var u = new se(n,r,t,e);
                    u.up.set(0, -1, 0),
                    u.lookAt(new l(0,0,-1)),
                    this.add(u);
                    var p = {
                        format: Va,
                        magFilter: Ea,
                        minFilter: Ea
                    };
                    this.renderTarget = new Kt(i,i,p),
                    this.updateCubeMap = function(t, e) {
                        null === this.parent && this.updateMatrixWorld();
                        var i = this.renderTarget
                          , n = i.texture.generateMipmaps;
                        i.texture.generateMipmaps = !1,
                        i.activeCubeFace = 0,
                        t.render(e, a, i),
                        i.activeCubeFace = 1,
                        t.render(e, o, i),
                        i.activeCubeFace = 2,
                        t.render(e, s, i),
                        i.activeCubeFace = 3,
                        t.render(e, h, i),
                        i.activeCubeFace = 4,
                        t.render(e, c, i),
                        i.texture.generateMipmaps = n,
                        i.activeCubeFace = 5,
                        t.render(e, u, i),
                        t.setRenderTarget(null)
                    }
                }
                function ki() {
                    zt.call(this),
                    this.type = "AudioListener",
                    this.context = Fi(),
                    this.gain = this.context.createGain(),
                    this.gain.connect(this.context.destination),
                    this.filter = null
                }
                function Gi(t) {
                    zt.call(this),
                    this.type = "Audio",
                    this.context = t.context,
                    this.source = this.context.createBufferSource(),
                    this.source.onended = this.onEnded.bind(this),
                    this.gain = this.context.createGain(),
                    this.gain.connect(t.getInput()),
                    this.autoplay = !1,
                    this.startTime = 0,
                    this.playbackRate = 1,
                    this.isPlaying = !1,
                    this.hasPlaybackControl = !0,
                    this.sourceType = "empty",
                    this.filters = []
                }
                function Vi(t) {
                    Gi.call(this, t),
                    this.panner = this.context.createPanner(),
                    this.panner.connect(this.gain)
                }
                function Hi(t, e) {
                    this.analyser = t.context.createAnalyser(),
                    this.analyser.fftSize = void 0 !== e ? e : 2048,
                    this.data = new Uint8Array(this.analyser.frequencyBinCount),
                    t.getOutput().connect(this.analyser)
                }
                function ji(t, e, i) {
                    this.binding = t,
                    this.valueSize = i;
                    var n, r = Float64Array;
                    switch (e) {
                    case "quaternion":
                        n = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array,
                        n = this._select;
                        break;
                    default:
                        n = this._lerp
                    }
                    this.buffer = new r(4 * i),
                    this._mixBufferRegion = n,
                    this.cumulativeWeight = 0,
                    this.useCount = 0,
                    this.referenceCount = 0
                }
                function Wi(t, e, i) {
                    this.path = e,
                    this.parsedPath = i || Wi.parseTrackName(e),
                    this.node = Wi.findNode(t, this.parsedPath.nodeName) || t,
                    this.rootNode = t
                }
                function Xi(t) {
                    this.uuid = e.Math.generateUUID(),
                    this._objects = Array.prototype.slice.call(arguments),
                    this.nCachedObjects_ = 0;
                    var i = {};
                    this._indicesByUUID = i;
                    for (var n = 0, r = arguments.length; n !== r; ++n)
                        i[arguments[n].uuid] = n;
                    this._paths = [],
                    this._parsedPaths = [],
                    this._bindings = [],
                    this._bindingsIndicesByPath = {};
                    var a = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return a._objects.length
                            },
                            get inUse() {
                                return this.total - a.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return a._bindings.length
                        }
                    }
                }
                function Yi(t, e, i) {
                    this._mixer = t,
                    this._clip = e,
                    this._localRoot = i || null;
                    for (var n = e.tracks, r = n.length, a = new Array(r), o = {
                        endingStart: co,
                        endingEnd: co
                    }, s = 0; s !== r; ++s) {
                        var l = n[s].createInterpolant(null);
                        a[s] = l,
                        l.settings = o
                    }
                    this._interpolantSettings = o,
                    this._interpolants = a,
                    this._propertyBindings = new Array(r),
                    this._cacheIndex = null,
                    this._byClipCacheIndex = null,
                    this._timeScaleInterpolant = null,
                    this._weightInterpolant = null,
                    this.loop = ao,
                    this._loopCount = -1,
                    this._startTime = null,
                    this.time = 0,
                    this.timeScale = 1,
                    this._effectiveTimeScale = 1,
                    this.weight = 1,
                    this._effectiveWeight = 1,
                    this.repetitions = 1 / 0,
                    this.paused = !1,
                    this.enabled = !0,
                    this.clampWhenFinished = !1,
                    this.zeroSlopeAtStart = !0,
                    this.zeroSlopeAtEnd = !0
                }
                function qi(t) {
                    this._root = t,
                    this._initMemoryManager(),
                    this._accuIndex = 0,
                    this.time = 0,
                    this.timeScale = 1
                }
                function Zi(t) {
                    "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
                    t = arguments[1]),
                    this.value = t,
                    this.dynamic = !1
                }
                function Qi() {
                    Ht.call(this),
                    this.type = "InstancedBufferGeometry",
                    this.maxInstancedCount = void 0
                }
                function Ji(t, i, n, r) {
                    this.uuid = e.Math.generateUUID(),
                    this.data = t,
                    this.itemSize = i,
                    this.offset = n,
                    this.normalized = r === !0
                }
                function Ki(t, i) {
                    this.uuid = e.Math.generateUUID(),
                    this.array = t,
                    this.stride = i,
                    this.dynamic = !1,
                    this.updateRange = {
                        offset: 0,
                        count: -1
                    },
                    this.version = 0
                }
                function $i(t, e, i) {
                    Ki.call(this, t, e),
                    this.meshPerAttribute = i || 1
                }
                function tn(t, e, i) {
                    Tt.call(this, t, e),
                    this.meshPerAttribute = i || 1
                }
                function en(t, e, i, n) {
                    this.ray = new te(t,e),
                    this.near = i || 0,
                    this.far = n || 1 / 0,
                    this.params = {
                        Mesh: {},
                        Line: {},
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    },
                    Object.defineProperties(this.params, {
                        PointCloud: {
                            get: function() {
                                return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                                this.Points
                            }
                        }
                    })
                }
                function nn(t, e) {
                    return t.distance - e.distance
                }
                function rn(t, e, i, n) {
                    if (t.visible !== !1 && (t.raycast(e, i),
                    n === !0))
                        for (var r = t.children, a = 0, o = r.length; a < o; a++)
                            rn(r[a], e, i, !0)
                }
                function an(t) {
                    this.autoStart = void 0 === t || t,
                    this.startTime = 0,
                    this.oldTime = 0,
                    this.elapsedTime = 0,
                    this.running = !1
                }
                function on(t) {
                    function e(t, e, i, n, r, a, o) {
                        var s = .5 * (i - t)
                          , l = .5 * (n - e);
                        return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
                    }
                    this.points = t;
                    var i, n, r, a, o, s, h, c, u, p = [], d = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                    this.initFromArray = function(t) {
                        this.points = [];
                        for (var e = 0; e < t.length; e++)
                            this.points[e] = {
                                x: t[e][0],
                                y: t[e][1],
                                z: t[e][2]
                            }
                    }
                    ,
                    this.getPoint = function(t) {
                        return i = (this.points.length - 1) * t,
                        n = Math.floor(i),
                        r = i - n,
                        p[0] = 0 === n ? n : n - 1,
                        p[1] = n,
                        p[2] = n > this.points.length - 2 ? this.points.length - 1 : n + 1,
                        p[3] = n > this.points.length - 3 ? this.points.length - 1 : n + 2,
                        s = this.points[p[0]],
                        h = this.points[p[1]],
                        c = this.points[p[2]],
                        u = this.points[p[3]],
                        a = r * r,
                        o = r * a,
                        d.x = e(s.x, h.x, c.x, u.x, r, a, o),
                        d.y = e(s.y, h.y, c.y, u.y, r, a, o),
                        d.z = e(s.z, h.z, c.z, u.z, r, a, o),
                        d
                    }
                    ,
                    this.getControlPointsArray = function() {
                        var t, e, i = this.points.length, n = [];
                        for (t = 0; t < i; t++)
                            e = this.points[t],
                            n[t] = [e.x, e.y, e.z];
                        return n
                    }
                    ,
                    this.getLength = function(t) {
                        var e, i, n, r, a = 0, o = 0, s = 0, h = new l, c = new l, u = [], p = 0;
                        for (u[0] = 0,
                        t || (t = 100),
                        n = this.points.length * t,
                        h.copy(this.points[0]),
                        e = 1; e < n; e++)
                            i = e / n,
                            r = this.getPoint(i),
                            c.copy(r),
                            p += c.distanceTo(h),
                            h.copy(r),
                            a = (this.points.length - 1) * i,
                            o = Math.floor(a),
                            o !== s && (u[o] = p,
                            s = o);
                        return u[u.length] = p,
                        {
                            chunks: u,
                            total: p
                        }
                    }
                    ,
                    this.reparametrizeByArcLength = function(t) {
                        var e, i, n, r, a, o, s, h, c = [], u = new l, p = this.getLength();
                        for (c.push(u.copy(this.points[0]).clone()),
                        e = 1; e < this.points.length; e++) {
                            for (o = p.chunks[e] - p.chunks[e - 1],
                            s = Math.ceil(t * o / p.total),
                            r = (e - 1) / (this.points.length - 1),
                            a = e / (this.points.length - 1),
                            i = 1; i < s - 1; i++)
                                n = r + i * (1 / s) * (a - r),
                                h = this.getPoint(n),
                                c.push(u.copy(h).clone());
                            c.push(u.copy(this.points[e]).clone())
                        }
                        this.points = c
                    }
                }
                function sn(t, e, i) {
                    return this.radius = void 0 !== t ? t : 1,
                    this.phi = void 0 !== e ? e : 0,
                    this.theta = void 0 !== i ? i : 0,
                    this
                }
                function ln(t, e) {
                    re.call(this, t, e),
                    this.animationsMap = {},
                    this.animationsList = [];
                    var i = this.geometry.morphTargets.length
                      , n = "__default"
                      , r = 0
                      , a = i - 1
                      , o = i / 1;
                    this.createAnimation(n, r, a, o),
                    this.setAnimationWeight(n, 1)
                }
                function hn(t) {
                    zt.call(this),
                    this.material = t,
                    this.render = function(t) {}
                }
                function cn(t) {
                    function e(t, e) {
                        return t - e
                    }
                    Ht.call(this);
                    var i = [0, 0]
                      , n = {}
                      , r = ["a", "b", "c"];
                    if (t && t.isGeometry) {
                        for (var a = t.vertices, o = t.faces, s = 0, l = new Uint32Array(6 * o.length), h = 0, c = o.length; h < c; h++)
                            for (var u = o[h], p = 0; p < 3; p++) {
                                i[0] = u[r[p]],
                                i[1] = u[r[(p + 1) % 3]],
                                i.sort(e);
                                var d = i.toString();
                                void 0 === n[d] && (l[2 * s] = i[0],
                                l[2 * s + 1] = i[1],
                                n[d] = !0,
                                s++)
                            }
                        for (var f = new Float32Array(2 * s * 3), h = 0, c = s; h < c; h++)
                            for (var p = 0; p < 2; p++) {
                                var m = a[l[2 * h + p]]
                                  , g = 6 * h + 3 * p;
                                f[g + 0] = m.x,
                                f[g + 1] = m.y,
                                f[g + 2] = m.z
                            }
                        this.addAttribute("position", new Tt(f,3))
                    } else if (t && t.isBufferGeometry)
                        if (null !== t.index) {
                            var v = t.index.array
                              , a = t.attributes.position
                              , _ = t.groups
                              , s = 0;
                            0 === _.length && t.addGroup(0, v.length);
                            for (var l = new Uint32Array(2 * v.length), y = 0, x = _.length; y < x; ++y)
                                for (var b = _[y], w = b.start, M = b.count, h = w, T = w + M; h < T; h += 3)
                                    for (var p = 0; p < 3; p++) {
                                        i[0] = v[h + p],
                                        i[1] = v[h + (p + 1) % 3],
                                        i.sort(e);
                                        var d = i.toString();
                                        void 0 === n[d] && (l[2 * s] = i[0],
                                        l[2 * s + 1] = i[1],
                                        n[d] = !0,
                                        s++)
                                    }
                            for (var f = new Float32Array(2 * s * 3), h = 0, c = s; h < c; h++)
                                for (var p = 0; p < 2; p++) {
                                    var g = 6 * h + 3 * p
                                      , S = l[2 * h + p];
                                    f[g + 0] = a.getX(S),
                                    f[g + 1] = a.getY(S),
                                    f[g + 2] = a.getZ(S)
                                }
                            this.addAttribute("position", new Tt(f,3))
                        } else {
                            for (var a = t.attributes.position.array, s = a.length / 3, E = s / 3, f = new Float32Array(2 * s * 3), h = 0, c = E; h < c; h++)
                                for (var p = 0; p < 3; p++) {
                                    var g = 18 * h + 6 * p
                                      , A = 9 * h + 3 * p;
                                    f[g + 0] = a[A],
                                    f[g + 1] = a[A + 1],
                                    f[g + 2] = a[A + 2];
                                    var S = 9 * h + 3 * ((p + 1) % 3);
                                    f[g + 3] = a[S],
                                    f[g + 4] = a[S + 1],
                                    f[g + 5] = a[S + 2]
                                }
                            this.addAttribute("position", new Tt(f,3))
                        }
                }
                function un(t, e) {
                    var i = void 0 !== e ? e : 16777215;
                    Me.call(this, new cn(t.geometry), new be({
                        color: i
                    })),
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1
                }
                function pn(t, e, i, n) {
                    this.object = t,
                    this.size = void 0 !== e ? e : 1;
                    var r = void 0 !== i ? i : 16711680
                      , a = void 0 !== n ? n : 1
                      , o = 0
                      , s = this.object.geometry;
                    s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
                    var l = new Ht
                      , h = new Ot(2 * o * 3,3);
                    l.addAttribute("position", h),
                    Me.call(this, l, new be({
                        color: r,
                        linewidth: a
                    })),
                    this.matrixAutoUpdate = !1,
                    this.update()
                }
                function dn(t) {
                    zt.call(this),
                    this.light = t,
                    this.light.updateMatrixWorld(),
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1;
                    for (var e = new Ht, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], n = 0, r = 1, a = 32; n < a; n++,
                    r++) {
                        var o = n / a * Math.PI * 2
                          , s = r / a * Math.PI * 2;
                        i.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
                    }
                    e.addAttribute("position", new Ot(i,3));
                    var l = new be({
                        fog: !1
                    });
                    this.cone = new Me(e,l),
                    this.add(this.cone),
                    this.update()
                }
                function fn(t) {
                    this.bones = this.getBoneList(t);
                    for (var e = new kt, i = 0; i < this.bones.length; i++) {
                        var n = this.bones[i];
                        n.parent && n.parent.isBone && (e.vertices.push(new l),
                        e.vertices.push(new l),
                        e.colors.push(new tt(0,0,1)),
                        e.colors.push(new tt(0,1,0)))
                    }
                    e.dynamic = !0;
                    var r = new be({
                        vertexColors: Ar,
                        depthTest: !1,
                        depthWrite: !1,
                        transparent: !0
                    });
                    Me.call(this, e, r),
                    this.root = t,
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1,
                    this.update()
                }
                function mn(t, e, i, n, r, a, o) {
                    Ht.call(this),
                    this.type = "SphereBufferGeometry",
                    this.parameters = {
                        radius: t,
                        widthSegments: e,
                        heightSegments: i,
                        phiStart: n,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: o
                    },
                    t = t || 50,
                    e = Math.max(3, Math.floor(e) || 8),
                    i = Math.max(2, Math.floor(i) || 6),
                    n = void 0 !== n ? n : 0,
                    r = void 0 !== r ? r : 2 * Math.PI,
                    a = void 0 !== a ? a : 0,
                    o = void 0 !== o ? o : Math.PI;
                    for (var s = a + o, h = (e + 1) * (i + 1), c = new Tt(new Float32Array(3 * h),3), u = new Tt(new Float32Array(3 * h),3), p = new Tt(new Float32Array(2 * h),2), d = 0, f = [], m = new l, g = 0; g <= i; g++) {
                        for (var v = [], _ = g / i, y = 0; y <= e; y++) {
                            var x = y / e
                              , b = -t * Math.cos(n + x * r) * Math.sin(a + _ * o)
                              , w = t * Math.cos(a + _ * o)
                              , M = t * Math.sin(n + x * r) * Math.sin(a + _ * o);
                            m.set(b, w, M).normalize(),
                            c.setXYZ(d, b, w, M),
                            u.setXYZ(d, m.x, m.y, m.z),
                            p.setXY(d, x, 1 - _),
                            v.push(d),
                            d++
                        }
                        f.push(v)
                    }
                    for (var T = [], g = 0; g < i; g++)
                        for (var y = 0; y < e; y++) {
                            var S = f[g][y + 1]
                              , E = f[g][y]
                              , A = f[g + 1][y]
                              , P = f[g + 1][y + 1];
                            (0 !== g || a > 0) && T.push(S, E, P),
                            (g !== i - 1 || s < Math.PI) && T.push(E, A, P)
                        }
                    this.setIndex(new (c.count > 65535 ? Ct : Rt)(T,1)),
                    this.addAttribute("position", c),
                    this.addAttribute("normal", u),
                    this.addAttribute("uv", p),
                    this.boundingSphere = new nt(new l,t)
                }
                function gn(t, e) {
                    this.light = t,
                    this.light.updateMatrixWorld();
                    var i = new mn(e,4,2)
                      , n = new ne({
                        wireframe: !0,
                        fog: !1
                    });
                    n.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                    re.call(this, i, n),
                    this.matrix = this.light.matrixWorld,
                    this.matrixAutoUpdate = !1
                }
                function vn(t, e, i, n, r, a, o) {
                    kt.call(this),
                    this.type = "SphereGeometry",
                    this.parameters = {
                        radius: t,
                        widthSegments: e,
                        heightSegments: i,
                        phiStart: n,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: o
                    },
                    this.fromBufferGeometry(new mn(t,e,i,n,r,a,o))
                }
                function _n(t, e) {
                    zt.call(this),
                    this.light = t,
                    this.light.updateMatrixWorld(),
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1,
                    this.colors = [new tt, new tt];
                    var i = new vn(e,4,2);
                    i.rotateX(-Math.PI / 2);
                    for (var n = 0, r = 8; n < r; n++)
                        i.faces[n].color = this.colors[n < 4 ? 0 : 1];
                    var a = new ne({
                        vertexColors: Er,
                        wireframe: !0
                    });
                    this.lightSphere = new re(i,a),
                    this.add(this.lightSphere),
                    this.update()
                }
                function yn(t, e, i, n) {
                    e = e || 1,
                    i = new tt(void 0 !== i ? i : 4473924),
                    n = new tt(void 0 !== n ? n : 8947848);
                    for (var r = e / 2, a = 2 * t / e, o = [], s = [], l = 0, h = 0, c = -t; l <= e; l++,
                    c += a) {
                        o.push(-t, 0, c, t, 0, c),
                        o.push(c, 0, -t, c, 0, t);
                        var u = l === r ? i : n;
                        u.toArray(s, h),
                        h += 3,
                        u.toArray(s, h),
                        h += 3,
                        u.toArray(s, h),
                        h += 3,
                        u.toArray(s, h),
                        h += 3
                    }
                    var p = new Ht;
                    p.addAttribute("position", new Ot(o,3)),
                    p.addAttribute("color", new Ot(s,3));
                    var d = new be({
                        vertexColors: Ar
                    });
                    Me.call(this, p, d)
                }
                function xn(t, e, i, n) {
                    this.object = t,
                    this.size = void 0 !== e ? e : 1;
                    var r = void 0 !== i ? i : 16776960
                      , a = void 0 !== n ? n : 1
                      , o = 0
                      , s = this.object.geometry;
                    s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                    var l = new Ht
                      , h = new Ot(2 * o * 3,3);
                    l.addAttribute("position", h),
                    Me.call(this, l, new be({
                        color: r,
                        linewidth: a
                    })),
                    this.matrixAutoUpdate = !1,
                    this.update()
                }
                function bn(t, i) {
                    function n(t, e) {
                        return t - e
                    }
                    Ht.call(this),
                    i = void 0 !== i ? i : 1;
                    var r, a = Math.cos(e.Math.DEG2RAD * i), o = [0, 0], s = {}, l = ["a", "b", "c"];
                    t && t.isBufferGeometry ? (r = new kt,
                    r.fromBufferGeometry(t)) : r = t.clone(),
                    r.mergeVertices(),
                    r.computeFaceNormals();
                    for (var h = r.vertices, c = r.faces, u = 0, p = c.length; u < p; u++)
                        for (var d = c[u], f = 0; f < 3; f++) {
                            o[0] = d[l[f]],
                            o[1] = d[l[(f + 1) % 3]],
                            o.sort(n);
                            var m = o.toString();
                            void 0 === s[m] ? s[m] = {
                                vert1: o[0],
                                vert2: o[1],
                                face1: u,
                                face2: void 0
                            } : s[m].face2 = u
                        }
                    var g = [];
                    for (var m in s) {
                        var v = s[m];
                        if (void 0 === v.face2 || c[v.face1].normal.dot(c[v.face2].normal) <= a) {
                            var _ = h[v.vert1];
                            g.push(_.x),
                            g.push(_.y),
                            g.push(_.z),
                            _ = h[v.vert2],
                            g.push(_.x),
                            g.push(_.y),
                            g.push(_.z)
                        }
                    }
                    this.addAttribute("position", new Tt(new Float32Array(g),3))
                }
                function wn(t, e, i) {
                    var n = void 0 !== e ? e : 16777215;
                    Me.call(this, new bn(t.geometry,i), new be({
                        color: n
                    })),
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1
                }
                function Mn(t, e) {
                    zt.call(this),
                    this.light = t,
                    this.light.updateMatrixWorld(),
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1,
                    void 0 === e && (e = 1);
                    var i = new Ht;
                    i.addAttribute("position", new Ot([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0],3));
                    var n = new be({
                        fog: !1
                    });
                    this.add(new we(i,n)),
                    i = new Ht,
                    i.addAttribute("position", new Ot([0, 0, 0, 0, 0, 1],3)),
                    this.add(new we(i,n)),
                    this.update()
                }
                function Tn(t) {
                    function e(t, e, n) {
                        i(t, n),
                        i(e, n)
                    }
                    function i(t, e) {
                        n.vertices.push(new l),
                        n.colors.push(new tt(e)),
                        void 0 === a[t] && (a[t] = []),
                        a[t].push(n.vertices.length - 1)
                    }
                    var n = new kt
                      , r = new be({
                        color: 16777215,
                        vertexColors: Er
                    })
                      , a = {}
                      , o = 16755200
                      , s = 16711680
                      , h = 43775
                      , c = 16777215
                      , u = 3355443;
                    e("n1", "n2", o),
                    e("n2", "n4", o),
                    e("n4", "n3", o),
                    e("n3", "n1", o),
                    e("f1", "f2", o),
                    e("f2", "f4", o),
                    e("f4", "f3", o),
                    e("f3", "f1", o),
                    e("n1", "f1", o),
                    e("n2", "f2", o),
                    e("n3", "f3", o),
                    e("n4", "f4", o),
                    e("p", "n1", s),
                    e("p", "n2", s),
                    e("p", "n3", s),
                    e("p", "n4", s),
                    e("u1", "u2", h),
                    e("u2", "u3", h),
                    e("u3", "u1", h),
                    e("c", "t", c),
                    e("p", "c", u),
                    e("cn1", "cn2", u),
                    e("cn3", "cn4", u),
                    e("cf1", "cf2", u),
                    e("cf3", "cf4", u),
                    Me.call(this, n, r),
                    this.camera = t,
                    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                    this.matrix = t.matrixWorld,
                    this.matrixAutoUpdate = !1,
                    this.pointMap = a,
                    this.update()
                }
                function Sn(t, e, i, n, r, a) {
                    kt.call(this),
                    this.type = "BoxGeometry",
                    this.parameters = {
                        width: t,
                        height: e,
                        depth: i,
                        widthSegments: n,
                        heightSegments: r,
                        depthSegments: a
                    },
                    this.fromBufferGeometry(new $t(t,e,i,n,r,a)),
                    this.mergeVertices()
                }
                function En(t, e) {
                    var i = void 0 !== e ? e : 8947848;
                    this.object = t,
                    this.box = new it,
                    re.call(this, new Sn(1,1,1), new ne({
                        color: i,
                        wireframe: !0
                    }))
                }
                function An(t, e) {
                    void 0 === e && (e = 16776960);
                    var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                      , n = new Float32Array(24)
                      , r = new Ht;
                    r.setIndex(new Tt(i,1)),
                    r.addAttribute("position", new Tt(n,3)),
                    Me.call(this, r, new be({
                        color: e
                    })),
                    void 0 !== t && this.update(t)
                }
                function Pn(t, e, i, r, a, o, s, h) {
                    function c() {
                        var t = (r + 1) * (a + 1);
                        return o === !1 && (t += (r + 1) * m + r * m),
                        t
                    }
                    function u() {
                        var t = r * a * 2 * 3;
                        return o === !1 && (t += r * m * 3),
                        t
                    }
                    function p() {
                        var n, o, c = new l, u = new l, p = 0, d = (e - t) / i;
                        for (o = 0; o <= a; o++) {
                            var m = []
                              , g = o / a
                              , v = g * (e - t) + t;
                            for (n = 0; n <= r; n++) {
                                var A = n / r;
                                u.x = v * Math.sin(A * h + s),
                                u.y = -g * i + S,
                                u.z = v * Math.cos(A * h + s),
                                y.setXYZ(w, u.x, u.y, u.z),
                                c.copy(u),
                                (0 === t && 0 === o || 0 === e && o === a) && (c.x = Math.sin(A * h + s),
                                c.z = Math.cos(A * h + s)),
                                c.setY(Math.sqrt(c.x * c.x + c.z * c.z) * d).normalize(),
                                x.setXYZ(w, c.x, c.y, c.z),
                                b.setXY(w, A, 1 - g),
                                m.push(w),
                                w++
                            }
                            T.push(m)
                        }
                        for (n = 0; n < r; n++)
                            for (o = 0; o < a; o++) {
                                var P = T[o][n]
                                  , R = T[o + 1][n]
                                  , L = T[o + 1][n + 1]
                                  , C = T[o][n + 1];
                                _.setX(M, P),
                                M++,
                                _.setX(M, R),
                                M++,
                                _.setX(M, C),
                                M++,
                                _.setX(M, R),
                                M++,
                                _.setX(M, L),
                                M++,
                                _.setX(M, C),
                                M++,
                                p += 6
                            }
                        f.addGroup(E, p, 0),
                        E += p
                    }
                    function d(i) {
                        var a, o, c, u = new n, p = new l, d = 0, m = i === !0 ? t : e, g = i === !0 ? 1 : -1;
                        for (o = w,
                        a = 1; a <= r; a++)
                            y.setXYZ(w, 0, S * g, 0),
                            x.setXYZ(w, 0, g, 0),
                            u.x = .5,
                            u.y = .5,
                            b.setXY(w, u.x, u.y),
                            w++;
                        for (c = w,
                        a = 0; a <= r; a++) {
                            var v = a / r
                              , T = v * h + s
                              , A = Math.cos(T)
                              , P = Math.sin(T);
                            p.x = m * P,
                            p.y = S * g,
                            p.z = m * A,
                            y.setXYZ(w, p.x, p.y, p.z),
                            x.setXYZ(w, 0, g, 0),
                            u.x = .5 * A + .5,
                            u.y = .5 * P * g + .5,
                            b.setXY(w, u.x, u.y),
                            w++
                        }
                        for (a = 0; a < r; a++) {
                            var R = o + a
                              , L = c + a;
                            i === !0 ? (_.setX(M, L),
                            M++,
                            _.setX(M, L + 1),
                            M++,
                            _.setX(M, R),
                            M++) : (_.setX(M, L + 1),
                            M++,
                            _.setX(M, L),
                            M++,
                            _.setX(M, R),
                            M++),
                            d += 3
                        }
                        f.addGroup(E, d, i === !0 ? 1 : 2),
                        E += d
                    }
                    Ht.call(this),
                    this.type = "CylinderBufferGeometry",
                    this.parameters = {
                        radiusTop: t,
                        radiusBottom: e,
                        height: i,
                        radialSegments: r,
                        heightSegments: a,
                        openEnded: o,
                        thetaStart: s,
                        thetaLength: h
                    };
                    var f = this;
                    t = void 0 !== t ? t : 20,
                    e = void 0 !== e ? e : 20,
                    i = void 0 !== i ? i : 100,
                    r = Math.floor(r) || 8,
                    a = Math.floor(a) || 1,
                    o = void 0 !== o && o,
                    s = void 0 !== s ? s : 0,
                    h = void 0 !== h ? h : 2 * Math.PI;
                    var m = 0;
                    o === !1 && (t > 0 && m++,
                    e > 0 && m++);
                    var g = c()
                      , v = u()
                      , _ = new Tt(new (v > 65535 ? Uint32Array : Uint16Array)(v),1)
                      , y = new Tt(new Float32Array(3 * g),3)
                      , x = new Tt(new Float32Array(3 * g),3)
                      , b = new Tt(new Float32Array(2 * g),2)
                      , w = 0
                      , M = 0
                      , T = []
                      , S = i / 2
                      , E = 0;
                    p(),
                    o === !1 && (t > 0 && d(!0),
                    e > 0 && d(!1)),
                    this.setIndex(_),
                    this.addAttribute("position", y),
                    this.addAttribute("normal", x),
                    this.addAttribute("uv", b)
                }
                function Rn(t, e, i, n, r, a) {
                    zt.call(this),
                    void 0 === n && (n = 16776960),
                    void 0 === i && (i = 1),
                    void 0 === r && (r = .2 * i),
                    void 0 === a && (a = .2 * r),
                    this.position.copy(e),
                    this.line = new we(Gl,new be({
                        color: n
                    })),
                    this.line.matrixAutoUpdate = !1,
                    this.add(this.line),
                    this.cone = new re(Vl,new ne({
                        color: n
                    })),
                    this.cone.matrixAutoUpdate = !1,
                    this.add(this.cone),
                    this.setDirection(t),
                    this.setLength(i, r, a)
                }
                function Ln(t) {
                    t = t || 1;
                    var e = new Float32Array([0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t])
                      , i = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1])
                      , n = new Ht;
                    n.addAttribute("position", new Tt(e,3)),
                    n.addAttribute("color", new Tt(i,3));
                    var r = new be({
                        vertexColors: Ar
                    });
                    Me.call(this, n, r)
                }
                function Cn(t, e, i) {
                    kt.call(this),
                    this.type = "ParametricGeometry",
                    this.parameters = {
                        func: t,
                        slices: e,
                        stacks: i
                    };
                    var r, a, o, s, l, h = this.vertices, c = this.faces, u = this.faceVertexUvs[0], p = e + 1;
                    for (r = 0; r <= i; r++)
                        for (l = r / i,
                        a = 0; a <= e; a++)
                            s = a / e,
                            o = t(s, l),
                            h.push(o);
                    var d, f, m, g, v, _, y, x;
                    for (r = 0; r < i; r++)
                        for (a = 0; a < e; a++)
                            d = r * p + a,
                            f = r * p + a + 1,
                            m = (r + 1) * p + a + 1,
                            g = (r + 1) * p + a,
                            v = new n(a / e,r / i),
                            _ = new n((a + 1) / e,r / i),
                            y = new n((a + 1) / e,(r + 1) / i),
                            x = new n(a / e,(r + 1) / i),
                            c.push(new Ut(d,f,g)),
                            u.push([v, _, x]),
                            c.push(new Ut(f,m,g)),
                            u.push([_.clone(), y, x.clone()]);
                    this.computeFaceNormals(),
                    this.computeVertexNormals()
                }
                function On(t, e, i, r) {
                    function a(t) {
                        var e = t.normalize().clone();
                        e.index = p.vertices.push(e) - 1;
                        var i = h(t) / 2 / Math.PI + .5
                          , r = c(t) / Math.PI + .5;
                        return e.uv = new n(i,1 - r),
                        e
                    }
                    function o(t, e, i) {
                        var n = new Ut(t.index,e.index,i.index,[t.clone(), e.clone(), i.clone()]);
                        p.faces.push(n),
                        b.copy(t).add(e).add(i).divideScalar(3);
                        var r = h(b);
                        p.faceVertexUvs[0].push([u(t.uv, t, r), u(e.uv, e, r), u(i.uv, i, r)])
                    }
                    function s(t, e) {
                        for (var i = Math.pow(2, e), n = a(p.vertices[t.a]), r = a(p.vertices[t.b]), s = a(p.vertices[t.c]), l = [], h = 0; h <= i; h++) {
                            l[h] = [];
                            for (var c = a(n.clone().lerp(s, h / i)), u = a(r.clone().lerp(s, h / i)), d = i - h, f = 0; f <= d; f++)
                                0 === f && h === i ? l[h][f] = c : l[h][f] = a(c.clone().lerp(u, f / d))
                        }
                        for (var h = 0; h < i; h++)
                            for (var f = 0; f < 2 * (i - h) - 1; f++) {
                                var m = Math.floor(f / 2);
                                f % 2 === 0 ? o(l[h][m + 1], l[h + 1][m], l[h][m]) : o(l[h][m + 1], l[h + 1][m + 1], l[h + 1][m])
                            }
                    }
                    function h(t) {
                        return Math.atan2(t.z, -t.x)
                    }
                    function c(t) {
                        return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                    }
                    function u(t, e, i) {
                        return i < 0 && 1 === t.x && (t = new n(t.x - 1,t.y)),
                        0 === e.x && 0 === e.z && (t = new n(i / 2 / Math.PI + .5,t.y)),
                        t.clone()
                    }
                    kt.call(this),
                    this.type = "PolyhedronGeometry",
                    this.parameters = {
                        vertices: t,
                        indices: e,
                        radius: i,
                        detail: r
                    },
                    i = i || 1,
                    r = r || 0;
                    for (var p = this, d = 0, f = t.length; d < f; d += 3)
                        a(new l(t[d],t[d + 1],t[d + 2]));
                    for (var m = this.vertices, g = [], d = 0, v = 0, f = e.length; d < f; d += 3,
                    v++) {
                        var _ = m[e[d]]
                          , y = m[e[d + 1]]
                          , x = m[e[d + 2]];
                        g[v] = new Ut(_.index,y.index,x.index,[_.clone(), y.clone(), x.clone()])
                    }
                    for (var b = new l, d = 0, f = g.length; d < f; d++)
                        s(g[d], r);
                    for (var d = 0, f = this.faceVertexUvs[0].length; d < f; d++) {
                        var w = this.faceVertexUvs[0][d]
                          , M = w[0].x
                          , T = w[1].x
                          , S = w[2].x
                          , E = Math.max(M, T, S)
                          , A = Math.min(M, T, S);
                        E > .9 && A < .1 && (M < .2 && (w[0].x += 1),
                        T < .2 && (w[1].x += 1),
                        S < .2 && (w[2].x += 1))
                    }
                    for (var d = 0, f = this.vertices.length; d < f; d++)
                        this.vertices[d].multiplyScalar(i);
                    this.mergeVertices(),
                    this.computeFaceNormals(),
                    this.boundingSphere = new nt(new l,i)
                }
                function In(t, e) {
                    var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
                      , n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                    On.call(this, i, n, t, e),
                    this.type = "TetrahedronGeometry",
                    this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                function Dn(t, e) {
                    var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
                      , n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                    On.call(this, i, n, t, e),
                    this.type = "OctahedronGeometry",
                    this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                function Un(t, e) {
                    var i = (1 + Math.sqrt(5)) / 2
                      , n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
                      , r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                    On.call(this, n, r, t, e),
                    this.type = "IcosahedronGeometry",
                    this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                function Fn(t, e) {
                    var i = (1 + Math.sqrt(5)) / 2
                      , n = 1 / i
                      , r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n]
                      , a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                    On.call(this, r, a, t, e),
                    this.type = "DodecahedronGeometry",
                    this.parameters = {
                        radius: t,
                        detail: e
                    }
                }
                function Nn(t, e, i, r, a, o) {
                    function s(t, e, i, n, r) {
                        var a = Math.cos(t)
                          , o = Math.sin(t)
                          , s = i / e * t
                          , l = Math.cos(s);
                        r.x = n * (2 + l) * .5 * a,
                        r.y = n * (2 + l) * o * .5,
                        r.z = n * Math.sin(s) * .5
                    }
                    Ht.call(this),
                    this.type = "TorusKnotBufferGeometry",
                    this.parameters = {
                        radius: t,
                        tube: e,
                        tubularSegments: i,
                        radialSegments: r,
                        p: a,
                        q: o
                    },
                    t = t || 100,
                    e = e || 40,
                    i = Math.floor(i) || 64,
                    r = Math.floor(r) || 8,
                    a = a || 2,
                    o = o || 3;
                    var h, c, u = (r + 1) * (i + 1), p = r * i * 2 * 3, d = new Tt(new (p > 65535 ? Uint32Array : Uint16Array)(p),1), f = new Tt(new Float32Array(3 * u),3), m = new Tt(new Float32Array(3 * u),3), g = new Tt(new Float32Array(2 * u),2), v = 0, _ = 0, y = new l, x = new l, b = new n, w = new l, M = new l, T = new l, S = new l, E = new l;
                    for (h = 0; h <= i; ++h) {
                        var A = h / i * a * Math.PI * 2;
                        for (s(A, a, o, t, w),
                        s(A + .01, a, o, t, M),
                        S.subVectors(M, w),
                        E.addVectors(M, w),
                        T.crossVectors(S, E),
                        E.crossVectors(T, S),
                        T.normalize(),
                        E.normalize(),
                        c = 0; c <= r; ++c) {
                            var P = c / r * Math.PI * 2
                              , R = -e * Math.cos(P)
                              , L = e * Math.sin(P);
                            y.x = w.x + (R * E.x + L * T.x),
                            y.y = w.y + (R * E.y + L * T.y),
                            y.z = w.z + (R * E.z + L * T.z),
                            f.setXYZ(v, y.x, y.y, y.z),
                            x.subVectors(y, w).normalize(),
                            m.setXYZ(v, x.x, x.y, x.z),
                            b.x = h / i,
                            b.y = c / r,
                            g.setXY(v, b.x, b.y),
                            v++
                        }
                    }
                    for (c = 1; c <= i; c++)
                        for (h = 1; h <= r; h++) {
                            var C = (r + 1) * (c - 1) + (h - 1)
                              , O = (r + 1) * c + (h - 1)
                              , I = (r + 1) * c + h
                              , D = (r + 1) * (c - 1) + h;
                            d.setX(_, C),
                            _++,
                            d.setX(_, O),
                            _++,
                            d.setX(_, D),
                            _++,
                            d.setX(_, O),
                            _++,
                            d.setX(_, I),
                            _++,
                            d.setX(_, D),
                            _++
                        }
                    this.setIndex(d),
                    this.addAttribute("position", f),
                    this.addAttribute("normal", m),
                    this.addAttribute("uv", g)
                }
                function zn(t, e, i, n, r, a, o) {
                    kt.call(this),
                    this.type = "TorusKnotGeometry",
                    this.parameters = {
                        radius: t,
                        tube: e,
                        tubularSegments: i,
                        radialSegments: n,
                        p: r,
                        q: a
                    },
                    void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
                    this.fromBufferGeometry(new Nn(t,e,i,n,r,a)),
                    this.mergeVertices()
                }
                function Bn(t, e, i, n, r) {
                    Ht.call(this),
                    this.type = "TorusBufferGeometry",
                    this.parameters = {
                        radius: t,
                        tube: e,
                        radialSegments: i,
                        tubularSegments: n,
                        arc: r
                    },
                    t = t || 100,
                    e = e || 40,
                    i = Math.floor(i) || 8,
                    n = Math.floor(n) || 6,
                    r = r || 2 * Math.PI;
                    var a, o, s = (i + 1) * (n + 1), h = i * n * 2 * 3, c = new (h > 65535 ? Uint32Array : Uint16Array)(h), u = new Float32Array(3 * s), p = new Float32Array(3 * s), d = new Float32Array(2 * s), f = 0, m = 0, g = 0, v = new l, _ = new l, y = new l;
                    for (a = 0; a <= i; a++)
                        for (o = 0; o <= n; o++) {
                            var x = o / n * r
                              , b = a / i * Math.PI * 2;
                            _.x = (t + e * Math.cos(b)) * Math.cos(x),
                            _.y = (t + e * Math.cos(b)) * Math.sin(x),
                            _.z = e * Math.sin(b),
                            u[f] = _.x,
                            u[f + 1] = _.y,
                            u[f + 2] = _.z,
                            v.x = t * Math.cos(x),
                            v.y = t * Math.sin(x),
                            y.subVectors(_, v).normalize(),
                            p[f] = y.x,
                            p[f + 1] = y.y,
                            p[f + 2] = y.z,
                            d[m] = o / n,
                            d[m + 1] = a / i,
                            f += 3,
                            m += 2
                        }
                    for (a = 1; a <= i; a++)
                        for (o = 1; o <= n; o++) {
                            var w = (n + 1) * a + o - 1
                              , M = (n + 1) * (a - 1) + o - 1
                              , T = (n + 1) * (a - 1) + o
                              , S = (n + 1) * a + o;
                            c[g] = w,
                            c[g + 1] = M,
                            c[g + 2] = S,
                            c[g + 3] = M,
                            c[g + 4] = T,
                            c[g + 5] = S,
                            g += 6
                        }
                    this.setIndex(new Tt(c,1)),
                    this.addAttribute("position", new Tt(u,3)),
                    this.addAttribute("normal", new Tt(p,3)),
                    this.addAttribute("uv", new Tt(d,2))
                }
                function kn(t, e, i, n, r) {
                    kt.call(this),
                    this.type = "TorusGeometry",
                    this.parameters = {
                        radius: t,
                        tube: e,
                        radialSegments: i,
                        tubularSegments: n,
                        arc: r
                    },
                    this.fromBufferGeometry(new Bn(t,e,i,n,r))
                }
                function Gn(t, e) {
                    e = e || {};
                    var i = e.font;
                    if ((i && i.isFont) === !1)
                        return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
                        new kt;
                    var n = i.generateShapes(t, e.size, e.curveSegments);
                    e.amount = void 0 !== e.height ? e.height : 50,
                    void 0 === e.bevelThickness && (e.bevelThickness = 10),
                    void 0 === e.bevelSize && (e.bevelSize = 8),
                    void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
                    Ri.call(this, n, e),
                    this.type = "TextGeometry"
                }
                function Vn(t, e, i, r, a, o) {
                    Ht.call(this),
                    this.type = "RingBufferGeometry",
                    this.parameters = {
                        innerRadius: t,
                        outerRadius: e,
                        thetaSegments: i,
                        phiSegments: r,
                        thetaStart: a,
                        thetaLength: o
                    },
                    t = t || 20,
                    e = e || 50,
                    a = void 0 !== a ? a : 0,
                    o = void 0 !== o ? o : 2 * Math.PI,
                    i = void 0 !== i ? Math.max(3, i) : 8,
                    r = void 0 !== r ? Math.max(1, r) : 1;
                    var s, h, c, u = (i + 1) * (r + 1), p = i * r * 2 * 3, d = new Tt(new (p > 65535 ? Uint32Array : Uint16Array)(p),1), f = new Tt(new Float32Array(3 * u),3), m = new Tt(new Float32Array(3 * u),3), g = new Tt(new Float32Array(2 * u),2), v = 0, _ = 0, y = t, x = (e - t) / r, b = new l, w = new n;
                    for (h = 0; h <= r; h++) {
                        for (c = 0; c <= i; c++)
                            s = a + c / i * o,
                            b.x = y * Math.cos(s),
                            b.y = y * Math.sin(s),
                            f.setXYZ(v, b.x, b.y, b.z),
                            m.setXYZ(v, 0, 0, 1),
                            w.x = (b.x / e + 1) / 2,
                            w.y = (b.y / e + 1) / 2,
                            g.setXY(v, w.x, w.y),
                            v++;
                        y += x
                    }
                    for (h = 0; h < r; h++) {
                        var M = h * (i + 1);
                        for (c = 0; c < i; c++) {
                            s = c + M;
                            var T = s
                              , S = s + i + 1
                              , E = s + i + 2
                              , A = s + 1;
                            d.setX(_, T),
                            _++,
                            d.setX(_, S),
                            _++,
                            d.setX(_, E),
                            _++,
                            d.setX(_, T),
                            _++,
                            d.setX(_, E),
                            _++,
                            d.setX(_, A),
                            _++
                        }
                    }
                    this.setIndex(d),
                    this.addAttribute("position", f),
                    this.addAttribute("normal", m),
                    this.addAttribute("uv", g)
                }
                function Hn(t, e, i, n, r, a) {
                    kt.call(this),
                    this.type = "RingGeometry",
                    this.parameters = {
                        innerRadius: t,
                        outerRadius: e,
                        thetaSegments: i,
                        phiSegments: n,
                        thetaStart: r,
                        thetaLength: a
                    },
                    this.fromBufferGeometry(new Vn(t,e,i,n,r,a))
                }
                function jn(t, e, i, n) {
                    kt.call(this),
                    this.type = "PlaneGeometry",
                    this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: i,
                        heightSegments: n
                    },
                    this.fromBufferGeometry(new ae(t,e,i,n))
                }
                function Wn(t, i, r, a) {
                    Ht.call(this),
                    this.type = "LatheBufferGeometry",
                    this.parameters = {
                        points: t,
                        segments: i,
                        phiStart: r,
                        phiLength: a
                    },
                    i = Math.floor(i) || 12,
                    r = r || 0,
                    a = a || 2 * Math.PI,
                    a = e.Math.clamp(a, 0, 2 * Math.PI);
                    var o, s, h, c = (i + 1) * t.length, u = i * t.length * 2 * 3, p = new Tt(new (u > 65535 ? Uint32Array : Uint16Array)(u),1), d = new Tt(new Float32Array(3 * c),3), f = new Tt(new Float32Array(2 * c),2), m = 0, g = 0, v = 1 / i, _ = new l, y = new n;
                    for (s = 0; s <= i; s++) {
                        var x = r + s * v * a
                          , b = Math.sin(x)
                          , w = Math.cos(x);
                        for (h = 0; h <= t.length - 1; h++)
                            _.x = t[h].x * b,
                            _.y = t[h].y,
                            _.z = t[h].x * w,
                            d.setXYZ(m, _.x, _.y, _.z),
                            y.x = s / i,
                            y.y = h / (t.length - 1),
                            f.setXY(m, y.x, y.y),
                            m++
                    }
                    for (s = 0; s < i; s++)
                        for (h = 0; h < t.length - 1; h++) {
                            o = h + s * t.length;
                            var M = o
                              , T = o + t.length
                              , S = o + t.length + 1
                              , E = o + 1;
                            p.setX(g, M),
                            g++,
                            p.setX(g, T),
                            g++,
                            p.setX(g, E),
                            g++,
                            p.setX(g, T),
                            g++,
                            p.setX(g, S),
                            g++,
                            p.setX(g, E),
                            g++
                        }
                    if (this.setIndex(p),
                    this.addAttribute("position", d),
                    this.addAttribute("uv", f),
                    this.computeVertexNormals(),
                    a === 2 * Math.PI) {
                        var A = this.attributes.normal.array
                          , P = new l
                          , R = new l
                          , L = new l;
                        for (o = i * t.length * 3,
                        s = 0,
                        h = 0; s < t.length; s++,
                        h += 3)
                            P.x = A[h + 0],
                            P.y = A[h + 1],
                            P.z = A[h + 2],
                            R.x = A[o + h + 0],
                            R.y = A[o + h + 1],
                            R.z = A[o + h + 2],
                            L.addVectors(P, R).normalize(),
                            A[h + 0] = A[o + h + 0] = L.x,
                            A[h + 1] = A[o + h + 1] = L.y,
                            A[h + 2] = A[o + h + 2] = L.z
                    }
                }
                function Xn(t, e, i, n) {
                    kt.call(this),
                    this.type = "LatheGeometry",
                    this.parameters = {
                        points: t,
                        segments: e,
                        phiStart: i,
                        phiLength: n
                    },
                    this.fromBufferGeometry(new Wn(t,e,i,n)),
                    this.mergeVertices()
                }
                function Yn(t, e, i, n, r, a, o, s) {
                    kt.call(this),
                    this.type = "CylinderGeometry",
                    this.parameters = {
                        radiusTop: t,
                        radiusBottom: e,
                        height: i,
                        radialSegments: n,
                        heightSegments: r,
                        openEnded: a,
                        thetaStart: o,
                        thetaLength: s
                    },
                    this.fromBufferGeometry(new Pn(t,e,i,n,r,a,o,s)),
                    this.mergeVertices()
                }
                function qn(t, e, i, n, r, a, o) {
                    Yn.call(this, 0, t, e, i, n, r, a, o),
                    this.type = "ConeGeometry",
                    this.parameters = {
                        radius: t,
                        height: e,
                        radialSegments: i,
                        heightSegments: n,
                        openEnded: r,
                        thetaStart: a,
                        thetaLength: o
                    }
                }
                function Zn(t, e, i, n, r, a, o) {
                    Pn.call(this, 0, t, e, i, n, r, a, o),
                    this.type = "ConeBufferGeometry",
                    this.parameters = {
                        radius: t,
                        height: e,
                        radialSegments: i,
                        heightSegments: n,
                        thetaStart: a,
                        thetaLength: o
                    }
                }
                function Qn(t, e, i, n) {
                    Ht.call(this),
                    this.type = "CircleBufferGeometry",
                    this.parameters = {
                        radius: t,
                        segments: e,
                        thetaStart: i,
                        thetaLength: n
                    },
                    t = t || 50,
                    e = void 0 !== e ? Math.max(3, e) : 8,
                    i = void 0 !== i ? i : 0,
                    n = void 0 !== n ? n : 2 * Math.PI;
                    var r = e + 2
                      , a = new Float32Array(3 * r)
                      , o = new Float32Array(3 * r)
                      , s = new Float32Array(2 * r);
                    o[2] = 1,
                    s[0] = .5,
                    s[1] = .5;
                    for (var h = 0, c = 3, u = 2; h <= e; h++,
                    c += 3,
                    u += 2) {
                        var p = i + h / e * n;
                        a[c] = t * Math.cos(p),
                        a[c + 1] = t * Math.sin(p),
                        o[c + 2] = 1,
                        s[u] = (a[c] / t + 1) / 2,
                        s[u + 1] = (a[c + 1] / t + 1) / 2
                    }
                    for (var d = [], c = 1; c <= e; c++)
                        d.push(c, c + 1, 0);
                    this.setIndex(new Tt(new Uint16Array(d),1)),
                    this.addAttribute("position", new Tt(a,3)),
                    this.addAttribute("normal", new Tt(o,3)),
                    this.addAttribute("uv", new Tt(s,2)),
                    this.boundingSphere = new nt(new l,t)
                }
                function Jn(t, e, i, n) {
                    kt.call(this),
                    this.type = "CircleGeometry",
                    this.parameters = {
                        radius: t,
                        segments: e,
                        thetaStart: i,
                        thetaLength: n
                    },
                    this.fromBufferGeometry(new Qn(t,e,i,n))
                }
                function Kn(t) {
                    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."),
                    e.CatmullRomCurve3.call(this, t),
                    this.type = "catmullrom",
                    this.closed = !0
                }
                function $n(t, e, i, n, r, a) {
                    Ti.call(this, t, e, i, i, n, r, a)
                }
                function tr(t, e, i, n, r, a, o) {
                    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
                    new Ut(t,e,i,r,a,o)
                }
                function er(t, e) {
                    return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
                    new Se(t,e)
                }
                function ir(t, e) {
                    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
                    new Se(t,e)
                }
                function nr(t) {
                    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
                    new Te(t)
                }
                function rr(t) {
                    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
                    new Te(t)
                }
                function ar(t) {
                    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
                    new Te(t)
                }
                function or(t, e, i) {
                    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
                    new l(t,e,i)
                }
                function sr() {
                    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
                    this.projectVector = function(t, e) {
                        console.warn("THREE.Projector: .projectVector() is now vector.project()."),
                        t.project(e)
                    }
                    ,
                    this.unprojectVector = function(t, e) {
                        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
                        t.unproject(e)
                    }
                    ,
                    this.pickingRay = function(t, e) {
                        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                    }
                }
                function lr() {
                    console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
                    this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    this.clear = function() {}
                    ,
                    this.render = function() {}
                    ,
                    this.setClearColor = function() {}
                    ,
                    this.setSize = function() {}
                }
                void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
                void 0 === Math.sign && (Math.sign = function(t) {
                    return t < 0 ? -1 : t > 0 ? 1 : +t
                }
                ),
                void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
                    get: function() {
                        return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
                    }
                }),
                void 0 === Object.assign && !function() {
                    Object.assign = function(t) {
                        if (void 0 === t || null === t)
                            throw new TypeError("Cannot convert undefined or null to object");
                        for (var e = Object(t), i = 1; i < arguments.length; i++) {
                            var n = arguments[i];
                            if (void 0 !== n && null !== n)
                                for (var r in n)
                                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                        }
                        return e
                    }
                }(),
                Object.assign(i.prototype, {
                    addEventListener: function(t, e) {
                        void 0 === this._listeners && (this._listeners = {});
                        var i = this._listeners;
                        void 0 === i[t] && (i[t] = []),
                        i[t].indexOf(e) === -1 && i[t].push(e)
                    },
                    hasEventListener: function(t, e) {
                        if (void 0 === this._listeners)
                            return !1;
                        var i = this._listeners;
                        return void 0 !== i[t] && i[t].indexOf(e) !== -1
                    },
                    removeEventListener: function(t, e) {
                        if (void 0 !== this._listeners) {
                            var i = this._listeners
                              , n = i[t];
                            if (void 0 !== n) {
                                var r = n.indexOf(e);
                                r !== -1 && n.splice(r, 1)
                            }
                        }
                    },
                    dispatchEvent: function(t) {
                        if (void 0 !== this._listeners) {
                            var e = this._listeners
                              , i = e[t.type];
                            if (void 0 !== i) {
                                t.target = this;
                                var n = []
                                  , r = 0
                                  , a = i.length;
                                for (r = 0; r < a; r++)
                                    n[r] = i[r];
                                for (r = 0; r < a; r++)
                                    n[r].call(this, t)
                            }
                        }
                    }
                });
                var hr = "80"
                  , cr = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                }
                  , ur = 0
                  , pr = 1
                  , dr = 2
                  , fr = 3
                  , mr = 0
                  , gr = 1
                  , vr = 0
                  , _r = 1
                  , yr = 2
                  , xr = 0
                  , br = 1
                  , wr = 2
                  , Mr = 1
                  , Tr = 2
                  , Sr = 0
                  , Er = 1
                  , Ar = 2
                  , Pr = 0
                  , Rr = 1
                  , Lr = 2
                  , Cr = 3
                  , Or = 4
                  , Ir = 5
                  , Dr = 100
                  , Ur = 101
                  , Fr = 102
                  , Nr = 103
                  , zr = 104
                  , Br = 200
                  , kr = 201
                  , Gr = 202
                  , Vr = 203
                  , Hr = 204
                  , jr = 205
                  , Wr = 206
                  , Xr = 207
                  , Yr = 208
                  , qr = 209
                  , Zr = 210
                  , Qr = 0
                  , Jr = 1
                  , Kr = 2
                  , $r = 3
                  , ta = 4
                  , ea = 5
                  , ia = 6
                  , na = 7
                  , ra = 0
                  , aa = 1
                  , oa = 2
                  , sa = 0
                  , la = 1
                  , ha = 2
                  , ca = 3
                  , ua = 4
                  , pa = 300
                  , da = 301
                  , fa = 302
                  , ma = 303
                  , ga = 304
                  , va = 305
                  , _a = 306
                  , ya = 307
                  , xa = 1e3
                  , ba = 1001
                  , wa = 1002
                  , Ma = 1003
                  , Ta = 1004
                  , Sa = 1005
                  , Ea = 1006
                  , Aa = 1007
                  , Pa = 1008
                  , Ra = 1009
                  , La = 1010
                  , Ca = 1011
                  , Oa = 1012
                  , Ia = 1013
                  , Da = 1014
                  , Ua = 1015
                  , Fa = 1016
                  , Na = 1017
                  , za = 1018
                  , Ba = 1019
                  , ka = 1020
                  , Ga = 1021
                  , Va = 1022
                  , Ha = 1023
                  , ja = 1024
                  , Wa = 1025
                  , Xa = Ha
                  , Ya = 1026
                  , qa = 1027
                  , Za = 2001
                  , Qa = 2002
                  , Ja = 2003
                  , Ka = 2004
                  , $a = 2100
                  , to = 2101
                  , eo = 2102
                  , io = 2103
                  , no = 2151
                  , ro = 2200
                  , ao = 2201
                  , oo = 2202
                  , so = 2300
                  , lo = 2301
                  , ho = 2302
                  , co = 2400
                  , uo = 2401
                  , po = 2402
                  , fo = 0
                  , mo = 1
                  , go = 2
                  , vo = 3e3
                  , _o = 3001
                  , yo = 3007
                  , xo = 3002
                  , bo = 3003
                  , wo = 3004
                  , Mo = 3005
                  , To = 3006
                  , So = 3200
                  , Eo = 3201;
                e.Math = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), i = new Array(36), n = 0;
                        return function() {
                            for (var r = 0; r < 36; r++)
                                8 === r || 13 === r || 18 === r || 23 === r ? i[r] = "-" : 14 === r ? i[r] = "4" : (n <= 2 && (n = 33554432 + 16777216 * Math.random() | 0),
                                t = 15 & n,
                                n >>= 4,
                                i[r] = e[19 === r ? 3 & t | 8 : t]);
                            return i.join("")
                        }
                    }(),
                    clamp: function(t, e, i) {
                        return Math.max(e, Math.min(i, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, i, n, r) {
                        return n + (t - e) * (r - n) / (i - e)
                    },
                    smoothstep: function(t, e, i) {
                        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e),
                        t * t * (3 - 2 * t))
                    },
                    smootherstep: function(t, e, i) {
                        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e),
                        t * t * t * (t * (6 * t - 15) + 10))
                    },
                    random16: function() {
                        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."),
                        Math.random()
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * e.Math.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * e.Math.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 === (t & t - 1) && 0 !== t
                    },
                    nearestPowerOfTwo: function(t) {
                        return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
                    },
                    nextPowerOfTwo: function(t) {
                        return t--,
                        t |= t >> 1,
                        t |= t >> 2,
                        t |= t >> 4,
                        t |= t >> 8,
                        t |= t >> 16,
                        t++,
                        t
                    }
                },
                n.prototype = {
                    constructor: n,
                    isVector2: !0,
                    get width() {
                        return this.x
                    },
                    set width(t) {
                        this.x = t
                    },
                    get height() {
                        return this.y
                    },
                    set height(t) {
                        this.y = t
                    },
                    set: function(t, e) {
                        return this.x = t,
                        this.y = e,
                        this
                    },
                    setScalar: function(t) {
                        return this.x = t,
                        this.y = t,
                        this
                    },
                    setX: function(t) {
                        return this.x = t,
                        this
                    },
                    setY: function(t) {
                        return this.y = t,
                        this
                    },
                    setComponent: function(t, e) {
                        switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    },
                    getComponent: function(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    },
                    clone: function() {
                        return new this.constructor(this.x,this.y)
                    },
                    copy: function(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this
                    },
                    add: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(t, e)) : (this.x += t.x,
                        this.y += t.y,
                        this)
                    },
                    addScalar: function(t) {
                        return this.x += t,
                        this.y += t,
                        this
                    },
                    addVectors: function(t, e) {
                        return this.x = t.x + e.x,
                        this.y = t.y + e.y,
                        this
                    },
                    addScaledVector: function(t, e) {
                        return this.x += t.x * e,
                        this.y += t.y * e,
                        this
                    },
                    sub: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(t, e)) : (this.x -= t.x,
                        this.y -= t.y,
                        this)
                    },
                    subScalar: function(t) {
                        return this.x -= t,
                        this.y -= t,
                        this
                    },
                    subVectors: function(t, e) {
                        return this.x = t.x - e.x,
                        this.y = t.y - e.y,
                        this
                    },
                    multiply: function(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this
                    },
                    multiplyScalar: function(t) {
                        return isFinite(t) ? (this.x *= t,
                        this.y *= t) : (this.x = 0,
                        this.y = 0),
                        this
                    },
                    divide: function(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this
                    },
                    divideScalar: function(t) {
                        return this.multiplyScalar(1 / t)
                    },
                    min: function(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this
                    },
                    max: function(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this
                    },
                    clamp: function(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                        this.y = Math.max(t.y, Math.min(e.y, this.y)),
                        this
                    },
                    clampScalar: function() {
                        var t, e;
                        return function(i, r) {
                            return void 0 === t && (t = new n,
                            e = new n),
                            t.set(i, i),
                            e.set(r, r),
                            this.clamp(t, e)
                        }
                    }(),
                    clampLength: function(t, e) {
                        var i = this.length();
                        return this.multiplyScalar(Math.max(t, Math.min(e, i)) / i)
                    },
                    floor: function() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this
                    },
                    ceil: function() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this
                    },
                    round: function() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    },
                    roundToZero: function() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this
                    },
                    negate: function() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y
                    },
                    lengthSq: function() {
                        return this.x * this.x + this.y * this.y
                    },
                    length: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    lengthManhattan: function() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    },
                    normalize: function() {
                        return this.divideScalar(this.length())
                    },
                    angle: function() {
                        var t = Math.atan2(this.y, this.x);
                        return t < 0 && (t += 2 * Math.PI),
                        t
                    },
                    distanceTo: function(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    },
                    distanceToSquared: function(t) {
                        var e = this.x - t.x
                          , i = this.y - t.y;
                        return e * e + i * i
                    },
                    distanceToManhattan: function(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                    },
                    setLength: function(t) {
                        return this.multiplyScalar(t / this.length())
                    },
                    lerp: function(t, e) {
                        return this.x += (t.x - this.x) * e,
                        this.y += (t.y - this.y) * e,
                        this
                    },
                    lerpVectors: function(t, e, i) {
                        return this.subVectors(e, t).multiplyScalar(i).add(t)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y
                    },
                    fromArray: function(t, e) {
                        return void 0 === e && (e = 0),
                        this.x = t[e],
                        this.y = t[e + 1],
                        this
                    },
                    toArray: function(t, e) {
                        return void 0 === t && (t = []),
                        void 0 === e && (e = 0),
                        t[e] = this.x,
                        t[e + 1] = this.y,
                        t
                    },
                    fromAttribute: function(t, e, i) {
                        return void 0 === i && (i = 0),
                        e = e * t.itemSize + i,
                        this.x = t.array[e],
                        this.y = t.array[e + 1],
                        this
                    },
                    rotateAround: function(t, e) {
                        var i = Math.cos(e)
                          , n = Math.sin(e)
                          , r = this.x - t.x
                          , a = this.y - t.y;
                        return this.x = r * i - a * n + t.x,
                        this.y = r * n + a * i + t.y,
                        this
                    }
                },
                r.DEFAULT_IMAGE = void 0,
                r.DEFAULT_MAPPING = pa,
                r.prototype = {
                    constructor: r,
                    isTexture: !0,
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.image = t.image,
                        this.mipmaps = t.mipmaps.slice(0),
                        this.mapping = t.mapping,
                        this.wrapS = t.wrapS,
                        this.wrapT = t.wrapT,
                        this.magFilter = t.magFilter,
                        this.minFilter = t.minFilter,
                        this.anisotropy = t.anisotropy,
                        this.format = t.format,
                        this.type = t.type,
                        this.offset.copy(t.offset),
                        this.repeat.copy(t.repeat),
                        this.generateMipmaps = t.generateMipmaps,
                        this.premultiplyAlpha = t.premultiplyAlpha,
                        this.flipY = t.flipY,
                        this.unpackAlignment = t.unpackAlignment,
                        this.encoding = t.encoding,
                        this
                    },
                    toJSON: function(t) {
                        function i(t) {
                            var e;
                            return void 0 !== t.toDataURL ? e = t : (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                            e.width = t.width,
                            e.height = t.height,
                            e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)),
                            e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                        }
                        if (void 0 !== t.textures[this.uuid])
                            return t.textures[this.uuid];
                        var n = {
                            metadata: {
                                version: 4.4,
                                type: "Texture",
                                generator: "Texture.toJSON"
                            },
                            uuid: this.uuid,
                            name: this.name,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            wrap: [this.wrapS, this.wrapT],
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY
                        };
                        if (void 0 !== this.image) {
                            var r = this.image;
                            void 0 === r.uuid && (r.uuid = e.Math.generateUUID()),
                            void 0 === t.images[r.uuid] && (t.images[r.uuid] = {
                                uuid: r.uuid,
                                url: i(r)
                            }),
                            n.image = r.uuid
                        }
                        return t.textures[this.uuid] = n,
                        n
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    },
                    transformUv: function(t) {
                        if (this.mapping === pa) {
                            if (t.multiply(this.repeat),
                            t.add(this.offset),
                            t.x < 0 || t.x > 1)
                                switch (this.wrapS) {
                                case xa:
                                    t.x = t.x - Math.floor(t.x);
                                    break;
                                case ba:
                                    t.x = t.x < 0 ? 0 : 1;
                                    break;
                                case wa:
                                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                                }
                            if (t.y < 0 || t.y > 1)
                                switch (this.wrapT) {
                                case xa:
                                    t.y = t.y - Math.floor(t.y);
                                    break;
                                case ba:
                                    t.y = t.y < 0 ? 0 : 1;
                                    break;
                                case wa:
                                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                                }
                            this.flipY && (t.y = 1 - t.y)
                        }
                    }
                },
                Object.assign(r.prototype, i.prototype);
                var Ao = 0;
                o.prototype = {
                    constructor: o,
                    isMatrix4: !0,
                    set: function(t, e, i, n, r, a, o, s, l, h, c, u, p, d, f, m) {
                        var g = this.elements;
                        return g[0] = t,
                        g[4] = e,
                        g[8] = i,
                        g[12] = n,
                        g[1] = r,
                        g[5] = a,
                        g[9] = o,
                        g[13] = s,
                        g[2] = l,
                        g[6] = h,
                        g[10] = c,
                        g[14] = u,
                        g[3] = p,
                        g[7] = d,
                        g[11] = f,
                        g[15] = m,
                        this
                    },
                    identity: function() {
                        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    },
                    clone: function() {
                        return (new o).fromArray(this.elements)
                    },
                    copy: function(t) {
                        return this.elements.set(t.elements),
                        this
                    },
                    copyPosition: function(t) {
                        var e = this.elements
                          , i = t.elements;
                        return e[12] = i[12],
                        e[13] = i[13],
                        e[14] = i[14],
                        this
                    },
                    extractBasis: function(t, e, i) {
                        return t.setFromMatrixColumn(this, 0),
                        e.setFromMatrixColumn(this, 1),
                        i.setFromMatrixColumn(this, 2),
                        this
                    },
                    makeBasis: function(t, e, i) {
                        return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1),
                        this
                    },
                    extractRotation: function() {
                        var t;
                        return function(e) {
                            void 0 === t && (t = new l);
                            var i = this.elements
                              , n = e.elements
                              , r = 1 / t.setFromMatrixColumn(e, 0).length()
                              , a = 1 / t.setFromMatrixColumn(e, 1).length()
                              , o = 1 / t.setFromMatrixColumn(e, 2).length();
                            return i[0] = n[0] * r,
                            i[1] = n[1] * r,
                            i[2] = n[2] * r,
                            i[4] = n[4] * a,
                            i[5] = n[5] * a,
                            i[6] = n[6] * a,
                            i[8] = n[8] * o,
                            i[9] = n[9] * o,
                            i[10] = n[10] * o,
                            this
                        }
                    }(),
                    makeRotationFromEuler: function(t) {
                        (t && t.isEuler) === !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        var e = this.elements
                          , i = t.x
                          , n = t.y
                          , r = t.z
                          , a = Math.cos(i)
                          , o = Math.sin(i)
                          , s = Math.cos(n)
                          , l = Math.sin(n)
                          , h = Math.cos(r)
                          , c = Math.sin(r);
                        if ("XYZ" === t.order) {
                            var u = a * h
                              , p = a * c
                              , d = o * h
                              , f = o * c;
                            e[0] = s * h,
                            e[4] = -s * c,
                            e[8] = l,
                            e[1] = p + d * l,
                            e[5] = u - f * l,
                            e[9] = -o * s,
                            e[2] = f - u * l,
                            e[6] = d + p * l,
                            e[10] = a * s
                        } else if ("YXZ" === t.order) {
                            var m = s * h
                              , g = s * c
                              , v = l * h
                              , _ = l * c;
                            e[0] = m + _ * o,
                            e[4] = v * o - g,
                            e[8] = a * l,
                            e[1] = a * c,
                            e[5] = a * h,
                            e[9] = -o,
                            e[2] = g * o - v,
                            e[6] = _ + m * o,
                            e[10] = a * s
                        } else if ("ZXY" === t.order) {
                            var m = s * h
                              , g = s * c
                              , v = l * h
                              , _ = l * c;
                            e[0] = m - _ * o,
                            e[4] = -a * c,
                            e[8] = v + g * o,
                            e[1] = g + v * o,
                            e[5] = a * h,
                            e[9] = _ - m * o,
                            e[2] = -a * l,
                            e[6] = o,
                            e[10] = a * s
                        } else if ("ZYX" === t.order) {
                            var u = a * h
                              , p = a * c
                              , d = o * h
                              , f = o * c;
                            e[0] = s * h,
                            e[4] = d * l - p,
                            e[8] = u * l + f,
                            e[1] = s * c,
                            e[5] = f * l + u,
                            e[9] = p * l - d,
                            e[2] = -l,
                            e[6] = o * s,
                            e[10] = a * s
                        } else if ("YZX" === t.order) {
                            var y = a * s
                              , x = a * l
                              , b = o * s
                              , w = o * l;
                            e[0] = s * h,
                            e[4] = w - y * c,
                            e[8] = b * c + x,
                            e[1] = c,
                            e[5] = a * h,
                            e[9] = -o * h,
                            e[2] = -l * h,
                            e[6] = x * c + b,
                            e[10] = y - w * c
                        } else if ("XZY" === t.order) {
                            var y = a * s
                              , x = a * l
                              , b = o * s
                              , w = o * l;
                            e[0] = s * h,
                            e[4] = -c,
                            e[8] = l * h,
                            e[1] = y * c + w,
                            e[5] = a * h,
                            e[9] = x * c - b,
                            e[2] = b * c - x,
                            e[6] = o * h,
                            e[10] = w * c + y
                        }
                        return e[3] = 0,
                        e[7] = 0,
                        e[11] = 0,
                        e[12] = 0,
                        e[13] = 0,
                        e[14] = 0,
                        e[15] = 1,
                        this
                    },
                    makeRotationFromQuaternion: function(t) {
                        var e = this.elements
                          , i = t.x
                          , n = t.y
                          , r = t.z
                          , a = t.w
                          , o = i + i
                          , s = n + n
                          , l = r + r
                          , h = i * o
                          , c = i * s
                          , u = i * l
                          , p = n * s
                          , d = n * l
                          , f = r * l
                          , m = a * o
                          , g = a * s
                          , v = a * l;
                        return e[0] = 1 - (p + f),
                        e[4] = c - v,
                        e[8] = u + g,
                        e[1] = c + v,
                        e[5] = 1 - (h + f),
                        e[9] = d - m,
                        e[2] = u - g,
                        e[6] = d + m,
                        e[10] = 1 - (h + p),
                        e[3] = 0,
                        e[7] = 0,
                        e[11] = 0,
                        e[12] = 0,
                        e[13] = 0,
                        e[14] = 0,
                        e[15] = 1,
                        this
                    },
                    lookAt: function() {
                        var t, e, i;
                        return function(n, r, a) {
                            void 0 === t && (t = new l,
                            e = new l,
                            i = new l);
                            var o = this.elements;
                            return i.subVectors(n, r).normalize(),
                            0 === i.lengthSq() && (i.z = 1),
                            t.crossVectors(a, i).normalize(),
                            0 === t.lengthSq() && (i.z += 1e-4,
                            t.crossVectors(a, i).normalize()),
                            e.crossVectors(i, t),
                            o[0] = t.x,
                            o[4] = e.x,
                            o[8] = i.x,
                            o[1] = t.y,
                            o[5] = e.y,
                            o[9] = i.y,
                            o[2] = t.z,
                            o[6] = e.z,
                            o[10] = i.z,
                            this
                        }
                    }(),
                    multiply: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
                        this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                    },
                    premultiply: function(t) {
                        return this.multiplyMatrices(t, this)
                    },
                    multiplyMatrices: function(t, e) {
                        var i = t.elements
                          , n = e.elements
                          , r = this.elements
                          , a = i[0]
                          , o = i[4]
                          , s = i[8]
                          , l = i[12]
                          , h = i[1]
                          , c = i[5]
                          , u = i[9]
                          , p = i[13]
                          , d = i[2]
                          , f = i[6]
                          , m = i[10]
                          , g = i[14]
                          , v = i[3]
                          , _ = i[7]
                          , y = i[11]
                          , x = i[15]
                          , b = n[0]
                          , w = n[4]
                          , M = n[8]
                          , T = n[12]
                          , S = n[1]
                          , E = n[5]
                          , A = n[9]
                          , P = n[13]
                          , R = n[2]
                          , L = n[6]
                          , C = n[10]
                          , O = n[14]
                          , I = n[3]
                          , D = n[7]
                          , U = n[11]
                          , F = n[15];
                        return r[0] = a * b + o * S + s * R + l * I,
                        r[4] = a * w + o * E + s * L + l * D,
                        r[8] = a * M + o * A + s * C + l * U,
                        r[12] = a * T + o * P + s * O + l * F,
                        r[1] = h * b + c * S + u * R + p * I,
                        r[5] = h * w + c * E + u * L + p * D,
                        r[9] = h * M + c * A + u * C + p * U,
                        r[13] = h * T + c * P + u * O + p * F,
                        r[2] = d * b + f * S + m * R + g * I,
                        r[6] = d * w + f * E + m * L + g * D,
                        r[10] = d * M + f * A + m * C + g * U,
                        r[14] = d * T + f * P + m * O + g * F,
                        r[3] = v * b + _ * S + y * R + x * I,
                        r[7] = v * w + _ * E + y * L + x * D,
                        r[11] = v * M + _ * A + y * C + x * U,
                        r[15] = v * T + _ * P + y * O + x * F,
                        this
                    },
                    multiplyToArray: function(t, e, i) {
                        var n = this.elements;
                        return this.multiplyMatrices(t, e),
                        i[0] = n[0],
                        i[1] = n[1],
                        i[2] = n[2],
                        i[3] = n[3],
                        i[4] = n[4],
                        i[5] = n[5],
                        i[6] = n[6],
                        i[7] = n[7],
                        i[8] = n[8],
                        i[9] = n[9],
                        i[10] = n[10],
                        i[11] = n[11],
                        i[12] = n[12],
                        i[13] = n[13],
                        i[14] = n[14],
                        i[15] = n[15],
                        this
                    },
                    multiplyScalar: function(t) {
                        var e = this.elements;
                        return e[0] *= t,
                        e[4] *= t,
                        e[8] *= t,
                        e[12] *= t,
                        e[1] *= t,
                        e[5] *= t,
                        e[9] *= t,
                        e[13] *= t,
                        e[2] *= t,
                        e[6] *= t,
                        e[10] *= t,
                        e[14] *= t,
                        e[3] *= t,
                        e[7] *= t,
                        e[11] *= t,
                        e[15] *= t,
                        this
                    },
                    applyToVector3Array: function() {
                        var t;
                        return function(e, i, n) {
                            void 0 === t && (t = new l),
                            void 0 === i && (i = 0),
                            void 0 === n && (n = e.length);
                            for (var r = 0, a = i; r < n; r += 3,
                            a += 3)
                                t.fromArray(e, a),
                                t.applyMatrix4(this),
                                t.toArray(e, a);
                            return e
                        }
                    }(),
                    applyToBuffer: function() {
                        var t;
                        return function(e, i, n) {
                            void 0 === t && (t = new l),
                            void 0 === i && (i = 0),
                            void 0 === n && (n = e.length / e.itemSize);
                            for (var r = 0, a = i; r < n; r++,
                            a++)
                                t.x = e.getX(a),
                                t.y = e.getY(a),
                                t.z = e.getZ(a),
                                t.applyMatrix4(this),
                                e.setXYZ(t.x, t.y, t.z);
                            return e
                        }
                    }(),
                    determinant: function() {
                        var t = this.elements
                          , e = t[0]
                          , i = t[4]
                          , n = t[8]
                          , r = t[12]
                          , a = t[1]
                          , o = t[5]
                          , s = t[9]
                          , l = t[13]
                          , h = t[2]
                          , c = t[6]
                          , u = t[10]
                          , p = t[14]
                          , d = t[3]
                          , f = t[7]
                          , m = t[11]
                          , g = t[15];
                        return d * (+r * s * c - n * l * c - r * o * u + i * l * u + n * o * p - i * s * p) + f * (+e * s * p - e * l * u + r * a * u - n * a * p + n * l * h - r * s * h) + m * (+e * l * c - e * o * p - r * a * c + i * a * p + r * o * h - i * l * h) + g * (-n * o * h - e * s * c + e * o * u + n * a * c - i * a * u + i * s * h)
                    },
                    transpose: function() {
                        var t, e = this.elements;
                        return t = e[1],
                        e[1] = e[4],
                        e[4] = t,
                        t = e[2],
                        e[2] = e[8],
                        e[8] = t,
                        t = e[6],
                        e[6] = e[9],
                        e[9] = t,
                        t = e[3],
                        e[3] = e[12],
                        e[12] = t,
                        t = e[7],
                        e[7] = e[13],
                        e[13] = t,
                        t = e[11],
                        e[11] = e[14],
                        e[14] = t,
                        this
                    },
                    flattenToArrayOffset: function(t, e) {
                        return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
                        this.toArray(t, e)
                    },
                    getPosition: function() {
                        var t;
                        return function() {
                            return void 0 === t && (t = new l),
                            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
                            t.setFromMatrixColumn(this, 3)
                        }
                    }(),
                    setPosition: function(t) {
                        var e = this.elements;
                        return e[12] = t.x,
                        e[13] = t.y,
                        e[14] = t.z,
                        this
                    },
                    getInverse: function(t, e) {
                        var i = this.elements
                          , n = t.elements
                          , r = n[0]
                          , a = n[1]
                          , o = n[2]
                          , s = n[3]
                          , l = n[4]
                          , h = n[5]
                          , c = n[6]
                          , u = n[7]
                          , p = n[8]
                          , d = n[9]
                          , f = n[10]
                          , m = n[11]
                          , g = n[12]
                          , v = n[13]
                          , _ = n[14]
                          , y = n[15]
                          , x = d * _ * u - v * f * u + v * c * m - h * _ * m - d * c * y + h * f * y
                          , b = g * f * u - p * _ * u - g * c * m + l * _ * m + p * c * y - l * f * y
                          , w = p * v * u - g * d * u + g * h * m - l * v * m - p * h * y + l * d * y
                          , M = g * d * c - p * v * c - g * h * f + l * v * f + p * h * _ - l * d * _
                          , T = r * x + a * b + o * w + s * M;
                        if (0 === T) {
                            var S = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                            if (e === !0)
                                throw new Error(S);
                            return console.warn(S),
                            this.identity()
                        }
                        var E = 1 / T;
                        return i[0] = x * E,
                        i[1] = (v * f * s - d * _ * s - v * o * m + a * _ * m + d * o * y - a * f * y) * E,
                        i[2] = (h * _ * s - v * c * s + v * o * u - a * _ * u - h * o * y + a * c * y) * E,
                        i[3] = (d * c * s - h * f * s - d * o * u + a * f * u + h * o * m - a * c * m) * E,
                        i[4] = b * E,
                        i[5] = (p * _ * s - g * f * s + g * o * m - r * _ * m - p * o * y + r * f * y) * E,
                        i[6] = (g * c * s - l * _ * s - g * o * u + r * _ * u + l * o * y - r * c * y) * E,
                        i[7] = (l * f * s - p * c * s + p * o * u - r * f * u - l * o * m + r * c * m) * E,
                        i[8] = w * E,
                        i[9] = (g * d * s - p * v * s - g * a * m + r * v * m + p * a * y - r * d * y) * E,
                        i[10] = (l * v * s - g * h * s + g * a * u - r * v * u - l * a * y + r * h * y) * E,
                        i[11] = (p * h * s - l * d * s - p * a * u + r * d * u + l * a * m - r * h * m) * E,
                        i[12] = M * E,
                        i[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a * _ + r * d * _) * E,
                        i[14] = (g * h * o - l * v * o - g * a * c + r * v * c + l * a * _ - r * h * _) * E,
                        i[15] = (l * d * o - p * h * o + p * a * c - r * d * c - l * a * f + r * h * f) * E,
                        this
                    },
                    scale: function(t) {
                        var e = this.elements
                          , i = t.x
                          , n = t.y
                          , r = t.z;
                        return e[0] *= i,
                        e[4] *= n,
                        e[8] *= r,
                        e[1] *= i,
                        e[5] *= n,
                        e[9] *= r,
                        e[2] *= i,
                        e[6] *= n,
                        e[10] *= r,
                        e[3] *= i,
                        e[7] *= n,
                        e[11] *= r,
                        this
                    },
                    getMaxScaleOnAxis: function() {
                        var t = this.elements
                          , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
                          , i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
                          , n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                        return Math.sqrt(Math.max(e, i, n))
                    },
                    makeTranslation: function(t, e, i) {
                        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1),
                        this
                    },
                    makeRotationX: function(t) {
                        var e = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1),
                        this
                    },
                    makeRotationY: function(t) {
                        var e = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1),
                        this
                    },
                    makeRotationZ: function(t) {
                        var e = Math.cos(t)
                          , i = Math.sin(t);
                        return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                        this
                    },
                    makeRotationAxis: function(t, e) {
                        var i = Math.cos(e)
                          , n = Math.sin(e)
                          , r = 1 - i
                          , a = t.x
                          , o = t.y
                          , s = t.z
                          , l = r * a
                          , h = r * o;
                        return this.set(l * a + i, l * o - n * s, l * s + n * o, 0, l * o + n * s, h * o + i, h * s - n * a, 0, l * s - n * o, h * s + n * a, r * s * s + i, 0, 0, 0, 0, 1),
                        this
                    },
                    makeScale: function(t, e, i) {
                        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
                        this
                    },
                    compose: function(t, e, i) {
                        return this.makeRotationFromQuaternion(e),
                        this.scale(i),
                        this.setPosition(t),
                        this
                    },
                    decompose: function() {
                        var t, e;
                        return function(i, n, r) {
                            void 0 === t && (t = new l,
                            e = new o);
                            var a = this.elements
                              , s = t.set(a[0], a[1], a[2]).length()
                              , h = t.set(a[4], a[5], a[6]).length()
                              , c = t.set(a[8], a[9], a[10]).length()
                              , u = this.determinant();
                            u < 0 && (s = -s),
                            i.x = a[12],
                            i.y = a[13],
                            i.z = a[14],
                            e.elements.set(this.elements);
                            var p = 1 / s
                              , d = 1 / h
                              , f = 1 / c;
                            return e.elements[0] *= p,
                            e.elements[1] *= p,
                            e.elements[2] *= p,
                            e.elements[4] *= d,
                            e.elements[5] *= d,
                            e.elements[6] *= d,
                            e.elements[8] *= f,
                            e.elements[9] *= f,
                            e.elements[10] *= f,
                            n.setFromRotationMatrix(e),
                            r.x = s,
                            r.y = h,
                            r.z = c,
                            this
                        }
                    }(),
                    makeFrustum: function(t, e, i, n, r, a) {
                        var o = this.elements
                          , s = 2 * r / (e - t)
                          , l = 2 * r / (n - i)
                          , h = (e + t) / (e - t)
                          , c = (n + i) / (n - i)
                          , u = -(a + r) / (a - r)
                          , p = -2 * a * r / (a - r);
                        return o[0] = s,
                        o[4] = 0,
                        o[8] = h,
                        o[12] = 0,
                        o[1] = 0,
                        o[5] = l,
                        o[9] = c,
                        o[13] = 0,
                        o[2] = 0,
                        o[6] = 0,
                        o[10] = u,
                        o[14] = p,
                        o[3] = 0,
                        o[7] = 0,
                        o[11] = -1,
                        o[15] = 0,
                        this
                    },
                    makePerspective: function(t, i, n, r) {
                        var a = n * Math.tan(e.Math.DEG2RAD * t * .5)
                          , o = -a
                          , s = o * i
                          , l = a * i;
                        return this.makeFrustum(s, l, o, a, n, r)
                    },
                    makeOrthographic: function(t, e, i, n, r, a) {
                        var o = this.elements
                          , s = 1 / (e - t)
                          , l = 1 / (i - n)
                          , h = 1 / (a - r)
                          , c = (e + t) * s
                          , u = (i + n) * l
                          , p = (a + r) * h;
                        return o[0] = 2 * s,
                        o[4] = 0,
                        o[8] = 0,
                        o[12] = -c,
                        o[1] = 0,
                        o[5] = 2 * l,
                        o[9] = 0,
                        o[13] = -u,
                        o[2] = 0,
                        o[6] = 0,
                        o[10] = -2 * h,
                        o[14] = -p,
                        o[3] = 0,
                        o[7] = 0,
                        o[11] = 0,
                        o[15] = 1,
                        this
                    },
                    equals: function(t) {
                        for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                            if (e[n] !== i[n])
                                return !1;
                        return !0
                    },
                    fromArray: function(t) {
                        return this.elements.set(t),
                        this
                    },
                    toArray: function(t, e) {
                        void 0 === t && (t = []),
                        void 0 === e && (e = 0);
                        var i = this.elements;
                        return t[e] = i[0],
                        t[e + 1] = i[1],
                        t[e + 2] = i[2],
                        t[e + 3] = i[3],
                        t[e + 4] = i[4],
                        t[e + 5] = i[5],
                        t[e + 6] = i[6],
                        t[e + 7] = i[7],
                        t[e + 8] = i[8],
                        t[e + 9] = i[9],
                        t[e + 10] = i[10],
                        t[e + 11] = i[11],
                        t[e + 12] = i[12],
                        t[e + 13] = i[13],
                        t[e + 14] = i[14],
                        t[e + 15] = i[15],
                        t
                    }
                },
                s.prototype = {
                    constructor: s,
                    get x() {
                        return this._x
                    },
                    set x(t) {
                        this._x = t,
                        this.onChangeCallback()
                    },
                    get y() {
                        return this._y
                    },
                    set y(t) {
                        this._y = t,
                        this.onChangeCallback()
                    },
                    get z() {
                        return this._z
                    },
                    set z(t) {
                        this._z = t,
                        this.onChangeCallback()
                    },
                    get w() {
                        return this._w
                    },
                    set w(t) {
                        this._w = t,
                        this.onChangeCallback()
                    },
                    set: function(t, e, i, n) {
                        return this._x = t,
                        this._y = e,
                        this._z = i,
                        this._w = n,
                        this.onChangeCallback(),
                        this
                    },
                    clone: function() {
                        return new this.constructor(this._x,this._y,this._z,this._w)
                    },
                    copy: function(t) {
                        return this._x = t.x,
                        this._y = t.y,
                        this._z = t.z,
                        this._w = t.w,
                        this.onChangeCallback(),
                        this
                    },
                    setFromEuler: function(t, e) {
                        if ((t && t.isEuler) === !1)
                            throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                        var i = Math.cos(t._x / 2)
                          , n = Math.cos(t._y / 2)
                          , r = Math.cos(t._z / 2)
                          , a = Math.sin(t._x / 2)
                          , o = Math.sin(t._y / 2)
                          , s = Math.sin(t._z / 2)
                          , l = t.order;
                        return "XYZ" === l ? (this._x = a * n * r + i * o * s,
                        this._y = i * o * r - a * n * s,
                        this._z = i * n * s + a * o * r,
                        this._w = i * n * r - a * o * s) : "YXZ" === l ? (this._x = a * n * r + i * o * s,
                        this._y = i * o * r - a * n * s,
                        this._z = i * n * s - a * o * r,
                        this._w = i * n * r + a * o * s) : "ZXY" === l ? (this._x = a * n * r - i * o * s,
                        this._y = i * o * r + a * n * s,
                        this._z = i * n * s + a * o * r,
                        this._w = i * n * r - a * o * s) : "ZYX" === l ? (this._x = a * n * r - i * o * s,
                        this._y = i * o * r + a * n * s,
                        this._z = i * n * s - a * o * r,
                        this._w = i * n * r + a * o * s) : "YZX" === l ? (this._x = a * n * r + i * o * s,
                        this._y = i * o * r + a * n * s,
                        this._z = i * n * s - a * o * r,
                        this._w = i * n * r - a * o * s) : "XZY" === l && (this._x = a * n * r - i * o * s,
                        this._y = i * o * r - a * n * s,
                        this._z = i * n * s + a * o * r,
                        this._w = i * n * r + a * o * s),
                        e !== !1 && this.onChangeCallback(),
                        this
                    },
                    setFromAxisAngle: function(t, e) {
                        var i = e / 2
                          , n = Math.sin(i);
                        return this._x = t.x * n,
                        this._y = t.y * n,
                        this._z = t.z * n,
                        this._w = Math.cos(i),
                        this.onChangeCallback(),
                        this
                    },
                    setFromRotationMatrix: function(t) {
                        var e, i = t.elements, n = i[0], r = i[4], a = i[8], o = i[1], s = i[5], l = i[9], h = i[2], c = i[6], u = i[10], p = n + s + u;
                        return p > 0 ? (e = .5 / Math.sqrt(p + 1),
                        this._w = .25 / e,
                        this._x = (c - l) * e,
                        this._y = (a - h) * e,
                        this._z = (o - r) * e) : n > s && n > u ? (e = 2 * Math.sqrt(1 + n - s - u),
                        this._w = (c - l) / e,
                        this._x = .25 * e,
                        this._y = (r + o) / e,
                        this._z = (a + h) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - n - u),
                        this._w = (a - h) / e,
                        this._x = (r + o) / e,
                        this._y = .25 * e,
                        this._z = (l + c) / e) : (e = 2 * Math.sqrt(1 + u - n - s),
                        this._w = (o - r) / e,
                        this._x = (a + h) / e,
                        this._y = (l + c) / e,
                        this._z = .25 * e),
                        this.onChangeCallback(),
                        this
                    },
                    setFromUnitVectors: function() {
                        var t, e, i = 1e-6;
                        return function(n, r) {
                            return void 0 === t && (t = new l),
                            e = n.dot(r) + 1,
                            e < i ? (e = 0,
                            Math.abs(n.x) > Math.abs(n.z) ? t.set(-n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, r),
                            this._x = t.x,
                            this._y = t.y,
                            this._z = t.z,
                            this._w = e,
                            this.normalize()
                        }
                    }(),
                    inverse: function() {
                        return this.conjugate().normalize()
                    },
                    conjugate: function() {
                        return this._x *= -1,
                        this._y *= -1,
                        this._z *= -1,
                        this.onChangeCallback(),
                        this
                    },
                    dot: function(t) {
                        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                    },
                    lengthSq: function() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    },
                    length: function() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    },
                    normalize: function() {
                        var t = this.length();
                        return 0 === t ? (this._x = 0,
                        this._y = 0,
                        this._z = 0,
                        this._w = 1) : (t = 1 / t,
                        this._x = this._x * t,
                        this._y = this._y * t,
                        this._z = this._z * t,
                        this._w = this._w * t),
                        this.onChangeCallback(),
                        this
                    },
                    multiply: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
                        this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                    },
                    premultiply: function(t) {
                        return this.multiplyQuaternions(t, this)
                    },
                    multiplyQuaternions: function(t, e) {
                        var i = t._x
                          , n = t._y
                          , r = t._z
                          , a = t._w
                          , o = e._x
                          , s = e._y
                          , l = e._z
                          , h = e._w;
                        return this._x = i * h + a * o + n * l - r * s,
                        this._y = n * h + a * s + r * o - i * l,
                        this._z = r * h + a * l + i * s - n * o,
                        this._w = a * h - i * o - n * s - r * l,
                        this.onChangeCallback(),
                        this
                    },
                    slerp: function(t, e) {
                        if (0 === e)
                            return this;
                        if (1 === e)
                            return this.copy(t);
                        var i = this._x
                          , n = this._y
                          , r = this._z
                          , a = this._w
                          , o = a * t._w + i * t._x + n * t._y + r * t._z;
                        if (o < 0 ? (this._w = -t._w,
                        this._x = -t._x,
                        this._y = -t._y,
                        this._z = -t._z,
                        o = -o) : this.copy(t),
                        o >= 1)
                            return this._w = a,
                            this._x = i,
                            this._y = n,
                            this._z = r,
                            this;
                        var s = Math.sqrt(1 - o * o);
                        if (Math.abs(s) < .001)
                            return this._w = .5 * (a + this._w),
                            this._x = .5 * (i + this._x),
                            this._y = .5 * (n + this._y),
                            this._z = .5 * (r + this._z),
                            this;
                        var l = Math.atan2(s, o)
                          , h = Math.sin((1 - e) * l) / s
                          , c = Math.sin(e * l) / s;
                        return this._w = a * h + this._w * c,
                        this._x = i * h + this._x * c,
                        this._y = n * h + this._y * c,
                        this._z = r * h + this._z * c,
                        this.onChangeCallback(),
                        this
                    },
                    equals: function(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                    },
                    fromArray: function(t, e) {
                        return void 0 === e && (e = 0),
                        this._x = t[e],
                        this._y = t[e + 1],
                        this._z = t[e + 2],
                        this._w = t[e + 3],
                        this.onChangeCallback(),
                        this
                    },
                    toArray: function(t, e) {
                        return void 0 === t && (t = []),
                        void 0 === e && (e = 0),
                        t[e] = this._x,
                        t[e + 1] = this._y,
                        t[e + 2] = this._z,
                        t[e + 3] = this._w,
                        t
                    },
                    onChange: function(t) {
                        return this.onChangeCallback = t,
                        this
                    },
                    onChangeCallback: function() {}
                },
                Object.assign(s, {
                    slerp: function(t, e, i, n) {
                        return i.copy(t).slerp(e, n)
                    },
                    slerpFlat: function(t, e, i, n, r, a, o) {
                        var s = i[n + 0]
                          , l = i[n + 1]
                          , h = i[n + 2]
                          , c = i[n + 3]
                          , u = r[a + 0]
                          , p = r[a + 1]
                          , d = r[a + 2]
                          , f = r[a + 3];
                        if (c !== f || s !== u || l !== p || h !== d) {
                            var m = 1 - o
                              , g = s * u + l * p + h * d + c * f
                              , v = g >= 0 ? 1 : -1
                              , _ = 1 - g * g;
                            if (_ > Number.EPSILON) {
                                var y = Math.sqrt(_)
                                  , x = Math.atan2(y, g * v);
                                m = Math.sin(m * x) / y,
                                o = Math.sin(o * x) / y
                            }
                            var b = o * v;
                            if (s = s * m + u * b,
                            l = l * m + p * b,
                            h = h * m + d * b,
                            c = c * m + f * b,
                            m === 1 - o) {
                                var w = 1 / Math.sqrt(s * s + l * l + h * h + c * c);
                                s *= w,
                                l *= w,
                                h *= w,
                                c *= w
                            }
                        }
                        t[e] = s,
                        t[e + 1] = l,
                        t[e + 2] = h,
                        t[e + 3] = c
                    }
                }),
                l.prototype = {
                    constructor: l,
                    isVector3: !0,
                    set: function(t, e, i) {
                        return this.x = t,
                        this.y = e,
                        this.z = i,
                        this
                    },
                    setScalar: function(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this
                    },
                    setX: function(t) {
                        return this.x = t,
                        this
                    },
                    setY: function(t) {
                        return this.y = t,
                        this
                    },
                    setZ: function(t) {
                        return this.z = t,
                        this
                    },
                    setComponent: function(t, e) {
                        switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    },
                    getComponent: function(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    },
                    clone: function() {
                        return new this.constructor(this.x,this.y,this.z)
                    },
                    copy: function(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this
                    },
                    add: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(t, e)) : (this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this)
                    },
                    addScalar: function(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this
                    },
                    addVectors: function(t, e) {
                        return this.x = t.x + e.x,
                        this.y = t.y + e.y,
                        this.z = t.z + e.z,
                        this
                    },
                    addScaledVector: function(t, e) {
                        return this.x += t.x * e,
                        this.y += t.y * e,
                        this.z += t.z * e,
                        this
                    },
                    sub: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(t, e)) : (this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this)
                    },
                    subScalar: function(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this
                    },
                    subVectors: function(t, e) {
                        return this.x = t.x - e.x,
                        this.y = t.y - e.y,
                        this.z = t.z - e.z,
                        this
                    },
                    multiply: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
                        this.multiplyVectors(t, e)) : (this.x *= t.x,
                        this.y *= t.y,
                        this.z *= t.z,
                        this)
                    },
                    multiplyScalar: function(t) {
                        return isFinite(t) ? (this.x *= t,
                        this.y *= t,
                        this.z *= t) : (this.x = 0,
                        this.y = 0,
                        this.z = 0),
                        this
                    },
                    multiplyVectors: function(t, e) {
                        return this.x = t.x * e.x,
                        this.y = t.y * e.y,
                        this.z = t.z * e.z,
                        this
                    },
                    applyEuler: function() {
                        var t;
                        return function(e) {
                            return (e && e.isEuler) === !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                            void 0 === t && (t = new s),
                            this.applyQuaternion(t.setFromEuler(e))
                        }
                    }(),
                    applyAxisAngle: function() {
                        var t;
                        return function(e, i) {
                            return void 0 === t && (t = new s),
                            this.applyQuaternion(t.setFromAxisAngle(e, i))
                        }
                    }(),
                    applyMatrix3: function(t) {
                        var e = this.x
                          , i = this.y
                          , n = this.z
                          , r = t.elements;
                        return this.x = r[0] * e + r[3] * i + r[6] * n,
                        this.y = r[1] * e + r[4] * i + r[7] * n,
                        this.z = r[2] * e + r[5] * i + r[8] * n,
                        this
                    },
                    applyMatrix4: function(t) {
                        var e = this.x
                          , i = this.y
                          , n = this.z
                          , r = t.elements;
                        return this.x = r[0] * e + r[4] * i + r[8] * n + r[12],
                        this.y = r[1] * e + r[5] * i + r[9] * n + r[13],
                        this.z = r[2] * e + r[6] * i + r[10] * n + r[14],
                        this
                    },
                    applyProjection: function(t) {
                        var e = this.x
                          , i = this.y
                          , n = this.z
                          , r = t.elements
                          , a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                        return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a,
                        this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a,
                        this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a,
                        this
                    },
                    applyQuaternion: function(t) {
                        var e = this.x
                          , i = this.y
                          , n = this.z
                          , r = t.x
                          , a = t.y
                          , o = t.z
                          , s = t.w
                          , l = s * e + a * n - o * i
                          , h = s * i + o * e - r * n
                          , c = s * n + r * i - a * e
                          , u = -r * e - a * i - o * n;
                        return this.x = l * s + u * -r + h * -o - c * -a,
                        this.y = h * s + u * -a + c * -r - l * -o,
                        this.z = c * s + u * -o + l * -a - h * -r,
                        this
                    },
                    project: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
                            this.applyProjection(t)
                        }
                    }(),
                    unproject: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
                            this.applyProjection(t)
                        }
                    }(),
                    transformDirection: function(t) {
                        var e = this.x
                          , i = this.y
                          , n = this.z
                          , r = t.elements;
                        return this.x = r[0] * e + r[4] * i + r[8] * n,
                        this.y = r[1] * e + r[5] * i + r[9] * n,
                        this.z = r[2] * e + r[6] * i + r[10] * n,
                        this.normalize()
                    },
                    divide: function(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this.z /= t.z,
                        this
                    },
                    divideScalar: function(t) {
                        return this.multiplyScalar(1 / t)
                    },
                    min: function(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this
                    },
                    max: function(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this
                    },
                    clamp: function(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                        this.y = Math.max(t.y, Math.min(e.y, this.y)),
                        this.z = Math.max(t.z, Math.min(e.z, this.z)),
                        this
                    },
                    clampScalar: function() {
                        var t, e;
                        return function(i, n) {
                            return void 0 === t && (t = new l,
                            e = new l),
                            t.set(i, i, i),
                            e.set(n, n, n),
                            this.clamp(t, e)
                        }
                    }(),
                    clampLength: function(t, e) {
                        var i = this.length();
                        return this.multiplyScalar(Math.max(t, Math.min(e, i)) / i)
                    },
                    floor: function() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this
                    },
                    ceil: function() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this
                    },
                    round: function() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this
                    },
                    roundToZero: function() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this
                    },
                    negate: function() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z
                    },
                    lengthSq: function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    },
                    length: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    },
                    lengthManhattan: function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    },
                    normalize: function() {
                        return this.divideScalar(this.length())
                    },
                    setLength: function(t) {
                        return this.multiplyScalar(t / this.length())
                    },
                    lerp: function(t, e) {
                        return this.x += (t.x - this.x) * e,
                        this.y += (t.y - this.y) * e,
                        this.z += (t.z - this.z) * e,
                        this
                    },
                    lerpVectors: function(t, e, i) {
                        return this.subVectors(e, t).multiplyScalar(i).add(t)
                    },
                    cross: function(t, e) {
                        if (void 0 !== e)
                            return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
                            this.crossVectors(t, e);
                        var i = this.x
                          , n = this.y
                          , r = this.z;
                        return this.x = n * t.z - r * t.y,
                        this.y = r * t.x - i * t.z,
                        this.z = i * t.y - n * t.x,
                        this
                    },
                    crossVectors: function(t, e) {
                        var i = t.x
                          , n = t.y
                          , r = t.z
                          , a = e.x
                          , o = e.y
                          , s = e.z;
                        return this.x = n * s - r * o,
                        this.y = r * a - i * s,
                        this.z = i * o - n * a,
                        this
                    },
                    projectOnVector: function(t) {
                        var e = t.dot(this) / t.lengthSq();
                        return this.copy(t).multiplyScalar(e)
                    },
                    projectOnPlane: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new l),
                            t.copy(this).projectOnVector(e),
                            this.sub(t)
                        }
                    }(),
                    reflect: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new l),
                            this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                        }
                    }(),
                    angleTo: function(t) {
                        var i = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                        return Math.acos(e.Math.clamp(i, -1, 1))
                    },
                    distanceTo: function(t) {
                        return Math.sqrt(this.distanceToSquared(t))
                    },
                    distanceToSquared: function(t) {
                        var e = this.x - t.x
                          , i = this.y - t.y
                          , n = this.z - t.z;
                        return e * e + i * i + n * n
                    },
                    distanceToManhattan: function(t) {
                        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                    },
                    setFromSpherical: function(t) {
                        var e = Math.sin(t.phi) * t.radius;
                        return this.x = e * Math.sin(t.theta),
                        this.y = Math.cos(t.phi) * t.radius,
                        this.z = e * Math.cos(t.theta),
                        this
                    },
                    setFromMatrixPosition: function(t) {
                        return this.setFromMatrixColumn(t, 3)
                    },
                    setFromMatrixScale: function(t) {
                        var e = this.setFromMatrixColumn(t, 0).length()
                          , i = this.setFromMatrixColumn(t, 1).length()
                          , n = this.setFromMatrixColumn(t, 2).length();
                        return this.x = e,
                        this.y = i,
                        this.z = n,
                        this
                    },
                    setFromMatrixColumn: function(t, e) {
                        if ("number" == typeof t) {
                            console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                            var i = t;
                            t = e,
                            e = i
                        }
                        return this.fromArray(t.elements, 4 * e)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z
                    },
                    fromArray: function(t, e) {
                        return void 0 === e && (e = 0),
                        this.x = t[e],
                        this.y = t[e + 1],
                        this.z = t[e + 2],
                        this
                    },
                    toArray: function(t, e) {
                        return void 0 === t && (t = []),
                        void 0 === e && (e = 0),
                        t[e] = this.x,
                        t[e + 1] = this.y,
                        t[e + 2] = this.z,
                        t
                    },
                    fromAttribute: function(t, e, i) {
                        return void 0 === i && (i = 0),
                        e = e * t.itemSize + i,
                        this.x = t.array[e],
                        this.y = t.array[e + 1],
                        this.z = t.array[e + 2],
                        this
                    }
                },
                c.prototype = {
                    constructor: c,
                    set: function(t, e) {
                        return this.min.copy(t),
                        this.max.copy(e),
                        this
                    },
                    setFromPoints: function(t) {
                        this.makeEmpty();
                        for (var e = 0, i = t.length; e < i; e++)
                            this.expandByPoint(t[e]);
                        return this
                    },
                    setFromCenterAndSize: function() {
                        var t = new n;
                        return function(e, i) {
                            var n = t.copy(i).multiplyScalar(.5);
                            return this.min.copy(e).sub(n),
                            this.max.copy(e).add(n),
                            this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.min.copy(t.min),
                        this.max.copy(t.max),
                        this
                    },
                    makeEmpty: function() {
                        return this.min.x = this.min.y = +(1 / 0),
                        this.max.x = this.max.y = -(1 / 0),
                        this
                    },
                    isEmpty: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    },
                    center: function(t) {
                        var e = t || new n;
                        return e.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    size: function(t) {
                        var e = t || new n;
                        return e.subVectors(this.max, this.min)
                    },
                    expandByPoint: function(t) {
                        return this.min.min(t),
                        this.max.max(t),
                        this
                    },
                    expandByVector: function(t) {
                        return this.min.sub(t),
                        this.max.add(t),
                        this
                    },
                    expandByScalar: function(t) {
                        return this.min.addScalar(-t),
                        this.max.addScalar(t),
                        this
                    },
                    containsPoint: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    },
                    containsBox: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    },
                    getParameter: function(t, e) {
                        var i = e || new n;
                        return i.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    },
                    intersectsBox: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    },
                    clampPoint: function(t, e) {
                        var i = e || new n;
                        return i.copy(t).clamp(this.min, this.max)
                    },
                    distanceToPoint: function() {
                        var t = new n;
                        return function(e) {
                            var i = t.copy(e).clamp(this.min, this.max);
                            return i.sub(e).length()
                        }
                    }(),
                    intersect: function(t) {
                        return this.min.max(t.min),
                        this.max.min(t.max),
                        this
                    },
                    union: function(t) {
                        return this.min.min(t.min),
                        this.max.max(t.max),
                        this
                    },
                    translate: function(t) {
                        return this.min.add(t),
                        this.max.add(t),
                        this
                    },
                    equals: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                },
                p.prototype = Object.create(r.prototype),
                p.prototype.constructor = p,
                p.prototype.isCubeTexture = !0,
                Object.defineProperty(p.prototype, "images", {
                    get: function() {
                        return this.image
                    },
                    set: function(t) {
                        this.image = t
                    }
                });
                var Po = new r
                  , Ro = new p
                  , Lo = []
                  , Co = [];
                H.prototype.setValue = function(t, e) {
                    for (var i = this.seq, n = 0, r = i.length; n !== r; ++n) {
                        var a = i[n];
                        a.setValue(t, e[a.id])
                    }
                }
                ;
                var Oo = /([\w\d_]+)(\])?(\[|\.)?/g;
                X.prototype.setValue = function(t, e, i) {
                    var n = this.map[e];
                    void 0 !== n && n.setValue(t, i, this.renderer)
                }
                ,
                X.prototype.set = function(t, e, i) {
                    var n = this.map[i];
                    void 0 !== n && n.setValue(t, e[i], this.renderer)
                }
                ,
                X.prototype.setOptional = function(t, e, i) {
                    var n = e[i];
                    void 0 !== n && this.setValue(t, i, n)
                }
                ,
                X.upload = function(t, e, i, n) {
                    for (var r = 0, a = e.length; r !== a; ++r) {
                        var o = e[r]
                          , s = i[o.id];
                        s.needsUpdate !== !1 && o.setValue(t, s.value, n)
                    }
                }
                ,
                X.seqWithValue = function(t, e) {
                    for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                        var a = t[n];
                        a.id in e && i.push(a)
                    }
                    return i
                }
                ,
                X.splitDynamic = function(t, e) {
                    for (var i = null, n = t.length, r = 0, a = 0; a !== n; ++a) {
                        var o = t[a]
                          , s = e[o.id];
                        s && s.dynamic === !0 ? (null === i && (i = []),
                        i.push(o)) : (r < a && (t[r] = o),
                        ++r)
                    }
                    return r < n && (t.length = r),
                    i
                }
                ,
                X.evalDynamic = function(t, e, i, n) {
                    for (var r = 0, a = t.length; r !== a; ++r) {
                        var o = e[t[r].id]
                          , s = o.onUpdateCallback;
                        void 0 !== s && s.call(o, i, n)
                    }
                }
                ,
                q.prototype = {
                    constructor: q,
                    isVector4: !0,
                    set: function(t, e, i, n) {
                        return this.x = t,
                        this.y = e,
                        this.z = i,
                        this.w = n,
                        this
                    },
                    setScalar: function(t) {
                        return this.x = t,
                        this.y = t,
                        this.z = t,
                        this.w = t,
                        this
                    },
                    setX: function(t) {
                        return this.x = t,
                        this
                    },
                    setY: function(t) {
                        return this.y = t,
                        this
                    },
                    setZ: function(t) {
                        return this.z = t,
                        this
                    },
                    setW: function(t) {
                        return this.w = t,
                        this
                    },
                    setComponent: function(t, e) {
                        switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    },
                    getComponent: function(t) {
                        switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                        }
                    },
                    clone: function() {
                        return new this.constructor(this.x,this.y,this.z,this.w)
                    },
                    copy: function(t) {
                        return this.x = t.x,
                        this.y = t.y,
                        this.z = t.z,
                        this.w = void 0 !== t.w ? t.w : 1,
                        this
                    },
                    add: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
                        this.addVectors(t, e)) : (this.x += t.x,
                        this.y += t.y,
                        this.z += t.z,
                        this.w += t.w,
                        this)
                    },
                    addScalar: function(t) {
                        return this.x += t,
                        this.y += t,
                        this.z += t,
                        this.w += t,
                        this
                    },
                    addVectors: function(t, e) {
                        return this.x = t.x + e.x,
                        this.y = t.y + e.y,
                        this.z = t.z + e.z,
                        this.w = t.w + e.w,
                        this
                    },
                    addScaledVector: function(t, e) {
                        return this.x += t.x * e,
                        this.y += t.y * e,
                        this.z += t.z * e,
                        this.w += t.w * e,
                        this
                    },
                    sub: function(t, e) {
                        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
                        this.subVectors(t, e)) : (this.x -= t.x,
                        this.y -= t.y,
                        this.z -= t.z,
                        this.w -= t.w,
                        this)
                    },
                    subScalar: function(t) {
                        return this.x -= t,
                        this.y -= t,
                        this.z -= t,
                        this.w -= t,
                        this
                    },
                    subVectors: function(t, e) {
                        return this.x = t.x - e.x,
                        this.y = t.y - e.y,
                        this.z = t.z - e.z,
                        this.w = t.w - e.w,
                        this
                    },
                    multiplyScalar: function(t) {
                        return isFinite(t) ? (this.x *= t,
                        this.y *= t,
                        this.z *= t,
                        this.w *= t) : (this.x = 0,
                        this.y = 0,
                        this.z = 0,
                        this.w = 0),
                        this
                    },
                    applyMatrix4: function(t) {
                        var e = this.x
                          , i = this.y
                          , n = this.z
                          , r = this.w
                          , a = t.elements;
                        return this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r,
                        this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r,
                        this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r,
                        this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r,
                        this
                    },
                    divideScalar: function(t) {
                        return this.multiplyScalar(1 / t)
                    },
                    setAxisAngleFromQuaternion: function(t) {
                        this.w = 2 * Math.acos(t.w);
                        var e = Math.sqrt(1 - t.w * t.w);
                        return e < 1e-4 ? (this.x = 1,
                        this.y = 0,
                        this.z = 0) : (this.x = t.x / e,
                        this.y = t.y / e,
                        this.z = t.z / e),
                        this
                    },
                    setAxisAngleFromRotationMatrix: function(t) {
                        var e, i, n, r, a = .01, o = .1, s = t.elements, l = s[0], h = s[4], c = s[8], u = s[1], p = s[5], d = s[9], f = s[2], m = s[6], g = s[10];
                        if (Math.abs(h - u) < a && Math.abs(c - f) < a && Math.abs(d - m) < a) {
                            if (Math.abs(h + u) < o && Math.abs(c + f) < o && Math.abs(d + m) < o && Math.abs(l + p + g - 3) < o)
                                return this.set(1, 0, 0, 0),
                                this;
                            e = Math.PI;
                            var v = (l + 1) / 2
                              , _ = (p + 1) / 2
                              , y = (g + 1) / 2
                              , x = (h + u) / 4
                              , b = (c + f) / 4
                              , w = (d + m) / 4;
                            return v > _ && v > y ? v < a ? (i = 0,
                            n = .707106781,
                            r = .707106781) : (i = Math.sqrt(v),
                            n = x / i,
                            r = b / i) : _ > y ? _ < a ? (i = .707106781,
                            n = 0,
                            r = .707106781) : (n = Math.sqrt(_),
                            i = x / n,
                            r = w / n) : y < a ? (i = .707106781,
                            n = .707106781,
                            r = 0) : (r = Math.sqrt(y),
                            i = b / r,
                            n = w / r),
                            this.set(i, n, r, e),
                            this
                        }
                        var M = Math.sqrt((m - d) * (m - d) + (c - f) * (c - f) + (u - h) * (u - h));
                        return Math.abs(M) < .001 && (M = 1),
                        this.x = (m - d) / M,
                        this.y = (c - f) / M,
                        this.z = (u - h) / M,
                        this.w = Math.acos((l + p + g - 1) / 2),
                        this
                    },
                    min: function(t) {
                        return this.x = Math.min(this.x, t.x),
                        this.y = Math.min(this.y, t.y),
                        this.z = Math.min(this.z, t.z),
                        this.w = Math.min(this.w, t.w),
                        this
                    },
                    max: function(t) {
                        return this.x = Math.max(this.x, t.x),
                        this.y = Math.max(this.y, t.y),
                        this.z = Math.max(this.z, t.z),
                        this.w = Math.max(this.w, t.w),
                        this
                    },
                    clamp: function(t, e) {
                        return this.x = Math.max(t.x, Math.min(e.x, this.x)),
                        this.y = Math.max(t.y, Math.min(e.y, this.y)),
                        this.z = Math.max(t.z, Math.min(e.z, this.z)),
                        this.w = Math.max(t.w, Math.min(e.w, this.w)),
                        this
                    },
                    clampScalar: function() {
                        var t, e;
                        return function(i, n) {
                            return void 0 === t && (t = new q,
                            e = new q),
                            t.set(i, i, i, i),
                            e.set(n, n, n, n),
                            this.clamp(t, e)
                        }
                    }(),
                    floor: function() {
                        return this.x = Math.floor(this.x),
                        this.y = Math.floor(this.y),
                        this.z = Math.floor(this.z),
                        this.w = Math.floor(this.w),
                        this
                    },
                    ceil: function() {
                        return this.x = Math.ceil(this.x),
                        this.y = Math.ceil(this.y),
                        this.z = Math.ceil(this.z),
                        this.w = Math.ceil(this.w),
                        this
                    },
                    round: function() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this.z = Math.round(this.z),
                        this.w = Math.round(this.w),
                        this
                    },
                    roundToZero: function() {
                        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
                        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
                        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
                        this
                    },
                    negate: function() {
                        return this.x = -this.x,
                        this.y = -this.y,
                        this.z = -this.z,
                        this.w = -this.w,
                        this
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    },
                    lengthSq: function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    },
                    length: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    },
                    lengthManhattan: function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    },
                    normalize: function() {
                        return this.divideScalar(this.length())
                    },
                    setLength: function(t) {
                        return this.multiplyScalar(t / this.length())
                    },
                    lerp: function(t, e) {
                        return this.x += (t.x - this.x) * e,
                        this.y += (t.y - this.y) * e,
                        this.z += (t.z - this.z) * e,
                        this.w += (t.w - this.w) * e,
                        this
                    },
                    lerpVectors: function(t, e, i) {
                        return this.subVectors(e, t).multiplyScalar(i).add(t)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                    },
                    fromArray: function(t, e) {
                        return void 0 === e && (e = 0),
                        this.x = t[e],
                        this.y = t[e + 1],
                        this.z = t[e + 2],
                        this.w = t[e + 3],
                        this
                    },
                    toArray: function(t, e) {
                        return void 0 === t && (t = []),
                        void 0 === e && (e = 0),
                        t[e] = this.x,
                        t[e + 1] = this.y,
                        t[e + 2] = this.z,
                        t[e + 3] = this.w,
                        t
                    },
                    fromAttribute: function(t, e, i) {
                        return void 0 === i && (i = 0),
                        e = e * t.itemSize + i,
                        this.x = t.array[e],
                        this.y = t.array[e + 1],
                        this.z = t.array[e + 2],
                        this.w = t.array[e + 3],
                        this
                    }
                },
                Object.assign(Q.prototype, i.prototype, {
                    isWebGLRenderTarget: !0,
                    setSize: function(t, e) {
                        this.width === t && this.height === e || (this.width = t,
                        this.height = e,
                        this.dispose()),
                        this.viewport.set(0, 0, t, e),
                        this.scissor.set(0, 0, t, e)
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.width = t.width,
                        this.height = t.height,
                        this.viewport.copy(t.viewport),
                        this.texture = t.texture.clone(),
                        this.depthBuffer = t.depthBuffer,
                        this.stencilBuffer = t.stencilBuffer,
                        this.depthTexture = t.depthTexture,
                        this
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }),
                J.prototype = {
                    constructor: J,
                    isMaterial: !0,
                    get needsUpdate() {
                        return this._needsUpdate
                    },
                    set needsUpdate(t) {
                        t === !0 && this.update(),
                        this._needsUpdate = t
                    },
                    setValues: function(t) {
                        if (void 0 !== t)
                            for (var e in t) {
                                var i = t[e];
                                if (void 0 !== i) {
                                    var n = this[e];
                                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : "overdraw" === e ? this[e] = Number(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else
                                    console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                            }
                    },
                    toJSON: function(t) {
                        function e(t) {
                            var e = [];
                            for (var i in t) {
                                var n = t[i];
                                delete n.metadata,
                                e.push(n)
                            }
                            return e
                        }
                        var i = void 0 === t;
                        i && (t = {
                            textures: {},
                            images: {}
                        });
                        var n = {
                            metadata: {
                                version: 4.4,
                                type: "Material",
                                generator: "Material.toJSON"
                            }
                        };
                        if (n.uuid = this.uuid,
                        n.type = this.type,
                        "" !== this.name && (n.name = this.name),
                        this.color && this.color.isColor && (n.color = this.color.getHex()),
                        void 0 !== this.roughness && (n.roughness = this.roughness),
                        void 0 !== this.metalness && (n.metalness = this.metalness),
                        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                        void 0 !== this.shininess && (n.shininess = this.shininess),
                        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
                        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid),
                        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
                        n.bumpScale = this.bumpScale),
                        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
                        n.normalScale = this.normalScale.toArray()),
                        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
                        n.displacementScale = this.displacementScale,
                        n.displacementBias = this.displacementBias),
                        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
                        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
                        n.reflectivity = this.reflectivity),
                        void 0 !== this.size && (n.size = this.size),
                        void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                        this.blending !== Rr && (n.blending = this.blending),
                        this.shading !== Tr && (n.shading = this.shading),
                        this.side !== xr && (n.side = this.side),
                        this.vertexColors !== Sr && (n.vertexColors = this.vertexColors),
                        this.opacity < 1 && (n.opacity = this.opacity),
                        this.transparent === !0 && (n.transparent = this.transparent),
                        n.depthFunc = this.depthFunc,
                        n.depthTest = this.depthTest,
                        n.depthWrite = this.depthWrite,
                        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha),
                        this.wireframe === !0 && (n.wireframe = this.wireframe),
                        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                        "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                        "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                        n.skinning = this.skinning,
                        n.morphTargets = this.morphTargets,
                        i) {
                            var r = e(t.textures)
                              , a = e(t.images);
                            r.length > 0 && (n.textures = r),
                            a.length > 0 && (n.images = a)
                        }
                        return n
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        this.name = t.name,
                        this.fog = t.fog,
                        this.lights = t.lights,
                        this.blending = t.blending,
                        this.side = t.side,
                        this.shading = t.shading,
                        this.vertexColors = t.vertexColors,
                        this.opacity = t.opacity,
                        this.transparent = t.transparent,
                        this.blendSrc = t.blendSrc,
                        this.blendDst = t.blendDst,
                        this.blendEquation = t.blendEquation,
                        this.blendSrcAlpha = t.blendSrcAlpha,
                        this.blendDstAlpha = t.blendDstAlpha,
                        this.blendEquationAlpha = t.blendEquationAlpha,
                        this.depthFunc = t.depthFunc,
                        this.depthTest = t.depthTest,
                        this.depthWrite = t.depthWrite,
                        this.colorWrite = t.colorWrite,
                        this.precision = t.precision,
                        this.polygonOffset = t.polygonOffset,
                        this.polygonOffsetFactor = t.polygonOffsetFactor,
                        this.polygonOffsetUnits = t.polygonOffsetUnits,
                        this.alphaTest = t.alphaTest,
                        this.premultipliedAlpha = t.premultipliedAlpha,
                        this.overdraw = t.overdraw,
                        this.visible = t.visible,
                        this.clipShadows = t.clipShadows;
                        var e = t.clippingPlanes
                          , i = null;
                        if (null !== e) {
                            var n = e.length;
                            i = new Array(n);
                            for (var r = 0; r !== n; ++r)
                                i[r] = e[r].clone()
                        }
                        return this.clippingPlanes = i,
                        this
                    },
                    update: function() {
                        this.dispatchEvent({
                            type: "update"
                        })
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                },
                Object.assign(J.prototype, i.prototype);
                var Io = 0;
                e.UniformsUtils = {
                    merge: function(t) {
                        for (var e = {}, i = 0; i < t.length; i++) {
                            var n = this.clone(t[i]);
                            for (var r in n)
                                e[r] = n[r]
                        }
                        return e
                    },
                    clone: function(t) {
                        var e = {};
                        for (var i in t) {
                            e[i] = {};
                            for (var n in t[i]) {
                                var r = t[i][n];
                                r && r.isColor || r && r.isVector2 || r && r.isVector3 || r && r.isVector4 || r && r.isMatrix3 || r && r.isMatrix4 || r && r.isTexture ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                            }
                        }
                        return e
                    }
                },
                $.prototype = Object.create(J.prototype),
                $.prototype.constructor = $,
                $.prototype.isShaderMaterial = !0,
                $.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.fragmentShader = t.fragmentShader,
                    this.vertexShader = t.vertexShader,
                    this.uniforms = e.UniformsUtils.clone(t.uniforms),
                    this.defines = t.defines,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.lights = t.lights,
                    this.clipping = t.clipping,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this.extensions = t.extensions,
                    this
                }
                ,
                $.prototype.toJSON = function(t) {
                    var e = J.prototype.toJSON.call(this, t);
                    return e.uniforms = this.uniforms,
                    e.vertexShader = this.vertexShader,
                    e.fragmentShader = this.fragmentShader,
                    e
                }
                ;
                var Do = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n"
                  , Uo = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n"
                  , Fo = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n"
                  , No = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n"
                  , zo = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif"
                  , Bo = "\nvec3 transformed = vec3( position );\n"
                  , ko = "\nvec3 objectNormal = vec3( normal );\n"
                  , Go = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n"
                  , Vo = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n"
                  , Ho = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n"
                  , jo = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n"
                  , Wo = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n"
                  , Xo = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n"
                  , Yo = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif"
                  , qo = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n"
                  , Zo = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif"
                  , Qo = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif"
                  , Jo = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n"
                  , Ko = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n"
                  , $o = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n"
                  , ts = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n"
                  , es = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n"
                  , is = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n"
                  , ns = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n"
                  , rs = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n"
                  , as = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n"
                  , os = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n"
                  , ss = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n"
                  , ls = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n"
                  , hs = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n"
                  , cs = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n"
                  , us = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif"
                  , ps = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n"
                  , ds = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"
                  , fs = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n"
                  , ms = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n"
                  , gs = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n"
                  , vs = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n"
                  , _s = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n"
                  , ys = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n"
                  , xs = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n"
                  , bs = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif"
                  , ws = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n"
                  , Ms = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif"
                  , Ts = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n"
                  , Ss = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n"
                  , Es = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n"
                  , As = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n"
                  , Ps = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n"
                  , Rs = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n"
                  , Ls = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif"
                  , Cs = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n"
                  , Os = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif"
                  , Is = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n"
                  , Ds = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n"
                  , Us = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n"
                  , Fs = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n"
                  , Ns = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n"
                  , zs = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n"
                  , Bs = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n"
                  , ks = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n"
                  , Gs = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"
                  , Vs = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n"
                  , Hs = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n"
                  , js = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n"
                  , Ws = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n"
                  , Xs = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif"
                  , Ys = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n"
                  , qs = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n"
                  , Zs = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n"
                  , Qs = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif"
                  , Js = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif"
                  , Ks = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n"
                  , $s = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n"
                  , tl = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif"
                  , el = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n"
                  , il = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif"
                  , nl = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif"
                  , rl = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif"
                  , al = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif"
                  , ol = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n"
                  , sl = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n"
                  , ll = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n"
                  , hl = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n"
                  , cl = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n"
                  , ul = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n"
                  , pl = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n"
                  , dl = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n"
                  , fl = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n"
                  , ml = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
                  , gl = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n"
                  , vl = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
                  , _l = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n"
                  , yl = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
                  , xl = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n"
                  , bl = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
                  , wl = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n"
                  , Ml = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
                  , Tl = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
                  , Sl = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n"
                  , El = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n"
                  , Al = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n"
                  , Pl = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
                  , Rl = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n"
                  , Ll = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
                  , Cl = {
                    alphamap_fragment: Do,
                    alphamap_pars_fragment: Uo,
                    alphatest_fragment: Fo,
                    aomap_fragment: No,
                    aomap_pars_fragment: zo,
                    begin_vertex: Bo,
                    beginnormal_vertex: ko,
                    bsdfs: Go,
                    bumpmap_pars_fragment: Vo,
                    clipping_planes_fragment: Ho,
                    clipping_planes_pars_fragment: jo,
                    clipping_planes_pars_vertex: Wo,
                    clipping_planes_vertex: Xo,
                    color_fragment: Yo,
                    color_pars_fragment: qo,
                    color_pars_vertex: Zo,
                    color_vertex: Qo,
                    common: Jo,
                    cube_uv_reflection_fragment: Ko,
                    defaultnormal_vertex: $o,
                    displacementmap_pars_vertex: ts,
                    displacementmap_vertex: es,
                    emissivemap_fragment: is,
                    emissivemap_pars_fragment: ns,
                    encodings_fragment: rs,
                    encodings_pars_fragment: as,
                    envmap_fragment: os,
                    envmap_pars_fragment: ss,
                    envmap_pars_vertex: ls,
                    envmap_vertex: hs,
                    fog_fragment: cs,
                    fog_pars_fragment: us,
                    lightmap_fragment: ps,
                    lightmap_pars_fragment: ds,
                    lights_lambert_vertex: fs,
                    lights_pars: ms,
                    lights_phong_fragment: gs,
                    lights_phong_pars_fragment: vs,
                    lights_physical_fragment: _s,
                    lights_physical_pars_fragment: ys,
                    lights_template: xs,
                    logdepthbuf_fragment: bs,
                    logdepthbuf_pars_fragment: ws,
                    logdepthbuf_pars_vertex: Ms,
                    logdepthbuf_vertex: Ts,
                    map_fragment: Ss,
                    map_pars_fragment: Es,
                    map_particle_fragment: As,
                    map_particle_pars_fragment: Ps,
                    metalnessmap_fragment: Rs,
                    metalnessmap_pars_fragment: Ls,
                    morphnormal_vertex: Cs,
                    morphtarget_pars_vertex: Os,
                    morphtarget_vertex: Is,
                    normal_flip: Ds,
                    normal_fragment: Us,
                    normalmap_pars_fragment: Fs,
                    packing: Ns,
                    premultiplied_alpha_fragment: zs,
                    project_vertex: Bs,
                    roughnessmap_fragment: ks,
                    roughnessmap_pars_fragment: Gs,
                    shadowmap_pars_fragment: Vs,
                    shadowmap_pars_vertex: Hs,
                    shadowmap_vertex: js,
                    shadowmask_pars_fragment: Ws,
                    skinbase_vertex: Xs,
                    skinning_pars_vertex: Ys,
                    skinning_vertex: qs,
                    skinnormal_vertex: Zs,
                    specularmap_fragment: Qs,
                    specularmap_pars_fragment: Js,
                    tonemapping_fragment: Ks,
                    tonemapping_pars_fragment: $s,
                    uv_pars_fragment: tl,
                    uv_pars_vertex: el,
                    uv_vertex: il,
                    uv2_pars_fragment: nl,
                    uv2_pars_vertex: rl,
                    uv2_vertex: al,
                    worldpos_vertex: ol,
                    cube_frag: sl,
                    cube_vert: ll,
                    depth_frag: hl,
                    depth_vert: cl,
                    distanceRGBA_frag: ul,
                    distanceRGBA_vert: pl,
                    equirect_frag: dl,
                    equirect_vert: fl,
                    linedashed_frag: ml,
                    linedashed_vert: gl,
                    meshbasic_frag: vl,
                    meshbasic_vert: _l,
                    meshlambert_frag: yl,
                    meshlambert_vert: xl,
                    meshphong_frag: bl,
                    meshphong_vert: wl,
                    meshphysical_frag: Ml,
                    meshphysical_vert: Tl,
                    normal_frag: Sl,
                    normal_vert: El,
                    points_frag: Al,
                    points_vert: Pl,
                    shadow_frag: Rl,
                    shadow_vert: Ll
                };
                tt.prototype = {
                    constructor: tt,
                    isColor: !0,
                    r: 1,
                    g: 1,
                    b: 1,
                    set: function(t) {
                        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
                        this
                    },
                    setScalar: function(t) {
                        this.r = t,
                        this.g = t,
                        this.b = t
                    },
                    setHex: function(t) {
                        return t = Math.floor(t),
                        this.r = (t >> 16 & 255) / 255,
                        this.g = (t >> 8 & 255) / 255,
                        this.b = (255 & t) / 255,
                        this
                    },
                    setRGB: function(t, e, i) {
                        return this.r = t,
                        this.g = e,
                        this.b = i,
                        this
                    },
                    setHSL: function() {
                        function t(t, e, i) {
                            return i < 0 && (i += 1),
                            i > 1 && (i -= 1),
                            i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                        }
                        return function(i, n, r) {
                            if (i = e.Math.euclideanModulo(i, 1),
                            n = e.Math.clamp(n, 0, 1),
                            r = e.Math.clamp(r, 0, 1),
                            0 === n)
                                this.r = this.g = this.b = r;
                            else {
                                var a = r <= .5 ? r * (1 + n) : r + n - r * n
                                  , o = 2 * r - a;
                                this.r = t(o, a, i + 1 / 3),
                                this.g = t(o, a, i),
                                this.b = t(o, a, i - 1 / 3)
                            }
                            return this
                        }
                    }(),
                    setStyle: function(t) {
                        function i(e) {
                            void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                        }
                        var n;
                        if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                            var r, a = n[1], o = n[2];
                            switch (a) {
                            case "rgb":
                            case "rgba":
                                if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                                    return this.r = Math.min(255, parseInt(r[1], 10)) / 255,
                                    this.g = Math.min(255, parseInt(r[2], 10)) / 255,
                                    this.b = Math.min(255, parseInt(r[3], 10)) / 255,
                                    i(r[5]),
                                    this;
                                if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))
                                    return this.r = Math.min(100, parseInt(r[1], 10)) / 100,
                                    this.g = Math.min(100, parseInt(r[2], 10)) / 100,
                                    this.b = Math.min(100, parseInt(r[3], 10)) / 100,
                                    i(r[5]),
                                    this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var s = parseFloat(r[1]) / 360
                                      , l = parseInt(r[2], 10) / 100
                                      , h = parseInt(r[3], 10) / 100;
                                    return i(r[5]),
                                    this.setHSL(s, l, h)
                                }
                            }
                        } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                            var c = n[1]
                              , u = c.length;
                            if (3 === u)
                                return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255,
                                this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255,
                                this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255,
                                this;
                            if (6 === u)
                                return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255,
                                this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255,
                                this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255,
                                this
                        }
                        if (t && t.length > 0) {
                            var c = e.ColorKeywords[t];
                            void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + t)
                        }
                        return this
                    },
                    clone: function() {
                        return new this.constructor(this.r,this.g,this.b)
                    },
                    copy: function(t) {
                        return this.r = t.r,
                        this.g = t.g,
                        this.b = t.b,
                        this
                    },
                    copyGammaToLinear: function(t, e) {
                        return void 0 === e && (e = 2),
                        this.r = Math.pow(t.r, e),
                        this.g = Math.pow(t.g, e),
                        this.b = Math.pow(t.b, e),
                        this
                    },
                    copyLinearToGamma: function(t, e) {
                        void 0 === e && (e = 2);
                        var i = e > 0 ? 1 / e : 1;
                        return this.r = Math.pow(t.r, i),
                        this.g = Math.pow(t.g, i),
                        this.b = Math.pow(t.b, i),
                        this
                    },
                    convertGammaToLinear: function() {
                        var t = this.r
                          , e = this.g
                          , i = this.b;
                        return this.r = t * t,
                        this.g = e * e,
                        this.b = i * i,
                        this
                    },
                    convertLinearToGamma: function() {
                        return this.r = Math.sqrt(this.r),
                        this.g = Math.sqrt(this.g),
                        this.b = Math.sqrt(this.b),
                        this
                    },
                    getHex: function() {
                        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                    },
                    getHexString: function() {
                        return ("000000" + this.getHex().toString(16)).slice(-6)
                    },
                    getHSL: function(t) {
                        var e, i, n = t || {
                            h: 0,
                            s: 0,
                            l: 0
                        }, r = this.r, a = this.g, o = this.b, s = Math.max(r, a, o), l = Math.min(r, a, o), h = (l + s) / 2;
                        if (l === s)
                            e = 0,
                            i = 0;
                        else {
                            var c = s - l;
                            switch (i = h <= .5 ? c / (s + l) : c / (2 - s - l),
                            s) {
                            case r:
                                e = (a - o) / c + (a < o ? 6 : 0);
                                break;
                            case a:
                                e = (o - r) / c + 2;
                                break;
                            case o:
                                e = (r - a) / c + 4
                            }
                            e /= 6
                        }
                        return n.h = e,
                        n.s = i,
                        n.l = h,
                        n
                    },
                    getStyle: function() {
                        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                    },
                    offsetHSL: function(t, e, i) {
                        var n = this.getHSL();
                        return n.h += t,
                        n.s += e,
                        n.l += i,
                        this.setHSL(n.h, n.s, n.l),
                        this
                    },
                    add: function(t) {
                        return this.r += t.r,
                        this.g += t.g,
                        this.b += t.b,
                        this
                    },
                    addColors: function(t, e) {
                        return this.r = t.r + e.r,
                        this.g = t.g + e.g,
                        this.b = t.b + e.b,
                        this
                    },
                    addScalar: function(t) {
                        return this.r += t,
                        this.g += t,
                        this.b += t,
                        this
                    },
                    sub: function(t) {
                        return this.r = Math.max(0, this.r - t.r),
                        this.g = Math.max(0, this.g - t.g),
                        this.b = Math.max(0, this.b - t.b),
                        this
                    },
                    multiply: function(t) {
                        return this.r *= t.r,
                        this.g *= t.g,
                        this.b *= t.b,
                        this
                    },
                    multiplyScalar: function(t) {
                        return this.r *= t,
                        this.g *= t,
                        this.b *= t,
                        this
                    },
                    lerp: function(t, e) {
                        return this.r += (t.r - this.r) * e,
                        this.g += (t.g - this.g) * e,
                        this.b += (t.b - this.b) * e,
                        this
                    },
                    equals: function(t) {
                        return t.r === this.r && t.g === this.g && t.b === this.b
                    },
                    fromArray: function(t, e) {
                        return void 0 === e && (e = 0),
                        this.r = t[e],
                        this.g = t[e + 1],
                        this.b = t[e + 2],
                        this
                    },
                    toArray: function(t, e) {
                        return void 0 === t && (t = []),
                        void 0 === e && (e = 0),
                        t[e] = this.r,
                        t[e + 1] = this.g,
                        t[e + 2] = this.b,
                        t
                    },
                    toJSON: function() {
                        return this.getHex()
                    }
                },
                e.ColorKeywords = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };
                var Ol = {
                    common: {
                        diffuse: {
                            value: new tt(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        offsetRepeat: {
                            value: new q(0,0,1,1)
                        },
                        specularMap: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new n(1,1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new tt(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new tt(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        offsetRepeat: {
                            value: new q(0,0,1,1)
                        }
                    }
                }
                  , Il = {
                    basic: {
                        uniforms: e.UniformsUtils.merge([Ol.common, Ol.aomap, Ol.fog]),
                        vertexShader: Cl.meshbasic_vert,
                        fragmentShader: Cl.meshbasic_frag
                    },
                    lambert: {
                        uniforms: e.UniformsUtils.merge([Ol.common, Ol.aomap, Ol.lightmap, Ol.emissivemap, Ol.fog, Ol.lights, {
                            emissive: {
                                value: new tt(0)
                            }
                        }]),
                        vertexShader: Cl.meshlambert_vert,
                        fragmentShader: Cl.meshlambert_frag
                    },
                    phong: {
                        uniforms: e.UniformsUtils.merge([Ol.common, Ol.aomap, Ol.lightmap, Ol.emissivemap, Ol.bumpmap, Ol.normalmap, Ol.displacementmap, Ol.fog, Ol.lights, {
                            emissive: {
                                value: new tt(0)
                            },
                            specular: {
                                value: new tt(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Cl.meshphong_vert,
                        fragmentShader: Cl.meshphong_frag
                    },
                    standard: {
                        uniforms: e.UniformsUtils.merge([Ol.common, Ol.aomap, Ol.lightmap, Ol.emissivemap, Ol.bumpmap, Ol.normalmap, Ol.displacementmap, Ol.roughnessmap, Ol.metalnessmap, Ol.fog, Ol.lights, {
                            emissive: {
                                value: new tt(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Cl.meshphysical_vert,
                        fragmentShader: Cl.meshphysical_frag
                    },
                    points: {
                        uniforms: e.UniformsUtils.merge([Ol.points, Ol.fog]),
                        vertexShader: Cl.points_vert,
                        fragmentShader: Cl.points_frag
                    },
                    dashed: {
                        uniforms: e.UniformsUtils.merge([Ol.common, Ol.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Cl.linedashed_vert,
                        fragmentShader: Cl.linedashed_frag
                    },
                    depth: {
                        uniforms: e.UniformsUtils.merge([Ol.common, Ol.displacementmap]),
                        vertexShader: Cl.depth_vert,
                        fragmentShader: Cl.depth_frag
                    },
                    normal: {
                        uniforms: {
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: Cl.normal_vert,
                        fragmentShader: Cl.normal_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: Cl.cube_vert,
                        fragmentShader: Cl.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            }
                        },
                        vertexShader: Cl.equirect_vert,
                        fragmentShader: Cl.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: {
                            lightPos: {
                                value: new l
                            }
                        },
                        vertexShader: Cl.distanceRGBA_vert,
                        fragmentShader: Cl.distanceRGBA_frag
                    }
                };
                Il.physical = {
                    uniforms: e.UniformsUtils.merge([Il.standard.uniforms, {
                        clearCoat: {
                            value: 0
                        },
                        clearCoatRoughness: {
                            value: 0
                        }
                    }]),
                    vertexShader: Cl.meshphysical_vert,
                    fragmentShader: Cl.meshphysical_frag
                },
                et.prototype = Object.create(J.prototype),
                et.prototype.constructor = et,
                et.prototype.isMeshDepthMaterial = !0,
                et.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.depthPacking = t.depthPacking,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.map = t.map,
                    this.alphaMap = t.alphaMap,
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this
                }
                ,
                it.prototype = {
                    constructor: it,
                    isBox3: !0,
                    set: function(t, e) {
                        return this.min.copy(t),
                        this.max.copy(e),
                        this
                    },
                    setFromArray: function(t) {
                        for (var e = +(1 / 0), i = +(1 / 0), n = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = t.length; s < l; s += 3) {
                            var h = t[s]
                              , c = t[s + 1]
                              , u = t[s + 2];
                            h < e && (e = h),
                            c < i && (i = c),
                            u < n && (n = u),
                            h > r && (r = h),
                            c > a && (a = c),
                            u > o && (o = u)
                        }
                        this.min.set(e, i, n),
                        this.max.set(r, a, o)
                    },
                    setFromPoints: function(t) {
                        this.makeEmpty();
                        for (var e = 0, i = t.length; e < i; e++)
                            this.expandByPoint(t[e]);
                        return this
                    },
                    setFromCenterAndSize: function() {
                        var t = new l;
                        return function(e, i) {
                            var n = t.copy(i).multiplyScalar(.5);
                            return this.min.copy(e).sub(n),
                            this.max.copy(e).add(n),
                            this
                        }
                    }(),
                    setFromObject: function() {
                        var t = new l;
                        return function(e) {
                            var i = this;
                            return e.updateMatrixWorld(!0),
                            this.makeEmpty(),
                            e.traverse(function(e) {
                                var n = e.geometry;
                                if (void 0 !== n)
                                    if (n && n.isGeometry)
                                        for (var r = n.vertices, a = 0, o = r.length; a < o; a++)
                                            t.copy(r[a]),
                                            t.applyMatrix4(e.matrixWorld),
                                            i.expandByPoint(t);
                                    else if (n && n.isBufferGeometry) {
                                        var s = n.attributes.position;
                                        if (void 0 !== s) {
                                            var l, h, c;
                                            s && s.isInterleavedBufferAttribute ? (l = s.data.array,
                                            h = s.offset,
                                            c = s.data.stride) : (l = s.array,
                                            h = 0,
                                            c = 3);
                                            for (var a = h, o = l.length; a < o; a += c)
                                                t.fromArray(l, a),
                                                t.applyMatrix4(e.matrixWorld),
                                                i.expandByPoint(t)
                                        }
                                    }
                            }),
                            this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.min.copy(t.min),
                        this.max.copy(t.max),
                        this
                    },
                    makeEmpty: function() {
                        return this.min.x = this.min.y = this.min.z = +(1 / 0),
                        this.max.x = this.max.y = this.max.z = -(1 / 0),
                        this
                    },
                    isEmpty: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                    },
                    center: function(t) {
                        var e = t || new l;
                        return e.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    size: function(t) {
                        var e = t || new l;
                        return e.subVectors(this.max, this.min)
                    },
                    expandByPoint: function(t) {
                        return this.min.min(t),
                        this.max.max(t),
                        this
                    },
                    expandByVector: function(t) {
                        return this.min.sub(t),
                        this.max.add(t),
                        this
                    },
                    expandByScalar: function(t) {
                        return this.min.addScalar(-t),
                        this.max.addScalar(t),
                        this
                    },
                    containsPoint: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                    },
                    containsBox: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                    },
                    getParameter: function(t, e) {
                        var i = e || new l;
                        return i.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                    },
                    intersectsBox: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                    },
                    intersectsSphere: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new l),
                            this.clampPoint(e.center, t),
                            t.distanceToSquared(e.center) <= e.radius * e.radius
                        }
                    }(),
                    intersectsPlane: function(t) {
                        var e, i;
                        return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
                        i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
                        i = t.normal.x * this.min.x),
                        t.normal.y > 0 ? (e += t.normal.y * this.min.y,
                        i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
                        i += t.normal.y * this.min.y),
                        t.normal.z > 0 ? (e += t.normal.z * this.min.z,
                        i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
                        i += t.normal.z * this.min.z),
                        e <= t.constant && i >= t.constant
                    },
                    clampPoint: function(t, e) {
                        var i = e || new l;
                        return i.copy(t).clamp(this.min, this.max)
                    },
                    distanceToPoint: function() {
                        var t = new l;
                        return function(e) {
                            var i = t.copy(e).clamp(this.min, this.max);
                            return i.sub(e).length()
                        }
                    }(),
                    getBoundingSphere: function() {
                        var t = new l;
                        return function(e) {
                            var i = e || new nt;
                            return i.center = this.center(),
                            i.radius = .5 * this.size(t).length(),
                            i
                        }
                    }(),
                    intersect: function(t) {
                        return this.min.max(t.min),
                        this.max.min(t.max),
                        this.isEmpty() && this.makeEmpty(),
                        this
                    },
                    union: function(t) {
                        return this.min.min(t.min),
                        this.max.max(t.max),
                        this
                    },
                    applyMatrix4: function() {
                        var t = [new l, new l, new l, new l, new l, new l, new l, new l];
                        return function(e) {
                            return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                            t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                            t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                            t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                            t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                            t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                            t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                            t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                            this.setFromPoints(t),
                            this)
                        }
                    }(),
                    translate: function(t) {
                        return this.min.add(t),
                        this.max.add(t),
                        this
                    },
                    equals: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                },
                nt.prototype = {
                    constructor: nt,
                    set: function(t, e) {
                        return this.center.copy(t),
                        this.radius = e,
                        this
                    },
                    setFromPoints: function() {
                        var t = new it;
                        return function(e, i) {
                            var n = this.center;
                            void 0 !== i ? n.copy(i) : t.setFromPoints(e).center(n);
                            for (var r = 0, a = 0, o = e.length; a < o; a++)
                                r = Math.max(r, n.distanceToSquared(e[a]));
                            return this.radius = Math.sqrt(r),
                            this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.center.copy(t.center),
                        this.radius = t.radius,
                        this
                    },
                    empty: function() {
                        return this.radius <= 0
                    },
                    containsPoint: function(t) {
                        return t.distanceToSquared(this.center) <= this.radius * this.radius
                    },
                    distanceToPoint: function(t) {
                        return t.distanceTo(this.center) - this.radius
                    },
                    intersectsSphere: function(t) {
                        var e = this.radius + t.radius;
                        return t.center.distanceToSquared(this.center) <= e * e
                    },
                    intersectsBox: function(t) {
                        return t.intersectsSphere(this)
                    },
                    intersectsPlane: function(t) {
                        return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
                    },
                    clampPoint: function(t, e) {
                        var i = this.center.distanceToSquared(t)
                          , n = e || new l;
                        return n.copy(t),
                        i > this.radius * this.radius && (n.sub(this.center).normalize(),
                        n.multiplyScalar(this.radius).add(this.center)),
                        n
                    },
                    getBoundingBox: function(t) {
                        var e = t || new it;
                        return e.set(this.center, this.center),
                        e.expandByScalar(this.radius),
                        e
                    },
                    applyMatrix4: function(t) {
                        return this.center.applyMatrix4(t),
                        this.radius = this.radius * t.getMaxScaleOnAxis(),
                        this
                    },
                    translate: function(t) {
                        return this.center.add(t),
                        this
                    },
                    equals: function(t) {
                        return t.center.equals(this.center) && t.radius === this.radius
                    }
                },
                rt.prototype = {
                    constructor: rt,
                    isMatrix3: !0,
                    set: function(t, e, i, n, r, a, o, s, l) {
                        var h = this.elements;
                        return h[0] = t,
                        h[1] = n,
                        h[2] = o,
                        h[3] = e,
                        h[4] = r,
                        h[5] = s,
                        h[6] = i,
                        h[7] = a,
                        h[8] = l,
                        this
                    },
                    identity: function() {
                        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).fromArray(this.elements)
                    },
                    copy: function(t) {
                        var e = t.elements;
                        return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]),
                        this
                    },
                    setFromMatrix4: function(t) {
                        var e = t.elements;
                        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
                        this
                    },
                    applyToVector3Array: function() {
                        var t;
                        return function(e, i, n) {
                            void 0 === t && (t = new l),
                            void 0 === i && (i = 0),
                            void 0 === n && (n = e.length);
                            for (var r = 0, a = i; r < n; r += 3,
                            a += 3)
                                t.fromArray(e, a),
                                t.applyMatrix3(this),
                                t.toArray(e, a);
                            return e
                        }
                    }(),
                    applyToBuffer: function() {
                        var t;
                        return function(e, i, n) {
                            void 0 === t && (t = new l),
                            void 0 === i && (i = 0),
                            void 0 === n && (n = e.length / e.itemSize);
                            for (var r = 0, a = i; r < n; r++,
                            a++)
                                t.x = e.getX(a),
                                t.y = e.getY(a),
                                t.z = e.getZ(a),
                                t.applyMatrix3(this),
                                e.setXYZ(t.x, t.y, t.z);
                            return e
                        }
                    }(),
                    multiplyScalar: function(t) {
                        var e = this.elements;
                        return e[0] *= t,
                        e[3] *= t,
                        e[6] *= t,
                        e[1] *= t,
                        e[4] *= t,
                        e[7] *= t,
                        e[2] *= t,
                        e[5] *= t,
                        e[8] *= t,
                        this
                    },
                    determinant: function() {
                        var t = this.elements
                          , e = t[0]
                          , i = t[1]
                          , n = t[2]
                          , r = t[3]
                          , a = t[4]
                          , o = t[5]
                          , s = t[6]
                          , l = t[7]
                          , h = t[8];
                        return e * a * h - e * o * l - i * r * h + i * o * s + n * r * l - n * a * s
                    },
                    getInverse: function(t, e) {
                        t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                        var i = t.elements
                          , n = this.elements
                          , r = i[0]
                          , a = i[1]
                          , o = i[2]
                          , s = i[3]
                          , l = i[4]
                          , h = i[5]
                          , c = i[6]
                          , u = i[7]
                          , p = i[8]
                          , d = p * l - h * u
                          , f = h * c - p * s
                          , m = u * s - l * c
                          , g = r * d + a * f + o * m;
                        if (0 === g) {
                            var v = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                            if (e === !0)
                                throw new Error(v);
                            return console.warn(v),
                            this.identity()
                        }
                        var _ = 1 / g;
                        return n[0] = d * _,
                        n[1] = (o * u - p * a) * _,
                        n[2] = (h * a - o * l) * _,
                        n[3] = f * _,
                        n[4] = (p * r - o * c) * _,
                        n[5] = (o * s - h * r) * _,
                        n[6] = m * _,
                        n[7] = (a * c - u * r) * _,
                        n[8] = (l * r - a * s) * _,
                        this
                    },
                    transpose: function() {
                        var t, e = this.elements;
                        return t = e[1],
                        e[1] = e[3],
                        e[3] = t,
                        t = e[2],
                        e[2] = e[6],
                        e[6] = t,
                        t = e[5],
                        e[5] = e[7],
                        e[7] = t,
                        this
                    },
                    flattenToArrayOffset: function(t, e) {
                        return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."),
                        this.toArray(t, e)
                    },
                    getNormalMatrix: function(t) {
                        return this.setFromMatrix4(t).getInverse(this).transpose()
                    },
                    transposeIntoArray: function(t) {
                        var e = this.elements;
                        return t[0] = e[0],
                        t[1] = e[3],
                        t[2] = e[6],
                        t[3] = e[1],
                        t[4] = e[4],
                        t[5] = e[7],
                        t[6] = e[2],
                        t[7] = e[5],
                        t[8] = e[8],
                        this
                    },
                    fromArray: function(t) {
                        return this.elements.set(t),
                        this
                    },
                    toArray: function(t, e) {
                        void 0 === t && (t = []),
                        void 0 === e && (e = 0);
                        var i = this.elements;
                        return t[e] = i[0],
                        t[e + 1] = i[1],
                        t[e + 2] = i[2],
                        t[e + 3] = i[3],
                        t[e + 4] = i[4],
                        t[e + 5] = i[5],
                        t[e + 6] = i[6],
                        t[e + 7] = i[7],
                        t[e + 8] = i[8],
                        t
                    }
                },
                at.prototype = {
                    constructor: at,
                    set: function(t, e) {
                        return this.normal.copy(t),
                        this.constant = e,
                        this
                    },
                    setComponents: function(t, e, i, n) {
                        return this.normal.set(t, e, i),
                        this.constant = n,
                        this
                    },
                    setFromNormalAndCoplanarPoint: function(t, e) {
                        return this.normal.copy(t),
                        this.constant = -e.dot(this.normal),
                        this
                    },
                    setFromCoplanarPoints: function() {
                        var t = new l
                          , e = new l;
                        return function(i, n, r) {
                            var a = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                            return this.setFromNormalAndCoplanarPoint(a, i),
                            this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.normal.copy(t.normal),
                        this.constant = t.constant,
                        this
                    },
                    normalize: function() {
                        var t = 1 / this.normal.length();
                        return this.normal.multiplyScalar(t),
                        this.constant *= t,
                        this
                    },
                    negate: function() {
                        return this.constant *= -1,
                        this.normal.negate(),
                        this
                    },
                    distanceToPoint: function(t) {
                        return this.normal.dot(t) + this.constant
                    },
                    distanceToSphere: function(t) {
                        return this.distanceToPoint(t.center) - t.radius
                    },
                    projectPoint: function(t, e) {
                        return this.orthoPoint(t, e).sub(t).negate()
                    },
                    orthoPoint: function(t, e) {
                        var i = this.distanceToPoint(t)
                          , n = e || new l;
                        return n.copy(this.normal).multiplyScalar(i)
                    },
                    intersectLine: function() {
                        var t = new l;
                        return function(e, i) {
                            var n = i || new l
                              , r = e.delta(t)
                              , a = this.normal.dot(r);
                            if (0 !== a) {
                                var o = -(e.start.dot(this.normal) + this.constant) / a;
                                if (!(o < 0 || o > 1))
                                    return n.copy(r).multiplyScalar(o).add(e.start)
                            } else if (0 === this.distanceToPoint(e.start))
                                return n.copy(e.start)
                        }
                    }(),
                    intersectsLine: function(t) {
                        var e = this.distanceToPoint(t.start)
                          , i = this.distanceToPoint(t.end);
                        return e < 0 && i > 0 || i < 0 && e > 0
                    },
                    intersectsBox: function(t) {
                        return t.intersectsPlane(this)
                    },
                    intersectsSphere: function(t) {
                        return t.intersectsPlane(this)
                    },
                    coplanarPoint: function(t) {
                        var e = t || new l;
                        return e.copy(this.normal).multiplyScalar(-this.constant)
                    },
                    applyMatrix4: function() {
                        var t = new l
                          , e = new rt;
                        return function(i, n) {
                            var r = this.coplanarPoint(t).applyMatrix4(i)
                              , a = n || e.getNormalMatrix(i)
                              , o = this.normal.applyMatrix3(a).normalize();
                            return this.constant = -r.dot(o),
                            this
                        }
                    }(),
                    translate: function(t) {
                        return this.constant = this.constant - t.dot(this.normal),
                        this
                    },
                    equals: function(t) {
                        return t.normal.equals(this.normal) && t.constant === this.constant
                    }
                },
                ot.prototype = {
                    constructor: ot,
                    set: function(t, e, i, n, r, a) {
                        var o = this.planes;
                        return o[0].copy(t),
                        o[1].copy(e),
                        o[2].copy(i),
                        o[3].copy(n),
                        o[4].copy(r),
                        o[5].copy(a),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        for (var e = this.planes, i = 0; i < 6; i++)
                            e[i].copy(t.planes[i]);
                        return this
                    },
                    setFromMatrix: function(t) {
                        var e = this.planes
                          , i = t.elements
                          , n = i[0]
                          , r = i[1]
                          , a = i[2]
                          , o = i[3]
                          , s = i[4]
                          , l = i[5]
                          , h = i[6]
                          , c = i[7]
                          , u = i[8]
                          , p = i[9]
                          , d = i[10]
                          , f = i[11]
                          , m = i[12]
                          , g = i[13]
                          , v = i[14]
                          , _ = i[15];
                        return e[0].setComponents(o - n, c - s, f - u, _ - m).normalize(),
                        e[1].setComponents(o + n, c + s, f + u, _ + m).normalize(),
                        e[2].setComponents(o + r, c + l, f + p, _ + g).normalize(),
                        e[3].setComponents(o - r, c - l, f - p, _ - g).normalize(),
                        e[4].setComponents(o - a, c - h, f - d, _ - v).normalize(),
                        e[5].setComponents(o + a, c + h, f + d, _ + v).normalize(),
                        this
                    },
                    intersectsObject: function() {
                        var t = new nt;
                        return function(e) {
                            var i = e.geometry;
                            return null === i.boundingSphere && i.computeBoundingSphere(),
                            t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld),
                            this.intersectsSphere(t)
                        }
                    }(),
                    intersectsSprite: function() {
                        var t = new nt;
                        return function(e) {
                            return t.center.set(0, 0, 0),
                            t.radius = .7071067811865476,
                            t.applyMatrix4(e.matrixWorld),
                            this.intersectsSphere(t)
                        }
                    }(),
                    intersectsSphere: function(t) {
                        for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                            var a = e[r].distanceToPoint(i);
                            if (a < n)
                                return !1
                        }
                        return !0
                    },
                    intersectsBox: function() {
                        var t = new l
                          , e = new l;
                        return function(i) {
                            for (var n = this.planes, r = 0; r < 6; r++) {
                                var a = n[r];
                                t.x = a.normal.x > 0 ? i.min.x : i.max.x,
                                e.x = a.normal.x > 0 ? i.max.x : i.min.x,
                                t.y = a.normal.y > 0 ? i.min.y : i.max.y,
                                e.y = a.normal.y > 0 ? i.max.y : i.min.y,
                                t.z = a.normal.z > 0 ? i.min.z : i.max.z,
                                e.z = a.normal.z > 0 ? i.max.z : i.min.z;
                                var o = a.distanceToPoint(t)
                                  , s = a.distanceToPoint(e);
                                if (o < 0 && s < 0)
                                    return !1
                            }
                            return !0
                        }
                    }(),
                    containsPoint: function(t) {
                        for (var e = this.planes, i = 0; i < 6; i++)
                            if (e[i].distanceToPoint(t) < 0)
                                return !1;
                        return !0
                    }
                };
                var Dl = 0;
                Tt.prototype = {
                    constructor: Tt,
                    isBufferAttribute: !0,
                    get count() {
                        return this.array.length / this.itemSize
                    },
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    },
                    setDynamic: function(t) {
                        return this.dynamic = t,
                        this
                    },
                    copy: function(t) {
                        return this.array = new t.array.constructor(t.array),
                        this.itemSize = t.itemSize,
                        this.normalized = t.normalized,
                        this.dynamic = t.dynamic,
                        this
                    },
                    copyAt: function(t, e, i) {
                        t *= this.itemSize,
                        i *= e.itemSize;
                        for (var n = 0, r = this.itemSize; n < r; n++)
                            this.array[t + n] = e.array[i + n];
                        return this
                    },
                    copyArray: function(t) {
                        return this.array.set(t),
                        this
                    },
                    copyColorsArray: function(t) {
                        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                            a = new tt),
                            e[i++] = a.r,
                            e[i++] = a.g,
                            e[i++] = a.b
                        }
                        return this
                    },
                    copyIndicesArray: function(t) {
                        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            e[i++] = a.a,
                            e[i++] = a.b,
                            e[i++] = a.c
                        }
                        return this
                    },
                    copyVector2sArray: function(t) {
                        for (var e = this.array, i = 0, r = 0, a = t.length; r < a; r++) {
                            var o = t[r];
                            void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r),
                            o = new n),
                            e[i++] = o.x,
                            e[i++] = o.y
                        }
                        return this
                    },
                    copyVector3sArray: function(t) {
                        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                            a = new l),
                            e[i++] = a.x,
                            e[i++] = a.y,
                            e[i++] = a.z
                        }
                        return this
                    },
                    copyVector4sArray: function(t) {
                        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                            a = new q),
                            e[i++] = a.x,
                            e[i++] = a.y,
                            e[i++] = a.z,
                            e[i++] = a.w
                        }
                        return this
                    },
                    set: function(t, e) {
                        return void 0 === e && (e = 0),
                        this.array.set(t, e),
                        this
                    },
                    getX: function(t) {
                        return this.array[t * this.itemSize]
                    },
                    setX: function(t, e) {
                        return this.array[t * this.itemSize] = e,
                        this
                    },
                    getY: function(t) {
                        return this.array[t * this.itemSize + 1]
                    },
                    setY: function(t, e) {
                        return this.array[t * this.itemSize + 1] = e,
                        this
                    },
                    getZ: function(t) {
                        return this.array[t * this.itemSize + 2]
                    },
                    setZ: function(t, e) {
                        return this.array[t * this.itemSize + 2] = e,
                        this
                    },
                    getW: function(t) {
                        return this.array[t * this.itemSize + 3]
                    },
                    setW: function(t, e) {
                        return this.array[t * this.itemSize + 3] = e,
                        this
                    },
                    setXY: function(t, e, i) {
                        return t *= this.itemSize,
                        this.array[t + 0] = e,
                        this.array[t + 1] = i,
                        this
                    },
                    setXYZ: function(t, e, i, n) {
                        return t *= this.itemSize,
                        this.array[t + 0] = e,
                        this.array[t + 1] = i,
                        this.array[t + 2] = n,
                        this
                    },
                    setXYZW: function(t, e, i, n, r) {
                        return t *= this.itemSize,
                        this.array[t + 0] = e,
                        this.array[t + 1] = i,
                        this.array[t + 2] = n,
                        this.array[t + 3] = r,
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                },
                Ut.prototype = {
                    constructor: Ut,
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        this.a = t.a,
                        this.b = t.b,
                        this.c = t.c,
                        this.normal.copy(t.normal),
                        this.color.copy(t.color),
                        this.materialIndex = t.materialIndex;
                        for (var e = 0, i = t.vertexNormals.length; e < i; e++)
                            this.vertexNormals[e] = t.vertexNormals[e].clone();
                        for (var e = 0, i = t.vertexColors.length; e < i; e++)
                            this.vertexColors[e] = t.vertexColors[e].clone();
                        return this
                    }
                },
                Ft.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
                Ft.DefaultOrder = "XYZ",
                Ft.prototype = {
                    constructor: Ft,
                    isEuler: !0,
                    get x() {
                        return this._x
                    },
                    set x(t) {
                        this._x = t,
                        this.onChangeCallback()
                    },
                    get y() {
                        return this._y
                    },
                    set y(t) {
                        this._y = t,
                        this.onChangeCallback()
                    },
                    get z() {
                        return this._z
                    },
                    set z(t) {
                        this._z = t,
                        this.onChangeCallback()
                    },
                    get order() {
                        return this._order
                    },
                    set order(t) {
                        this._order = t,
                        this.onChangeCallback()
                    },
                    set: function(t, e, i, n) {
                        return this._x = t,
                        this._y = e,
                        this._z = i,
                        this._order = n || this._order,
                        this.onChangeCallback(),
                        this
                    },
                    clone: function() {
                        return new this.constructor(this._x,this._y,this._z,this._order)
                    },
                    copy: function(t) {
                        return this._x = t._x,
                        this._y = t._y,
                        this._z = t._z,
                        this._order = t._order,
                        this.onChangeCallback(),
                        this
                    },
                    setFromRotationMatrix: function(t, i, n) {
                        var r = e.Math.clamp
                          , a = t.elements
                          , o = a[0]
                          , s = a[4]
                          , l = a[8]
                          , h = a[1]
                          , c = a[5]
                          , u = a[9]
                          , p = a[2]
                          , d = a[6]
                          , f = a[10];
                        return i = i || this._order,
                        "XYZ" === i ? (this._y = Math.asin(r(l, -1, 1)),
                        Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, f),
                        this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, c),
                        this._z = 0)) : "YXZ" === i ? (this._x = Math.asin(-r(u, -1, 1)),
                        Math.abs(u) < .99999 ? (this._y = Math.atan2(l, f),
                        this._z = Math.atan2(h, c)) : (this._y = Math.atan2(-p, o),
                        this._z = 0)) : "ZXY" === i ? (this._x = Math.asin(r(d, -1, 1)),
                        Math.abs(d) < .99999 ? (this._y = Math.atan2(-p, f),
                        this._z = Math.atan2(-s, c)) : (this._y = 0,
                        this._z = Math.atan2(h, o))) : "ZYX" === i ? (this._y = Math.asin(-r(p, -1, 1)),
                        Math.abs(p) < .99999 ? (this._x = Math.atan2(d, f),
                        this._z = Math.atan2(h, o)) : (this._x = 0,
                        this._z = Math.atan2(-s, c))) : "YZX" === i ? (this._z = Math.asin(r(h, -1, 1)),
                        Math.abs(h) < .99999 ? (this._x = Math.atan2(-u, c),
                        this._y = Math.atan2(-p, o)) : (this._x = 0,
                        this._y = Math.atan2(l, f))) : "XZY" === i ? (this._z = Math.asin(-r(s, -1, 1)),
                        Math.abs(s) < .99999 ? (this._x = Math.atan2(d, c),
                        this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-u, f),
                        this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + i),
                        this._order = i,
                        n !== !1 && this.onChangeCallback(),
                        this
                    },
                    setFromQuaternion: function() {
                        var t;
                        return function(e, i, n) {
                            return void 0 === t && (t = new o),
                            t.makeRotationFromQuaternion(e),
                            this.setFromRotationMatrix(t, i, n)
                        }
                    }(),
                    setFromVector3: function(t, e) {
                        return this.set(t.x, t.y, t.z, e || this._order)
                    },
                    reorder: function() {
                        var t = new s;
                        return function(e) {
                            return t.setFromEuler(this),
                            this.setFromQuaternion(t, e)
                        }
                    }(),
                    equals: function(t) {
                        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                    },
                    fromArray: function(t) {
                        return this._x = t[0],
                        this._y = t[1],
                        this._z = t[2],
                        void 0 !== t[3] && (this._order = t[3]),
                        this.onChangeCallback(),
                        this
                    },
                    toArray: function(t, e) {
                        return void 0 === t && (t = []),
                        void 0 === e && (e = 0),
                        t[e] = this._x,
                        t[e + 1] = this._y,
                        t[e + 2] = this._z,
                        t[e + 3] = this._order,
                        t
                    },
                    toVector3: function(t) {
                        return t ? t.set(this._x, this._y, this._z) : new l(this._x,this._y,this._z)
                    },
                    onChange: function(t) {
                        return this.onChangeCallback = t,
                        this
                    },
                    onChangeCallback: function() {}
                },
                Nt.prototype = {
                    constructor: Nt,
                    set: function(t) {
                        this.mask = 1 << t
                    },
                    enable: function(t) {
                        this.mask |= 1 << t;
                    },
                    toggle: function(t) {
                        this.mask ^= 1 << t
                    },
                    disable: function(t) {
                        this.mask &= ~(1 << t)
                    },
                    test: function(t) {
                        return 0 !== (this.mask & t.mask)
                    }
                },
                zt.DefaultUp = new l(0,1,0),
                zt.DefaultMatrixAutoUpdate = !0,
                Object.assign(zt.prototype, i.prototype, {
                    isObject3D: !0,
                    applyMatrix: function(t) {
                        this.matrix.multiplyMatrices(t, this.matrix),
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    },
                    setRotationFromAxisAngle: function(t, e) {
                        this.quaternion.setFromAxisAngle(t, e)
                    },
                    setRotationFromEuler: function(t) {
                        this.quaternion.setFromEuler(t, !0)
                    },
                    setRotationFromMatrix: function(t) {
                        this.quaternion.setFromRotationMatrix(t)
                    },
                    setRotationFromQuaternion: function(t) {
                        this.quaternion.copy(t)
                    },
                    rotateOnAxis: function() {
                        var t = new s;
                        return function(e, i) {
                            return t.setFromAxisAngle(e, i),
                            this.quaternion.multiply(t),
                            this
                        }
                    }(),
                    rotateX: function() {
                        var t = new l(1,0,0);
                        return function(e) {
                            return this.rotateOnAxis(t, e)
                        }
                    }(),
                    rotateY: function() {
                        var t = new l(0,1,0);
                        return function(e) {
                            return this.rotateOnAxis(t, e)
                        }
                    }(),
                    rotateZ: function() {
                        var t = new l(0,0,1);
                        return function(e) {
                            return this.rotateOnAxis(t, e)
                        }
                    }(),
                    translateOnAxis: function() {
                        var t = new l;
                        return function(e, i) {
                            return t.copy(e).applyQuaternion(this.quaternion),
                            this.position.add(t.multiplyScalar(i)),
                            this
                        }
                    }(),
                    translateX: function() {
                        var t = new l(1,0,0);
                        return function(e) {
                            return this.translateOnAxis(t, e)
                        }
                    }(),
                    translateY: function() {
                        var t = new l(0,1,0);
                        return function(e) {
                            return this.translateOnAxis(t, e)
                        }
                    }(),
                    translateZ: function() {
                        var t = new l(0,0,1);
                        return function(e) {
                            return this.translateOnAxis(t, e)
                        }
                    }(),
                    localToWorld: function(t) {
                        return t.applyMatrix4(this.matrixWorld)
                    },
                    worldToLocal: function() {
                        var t = new o;
                        return function(e) {
                            return e.applyMatrix4(t.getInverse(this.matrixWorld))
                        }
                    }(),
                    lookAt: function() {
                        var t = new o;
                        return function(e) {
                            t.lookAt(e, this.position, this.up),
                            this.quaternion.setFromRotationMatrix(t)
                        }
                    }(),
                    add: function(t) {
                        if (arguments.length > 1) {
                            for (var e = 0; e < arguments.length; e++)
                                this.add(arguments[e]);
                            return this
                        }
                        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
                        this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
                        t.parent = this,
                        t.dispatchEvent({
                            type: "added"
                        }),
                        this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
                        this)
                    },
                    remove: function(t) {
                        if (arguments.length > 1)
                            for (var e = 0; e < arguments.length; e++)
                                this.remove(arguments[e]);
                        var i = this.children.indexOf(t);
                        i !== -1 && (t.parent = null,
                        t.dispatchEvent({
                            type: "removed"
                        }),
                        this.children.splice(i, 1))
                    },
                    getObjectById: function(t) {
                        return this.getObjectByProperty("id", t)
                    },
                    getObjectByName: function(t) {
                        return this.getObjectByProperty("name", t)
                    },
                    getObjectByProperty: function(t, e) {
                        if (this[t] === e)
                            return this;
                        for (var i = 0, n = this.children.length; i < n; i++) {
                            var r = this.children[i]
                              , a = r.getObjectByProperty(t, e);
                            if (void 0 !== a)
                                return a
                        }
                    },
                    getWorldPosition: function(t) {
                        var e = t || new l;
                        return this.updateMatrixWorld(!0),
                        e.setFromMatrixPosition(this.matrixWorld)
                    },
                    getWorldQuaternion: function() {
                        var t = new l
                          , e = new l;
                        return function(i) {
                            var n = i || new s;
                            return this.updateMatrixWorld(!0),
                            this.matrixWorld.decompose(t, n, e),
                            n
                        }
                    }(),
                    getWorldRotation: function() {
                        var t = new s;
                        return function(e) {
                            var i = e || new Ft;
                            return this.getWorldQuaternion(t),
                            i.setFromQuaternion(t, this.rotation.order, !1)
                        }
                    }(),
                    getWorldScale: function() {
                        var t = new l
                          , e = new s;
                        return function(i) {
                            var n = i || new l;
                            return this.updateMatrixWorld(!0),
                            this.matrixWorld.decompose(t, e, n),
                            n
                        }
                    }(),
                    getWorldDirection: function() {
                        var t = new s;
                        return function(e) {
                            var i = e || new l;
                            return this.getWorldQuaternion(t),
                            i.set(0, 0, 1).applyQuaternion(t)
                        }
                    }(),
                    raycast: function() {},
                    traverse: function(t) {
                        t(this);
                        for (var e = this.children, i = 0, n = e.length; i < n; i++)
                            e[i].traverse(t)
                    },
                    traverseVisible: function(t) {
                        if (this.visible !== !1) {
                            t(this);
                            for (var e = this.children, i = 0, n = e.length; i < n; i++)
                                e[i].traverseVisible(t)
                        }
                    },
                    traverseAncestors: function(t) {
                        var e = this.parent;
                        null !== e && (t(e),
                        e.traverseAncestors(t))
                    },
                    updateMatrix: function() {
                        this.matrix.compose(this.position, this.quaternion, this.scale),
                        this.matrixWorldNeedsUpdate = !0
                    },
                    updateMatrixWorld: function(t) {
                        this.matrixAutoUpdate === !0 && this.updateMatrix(),
                        this.matrixWorldNeedsUpdate !== !0 && t !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                        this.matrixWorldNeedsUpdate = !1,
                        t = !0);
                        for (var e = this.children, i = 0, n = e.length; i < n; i++)
                            e[i].updateMatrixWorld(t)
                    },
                    toJSON: function(t) {
                        function e(t) {
                            var e = [];
                            for (var i in t) {
                                var n = t[i];
                                delete n.metadata,
                                e.push(n)
                            }
                            return e
                        }
                        var i = void 0 === t || "" === t
                          , n = {};
                        i && (t = {
                            geometries: {},
                            materials: {},
                            textures: {},
                            images: {}
                        },
                        n.metadata = {
                            version: 4.4,
                            type: "Object",
                            generator: "Object3D.toJSON"
                        });
                        var r = {};
                        if (r.uuid = this.uuid,
                        r.type = this.type,
                        "" !== this.name && (r.name = this.name),
                        "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
                        this.castShadow === !0 && (r.castShadow = !0),
                        this.receiveShadow === !0 && (r.receiveShadow = !0),
                        this.visible === !1 && (r.visible = !1),
                        r.matrix = this.matrix.toArray(),
                        void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)),
                        r.geometry = this.geometry.uuid),
                        void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)),
                        r.material = this.material.uuid),
                        this.children.length > 0) {
                            r.children = [];
                            for (var a = 0; a < this.children.length; a++)
                                r.children.push(this.children[a].toJSON(t).object)
                        }
                        if (i) {
                            var o = e(t.geometries)
                              , s = e(t.materials)
                              , l = e(t.textures)
                              , h = e(t.images);
                            o.length > 0 && (n.geometries = o),
                            s.length > 0 && (n.materials = s),
                            l.length > 0 && (n.textures = l),
                            h.length > 0 && (n.images = h)
                        }
                        return n.object = r,
                        n
                    },
                    clone: function(t) {
                        return (new this.constructor).copy(this, t)
                    },
                    copy: function(t, e) {
                        if (void 0 === e && (e = !0),
                        this.name = t.name,
                        this.up.copy(t.up),
                        this.position.copy(t.position),
                        this.quaternion.copy(t.quaternion),
                        this.scale.copy(t.scale),
                        this.matrix.copy(t.matrix),
                        this.matrixWorld.copy(t.matrixWorld),
                        this.matrixAutoUpdate = t.matrixAutoUpdate,
                        this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
                        this.visible = t.visible,
                        this.castShadow = t.castShadow,
                        this.receiveShadow = t.receiveShadow,
                        this.frustumCulled = t.frustumCulled,
                        this.renderOrder = t.renderOrder,
                        this.userData = JSON.parse(JSON.stringify(t.userData)),
                        e === !0)
                            for (var i = 0; i < t.children.length; i++) {
                                var n = t.children[i];
                                this.add(n.clone())
                            }
                        return this
                    }
                });
                var Ul = 0;
                Object.assign(kt.prototype, i.prototype, {
                    isGeometry: !0,
                    applyMatrix: function(t) {
                        for (var e = (new rt).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                            var r = this.vertices[i];
                            r.applyMatrix4(t)
                        }
                        for (var i = 0, n = this.faces.length; i < n; i++) {
                            var a = this.faces[i];
                            a.normal.applyMatrix3(e).normalize();
                            for (var o = 0, s = a.vertexNormals.length; o < s; o++)
                                a.vertexNormals[o].applyMatrix3(e).normalize()
                        }
                        return null !== this.boundingBox && this.computeBoundingBox(),
                        null !== this.boundingSphere && this.computeBoundingSphere(),
                        this.verticesNeedUpdate = !0,
                        this.normalsNeedUpdate = !0,
                        this
                    },
                    rotateX: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.makeRotationX(e),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    rotateY: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.makeRotationY(e),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    rotateZ: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.makeRotationZ(e),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    translate: function() {
                        var t;
                        return function(e, i, n) {
                            return void 0 === t && (t = new o),
                            t.makeTranslation(e, i, n),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    scale: function() {
                        var t;
                        return function(e, i, n) {
                            return void 0 === t && (t = new o),
                            t.makeScale(e, i, n),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    lookAt: function() {
                        var t;
                        return function(e) {
                            void 0 === t && (t = new zt),
                            t.lookAt(e),
                            t.updateMatrix(),
                            this.applyMatrix(t.matrix)
                        }
                    }(),
                    fromBufferGeometry: function(t) {
                        function e(t, e, n, r) {
                            var a = void 0 !== s ? [p[t].clone(), p[e].clone(), p[n].clone()] : []
                              , o = void 0 !== h ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[n].clone()] : []
                              , l = new Ut(t,e,n,a,o,r);
                            i.faces.push(l),
                            void 0 !== c && i.faceVertexUvs[0].push([d[t].clone(), d[e].clone(), d[n].clone()]),
                            void 0 !== u && i.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[n].clone()])
                        }
                        var i = this
                          , r = null !== t.index ? t.index.array : void 0
                          , a = t.attributes
                          , o = a.position.array
                          , s = void 0 !== a.normal ? a.normal.array : void 0
                          , h = void 0 !== a.color ? a.color.array : void 0
                          , c = void 0 !== a.uv ? a.uv.array : void 0
                          , u = void 0 !== a.uv2 ? a.uv2.array : void 0;
                        void 0 !== u && (this.faceVertexUvs[1] = []);
                        for (var p = [], d = [], f = [], m = 0, g = 0; m < o.length; m += 3,
                        g += 2)
                            i.vertices.push(new l(o[m],o[m + 1],o[m + 2])),
                            void 0 !== s && p.push(new l(s[m],s[m + 1],s[m + 2])),
                            void 0 !== h && i.colors.push(new tt(h[m],h[m + 1],h[m + 2])),
                            void 0 !== c && d.push(new n(c[g],c[g + 1])),
                            void 0 !== u && f.push(new n(u[g],u[g + 1]));
                        if (void 0 !== r) {
                            var v = t.groups;
                            if (v.length > 0)
                                for (var m = 0; m < v.length; m++)
                                    for (var _ = v[m], y = _.start, x = _.count, g = y, b = y + x; g < b; g += 3)
                                        e(r[g], r[g + 1], r[g + 2], _.materialIndex);
                            else
                                for (var m = 0; m < r.length; m += 3)
                                    e(r[m], r[m + 1], r[m + 2])
                        } else
                            for (var m = 0; m < o.length / 3; m += 3)
                                e(m, m + 1, m + 2);
                        return this.computeFaceNormals(),
                        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                        this
                    },
                    center: function() {
                        this.computeBoundingBox();
                        var t = this.boundingBox.center().negate();
                        return this.translate(t.x, t.y, t.z),
                        t
                    },
                    normalize: function() {
                        this.computeBoundingSphere();
                        var t = this.boundingSphere.center
                          , e = this.boundingSphere.radius
                          , i = 0 === e ? 1 : 1 / e
                          , n = new o;
                        return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1),
                        this.applyMatrix(n),
                        this
                    },
                    computeFaceNormals: function() {
                        for (var t = new l, e = new l, i = 0, n = this.faces.length; i < n; i++) {
                            var r = this.faces[i]
                              , a = this.vertices[r.a]
                              , o = this.vertices[r.b]
                              , s = this.vertices[r.c];
                            t.subVectors(s, o),
                            e.subVectors(a, o),
                            t.cross(e),
                            t.normalize(),
                            r.normal.copy(t)
                        }
                    },
                    computeVertexNormals: function(t) {
                        void 0 === t && (t = !0);
                        var e, i, n, r, a, o;
                        for (o = new Array(this.vertices.length),
                        e = 0,
                        i = this.vertices.length; e < i; e++)
                            o[e] = new l;
                        if (t) {
                            var s, h, c, u = new l, p = new l;
                            for (n = 0,
                            r = this.faces.length; n < r; n++)
                                a = this.faces[n],
                                s = this.vertices[a.a],
                                h = this.vertices[a.b],
                                c = this.vertices[a.c],
                                u.subVectors(c, h),
                                p.subVectors(s, h),
                                u.cross(p),
                                o[a.a].add(u),
                                o[a.b].add(u),
                                o[a.c].add(u)
                        } else
                            for (n = 0,
                            r = this.faces.length; n < r; n++)
                                a = this.faces[n],
                                o[a.a].add(a.normal),
                                o[a.b].add(a.normal),
                                o[a.c].add(a.normal);
                        for (e = 0,
                        i = this.vertices.length; e < i; e++)
                            o[e].normalize();
                        for (n = 0,
                        r = this.faces.length; n < r; n++) {
                            a = this.faces[n];
                            var d = a.vertexNormals;
                            3 === d.length ? (d[0].copy(o[a.a]),
                            d[1].copy(o[a.b]),
                            d[2].copy(o[a.c])) : (d[0] = o[a.a].clone(),
                            d[1] = o[a.b].clone(),
                            d[2] = o[a.c].clone())
                        }
                        this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                    },
                    computeMorphNormals: function() {
                        var t, e, i, n, r;
                        for (i = 0,
                        n = this.faces.length; i < n; i++)
                            for (r = this.faces[i],
                            r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(),
                            r.__originalVertexNormals || (r.__originalVertexNormals = []),
                            t = 0,
                            e = r.vertexNormals.length; t < e; t++)
                                r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                        var a = new kt;
                        for (a.faces = this.faces,
                        t = 0,
                        e = this.morphTargets.length; t < e; t++) {
                            if (!this.morphNormals[t]) {
                                this.morphNormals[t] = {},
                                this.morphNormals[t].faceNormals = [],
                                this.morphNormals[t].vertexNormals = [];
                                var o, s, h = this.morphNormals[t].faceNormals, c = this.morphNormals[t].vertexNormals;
                                for (i = 0,
                                n = this.faces.length; i < n; i++)
                                    o = new l,
                                    s = {
                                        a: new l,
                                        b: new l,
                                        c: new l
                                    },
                                    h.push(o),
                                    c.push(s)
                            }
                            var u = this.morphNormals[t];
                            a.vertices = this.morphTargets[t].vertices,
                            a.computeFaceNormals(),
                            a.computeVertexNormals();
                            var o, s;
                            for (i = 0,
                            n = this.faces.length; i < n; i++)
                                r = this.faces[i],
                                o = u.faceNormals[i],
                                s = u.vertexNormals[i],
                                o.copy(r.normal),
                                s.a.copy(r.vertexNormals[0]),
                                s.b.copy(r.vertexNormals[1]),
                                s.c.copy(r.vertexNormals[2])
                        }
                        for (i = 0,
                        n = this.faces.length; i < n; i++)
                            r = this.faces[i],
                            r.normal = r.__originalFaceNormal,
                            r.vertexNormals = r.__originalVertexNormals
                    },
                    computeTangents: function() {
                        console.warn("THREE.Geometry: .computeTangents() has been removed.")
                    },
                    computeLineDistances: function() {
                        for (var t = 0, e = this.vertices, i = 0, n = e.length; i < n; i++)
                            i > 0 && (t += e[i].distanceTo(e[i - 1])),
                            this.lineDistances[i] = t
                    },
                    computeBoundingBox: function() {
                        null === this.boundingBox && (this.boundingBox = new it),
                        this.boundingBox.setFromPoints(this.vertices)
                    },
                    computeBoundingSphere: function() {
                        null === this.boundingSphere && (this.boundingSphere = new nt),
                        this.boundingSphere.setFromPoints(this.vertices)
                    },
                    merge: function(t, e, i) {
                        if ((t && t.isGeometry) === !1)
                            return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                        var n, r = this.vertices.length, a = this.vertices, o = t.vertices, s = this.faces, l = t.faces, h = this.faceVertexUvs[0], c = t.faceVertexUvs[0];
                        void 0 === i && (i = 0),
                        void 0 !== e && (n = (new rt).getNormalMatrix(e));
                        for (var u = 0, p = o.length; u < p; u++) {
                            var d = o[u]
                              , f = d.clone();
                            void 0 !== e && f.applyMatrix4(e),
                            a.push(f)
                        }
                        for (u = 0,
                        p = l.length; u < p; u++) {
                            var m, g, v, _ = l[u], y = _.vertexNormals, x = _.vertexColors;
                            m = new Ut(_.a + r,_.b + r,_.c + r),
                            m.normal.copy(_.normal),
                            void 0 !== n && m.normal.applyMatrix3(n).normalize();
                            for (var b = 0, w = y.length; b < w; b++)
                                g = y[b].clone(),
                                void 0 !== n && g.applyMatrix3(n).normalize(),
                                m.vertexNormals.push(g);
                            m.color.copy(_.color);
                            for (var b = 0, w = x.length; b < w; b++)
                                v = x[b],
                                m.vertexColors.push(v.clone());
                            m.materialIndex = _.materialIndex + i,
                            s.push(m)
                        }
                        for (u = 0,
                        p = c.length; u < p; u++) {
                            var M = c[u]
                              , T = [];
                            if (void 0 !== M) {
                                for (var b = 0, w = M.length; b < w; b++)
                                    T.push(M[b].clone());
                                h.push(T)
                            }
                        }
                    },
                    mergeMesh: function(t) {
                        return (t && t.isMesh) === !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(),
                        void this.merge(t.geometry, t.matrix))
                    },
                    mergeVertices: function() {
                        var t, e, i, n, r, a, o, s, l = {}, h = [], c = [], u = 4, p = Math.pow(10, u);
                        for (i = 0,
                        n = this.vertices.length; i < n; i++)
                            t = this.vertices[i],
                            e = Math.round(t.x * p) + "_" + Math.round(t.y * p) + "_" + Math.round(t.z * p),
                            void 0 === l[e] ? (l[e] = i,
                            h.push(this.vertices[i]),
                            c[i] = h.length - 1) : c[i] = c[l[e]];
                        var d = [];
                        for (i = 0,
                        n = this.faces.length; i < n; i++) {
                            r = this.faces[i],
                            r.a = c[r.a],
                            r.b = c[r.b],
                            r.c = c[r.c],
                            a = [r.a, r.b, r.c];
                            for (var f = -1, m = 0; m < 3; m++)
                                if (a[m] === a[(m + 1) % 3]) {
                                    f = m,
                                    d.push(i);
                                    break
                                }
                        }
                        for (i = d.length - 1; i >= 0; i--) {
                            var g = d[i];
                            for (this.faces.splice(g, 1),
                            o = 0,
                            s = this.faceVertexUvs.length; o < s; o++)
                                this.faceVertexUvs[o].splice(g, 1)
                        }
                        var v = this.vertices.length - h.length;
                        return this.vertices = h,
                        v
                    },
                    sortFacesByMaterialIndex: function() {
                        function t(t, e) {
                            return t.materialIndex - e.materialIndex
                        }
                        for (var e = this.faces, i = e.length, n = 0; n < i; n++)
                            e[n]._id = n;
                        e.sort(t);
                        var r, a, o = this.faceVertexUvs[0], s = this.faceVertexUvs[1];
                        o && o.length === i && (r = []),
                        s && s.length === i && (a = []);
                        for (var n = 0; n < i; n++) {
                            var l = e[n]._id;
                            r && r.push(o[l]),
                            a && a.push(s[l])
                        }
                        r && (this.faceVertexUvs[0] = r),
                        a && (this.faceVertexUvs[1] = a)
                    },
                    toJSON: function() {
                        function t(t, e, i) {
                            return i ? t | 1 << e : t & ~(1 << e)
                        }
                        function e(t) {
                            var e = t.x.toString() + t.y.toString() + t.z.toString();
                            return void 0 !== p[e] ? p[e] : (p[e] = u.length / 3,
                            u.push(t.x, t.y, t.z),
                            p[e])
                        }
                        function i(t) {
                            var e = t.r.toString() + t.g.toString() + t.b.toString();
                            return void 0 !== f[e] ? f[e] : (f[e] = d.length,
                            d.push(t.getHex()),
                            f[e])
                        }
                        function n(t) {
                            var e = t.x.toString() + t.y.toString();
                            return void 0 !== g[e] ? g[e] : (g[e] = m.length / 2,
                            m.push(t.x, t.y),
                            g[e])
                        }
                        var r = {
                            metadata: {
                                version: 4.4,
                                type: "Geometry",
                                generator: "Geometry.toJSON"
                            }
                        };
                        if (r.uuid = this.uuid,
                        r.type = this.type,
                        "" !== this.name && (r.name = this.name),
                        void 0 !== this.parameters) {
                            var a = this.parameters;
                            for (var o in a)
                                void 0 !== a[o] && (r[o] = a[o]);
                            return r
                        }
                        for (var s = [], l = 0; l < this.vertices.length; l++) {
                            var h = this.vertices[l];
                            s.push(h.x, h.y, h.z)
                        }
                        for (var c = [], u = [], p = {}, d = [], f = {}, m = [], g = {}, l = 0; l < this.faces.length; l++) {
                            var v = this.faces[l]
                              , _ = !0
                              , y = !1
                              , x = void 0 !== this.faceVertexUvs[0][l]
                              , b = v.normal.length() > 0
                              , w = v.vertexNormals.length > 0
                              , M = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b
                              , T = v.vertexColors.length > 0
                              , S = 0;
                            if (S = t(S, 0, 0),
                            S = t(S, 1, _),
                            S = t(S, 2, y),
                            S = t(S, 3, x),
                            S = t(S, 4, b),
                            S = t(S, 5, w),
                            S = t(S, 6, M),
                            S = t(S, 7, T),
                            c.push(S),
                            c.push(v.a, v.b, v.c),
                            c.push(v.materialIndex),
                            x) {
                                var E = this.faceVertexUvs[0][l];
                                c.push(n(E[0]), n(E[1]), n(E[2]))
                            }
                            if (b && c.push(e(v.normal)),
                            w) {
                                var A = v.vertexNormals;
                                c.push(e(A[0]), e(A[1]), e(A[2]))
                            }
                            if (M && c.push(i(v.color)),
                            T) {
                                var P = v.vertexColors;
                                c.push(i(P[0]), i(P[1]), i(P[2]))
                            }
                        }
                        return r.data = {},
                        r.data.vertices = s,
                        r.data.normals = u,
                        d.length > 0 && (r.data.colors = d),
                        m.length > 0 && (r.data.uvs = [m]),
                        r.data.faces = c,
                        r
                    },
                    clone: function() {
                        return (new kt).copy(this)
                    },
                    copy: function(t) {
                        this.vertices = [],
                        this.faces = [],
                        this.faceVertexUvs = [[]];
                        for (var e = t.vertices, i = 0, n = e.length; i < n; i++)
                            this.vertices.push(e[i].clone());
                        for (var r = t.faces, i = 0, n = r.length; i < n; i++)
                            this.faces.push(r[i].clone());
                        for (var i = 0, n = t.faceVertexUvs.length; i < n; i++) {
                            var a = t.faceVertexUvs[i];
                            void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []);
                            for (var o = 0, s = a.length; o < s; o++) {
                                for (var l = a[o], h = [], c = 0, u = l.length; c < u; c++) {
                                    var p = l[c];
                                    h.push(p.clone())
                                }
                                this.faceVertexUvs[i].push(h)
                            }
                        }
                        return this
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                });
                var Fl = 0;
                Object.assign(Vt.prototype, i.prototype, {
                    computeBoundingBox: kt.prototype.computeBoundingBox,
                    computeBoundingSphere: kt.prototype.computeBoundingSphere,
                    computeFaceNormals: function() {
                        console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
                    },
                    computeVertexNormals: function() {
                        console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
                    },
                    computeGroups: function(t) {
                        for (var e, i, n = [], r = t.faces, a = 0; a < r.length; a++) {
                            var o = r[a];
                            o.materialIndex !== i && (i = o.materialIndex,
                            void 0 !== e && (e.count = 3 * a - e.start,
                            n.push(e)),
                            e = {
                                start: 3 * a,
                                materialIndex: i
                            })
                        }
                        void 0 !== e && (e.count = 3 * a - e.start,
                        n.push(e)),
                        this.groups = n
                    },
                    fromGeometry: function(t) {
                        var e, i = t.faces, r = t.vertices, a = t.faceVertexUvs, o = a[0] && a[0].length > 0, s = a[1] && a[1].length > 0, l = t.morphTargets, h = l.length;
                        if (h > 0) {
                            e = [];
                            for (var c = 0; c < h; c++)
                                e[c] = [];
                            this.morphTargets.position = e
                        }
                        var u, p = t.morphNormals, d = p.length;
                        if (d > 0) {
                            u = [];
                            for (var c = 0; c < d; c++)
                                u[c] = [];
                            this.morphTargets.normal = u
                        }
                        for (var f = t.skinIndices, m = t.skinWeights, g = f.length === r.length, v = m.length === r.length, c = 0; c < i.length; c++) {
                            var _ = i[c];
                            this.vertices.push(r[_.a], r[_.b], r[_.c]);
                            var y = _.vertexNormals;
                            if (3 === y.length)
                                this.normals.push(y[0], y[1], y[2]);
                            else {
                                var x = _.normal;
                                this.normals.push(x, x, x)
                            }
                            var b = _.vertexColors;
                            if (3 === b.length)
                                this.colors.push(b[0], b[1], b[2]);
                            else {
                                var w = _.color;
                                this.colors.push(w, w, w)
                            }
                            if (o === !0) {
                                var M = a[0][c];
                                void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c),
                                this.uvs.push(new n, new n, new n))
                            }
                            if (s === !0) {
                                var M = a[1][c];
                                void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c),
                                this.uvs2.push(new n, new n, new n))
                            }
                            for (var T = 0; T < h; T++) {
                                var S = l[T].vertices;
                                e[T].push(S[_.a], S[_.b], S[_.c])
                            }
                            for (var T = 0; T < d; T++) {
                                var E = p[T].vertexNormals[c];
                                u[T].push(E.a, E.b, E.c)
                            }
                            g && this.skinIndices.push(f[_.a], f[_.b], f[_.c]),
                            v && this.skinWeights.push(m[_.a], m[_.b], m[_.c])
                        }
                        return this.computeGroups(t),
                        this.verticesNeedUpdate = t.verticesNeedUpdate,
                        this.normalsNeedUpdate = t.normalsNeedUpdate,
                        this.colorsNeedUpdate = t.colorsNeedUpdate,
                        this.uvsNeedUpdate = t.uvsNeedUpdate,
                        this.groupsNeedUpdate = t.groupsNeedUpdate,
                        this
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }),
                Object.assign(Ht.prototype, i.prototype, {
                    isBufferGeometry: !0,
                    getIndex: function() {
                        return this.index
                    },
                    setIndex: function(t) {
                        this.index = t
                    },
                    addAttribute: function(t, e) {
                        return (e && e.isBufferAttribute) === !1 && (e && e.isInterleavedBufferAttribute) === !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
                        void this.addAttribute(t, new Tt(arguments[1],arguments[2]))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
                        void this.setIndex(e)) : (this.attributes[t] = e,
                        this)
                    },
                    getAttribute: function(t) {
                        return this.attributes[t]
                    },
                    removeAttribute: function(t) {
                        return delete this.attributes[t],
                        this
                    },
                    addGroup: function(t, e, i) {
                        this.groups.push({
                            start: t,
                            count: e,
                            materialIndex: void 0 !== i ? i : 0
                        })
                    },
                    clearGroups: function() {
                        this.groups = []
                    },
                    setDrawRange: function(t, e) {
                        this.drawRange.start = t,
                        this.drawRange.count = e
                    },
                    applyMatrix: function(t) {
                        var e = this.attributes.position;
                        void 0 !== e && (t.applyToVector3Array(e.array),
                        e.needsUpdate = !0);
                        var i = this.attributes.normal;
                        if (void 0 !== i) {
                            var n = (new rt).getNormalMatrix(t);
                            n.applyToVector3Array(i.array),
                            i.needsUpdate = !0
                        }
                        return null !== this.boundingBox && this.computeBoundingBox(),
                        null !== this.boundingSphere && this.computeBoundingSphere(),
                        this
                    },
                    rotateX: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.makeRotationX(e),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    rotateY: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.makeRotationY(e),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    rotateZ: function() {
                        var t;
                        return function(e) {
                            return void 0 === t && (t = new o),
                            t.makeRotationZ(e),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    translate: function() {
                        var t;
                        return function(e, i, n) {
                            return void 0 === t && (t = new o),
                            t.makeTranslation(e, i, n),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    scale: function() {
                        var t;
                        return function(e, i, n) {
                            return void 0 === t && (t = new o),
                            t.makeScale(e, i, n),
                            this.applyMatrix(t),
                            this
                        }
                    }(),
                    lookAt: function() {
                        var t;
                        return function(e) {
                            void 0 === t && (t = new zt),
                            t.lookAt(e),
                            t.updateMatrix(),
                            this.applyMatrix(t.matrix)
                        }
                    }(),
                    center: function() {
                        this.computeBoundingBox();
                        var t = this.boundingBox.center().negate();
                        return this.translate(t.x, t.y, t.z),
                        t
                    },
                    setFromObject: function(t) {
                        var e = t.geometry;
                        if (t && t.isPoints || t && t.isLine) {
                            var i = new Ot(3 * e.vertices.length,3)
                              , n = new Ot(3 * e.colors.length,3);
                            if (this.addAttribute("position", i.copyVector3sArray(e.vertices)),
                            this.addAttribute("color", n.copyColorsArray(e.colors)),
                            e.lineDistances && e.lineDistances.length === e.vertices.length) {
                                var r = new Ot(e.lineDistances.length,1);
                                this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                            }
                            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                        } else
                            t && t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                        return this
                    },
                    updateFromObject: function(t) {
                        var e = t.geometry;
                        if (t && t.isMesh) {
                            var i = e.__directGeometry;
                            if (e.elementsNeedUpdate === !0 && (i = void 0,
                            e.elementsNeedUpdate = !1),
                            void 0 === i)
                                return this.fromGeometry(e);
                            i.verticesNeedUpdate = e.verticesNeedUpdate,
                            i.normalsNeedUpdate = e.normalsNeedUpdate,
                            i.colorsNeedUpdate = e.colorsNeedUpdate,
                            i.uvsNeedUpdate = e.uvsNeedUpdate,
                            i.groupsNeedUpdate = e.groupsNeedUpdate,
                            e.verticesNeedUpdate = !1,
                            e.normalsNeedUpdate = !1,
                            e.colorsNeedUpdate = !1,
                            e.uvsNeedUpdate = !1,
                            e.groupsNeedUpdate = !1,
                            e = i
                        }
                        var n;
                        return e.verticesNeedUpdate === !0 && (n = this.attributes.position,
                        void 0 !== n && (n.copyVector3sArray(e.vertices),
                        n.needsUpdate = !0),
                        e.verticesNeedUpdate = !1),
                        e.normalsNeedUpdate === !0 && (n = this.attributes.normal,
                        void 0 !== n && (n.copyVector3sArray(e.normals),
                        n.needsUpdate = !0),
                        e.normalsNeedUpdate = !1),
                        e.colorsNeedUpdate === !0 && (n = this.attributes.color,
                        void 0 !== n && (n.copyColorsArray(e.colors),
                        n.needsUpdate = !0),
                        e.colorsNeedUpdate = !1),
                        e.uvsNeedUpdate && (n = this.attributes.uv,
                        void 0 !== n && (n.copyVector2sArray(e.uvs),
                        n.needsUpdate = !0),
                        e.uvsNeedUpdate = !1),
                        e.lineDistancesNeedUpdate && (n = this.attributes.lineDistance,
                        void 0 !== n && (n.copyArray(e.lineDistances),
                        n.needsUpdate = !0),
                        e.lineDistancesNeedUpdate = !1),
                        e.groupsNeedUpdate && (e.computeGroups(t.geometry),
                        this.groups = e.groups,
                        e.groupsNeedUpdate = !1),
                        this
                    },
                    fromGeometry: function(t) {
                        return t.__directGeometry = (new Vt).fromGeometry(t),
                        this.fromDirectGeometry(t.__directGeometry)
                    },
                    fromDirectGeometry: function(t) {
                        var e = new Float32Array(3 * t.vertices.length);
                        if (this.addAttribute("position", new Tt(e,3).copyVector3sArray(t.vertices)),
                        t.normals.length > 0) {
                            var i = new Float32Array(3 * t.normals.length);
                            this.addAttribute("normal", new Tt(i,3).copyVector3sArray(t.normals))
                        }
                        if (t.colors.length > 0) {
                            var n = new Float32Array(3 * t.colors.length);
                            this.addAttribute("color", new Tt(n,3).copyColorsArray(t.colors))
                        }
                        if (t.uvs.length > 0) {
                            var r = new Float32Array(2 * t.uvs.length);
                            this.addAttribute("uv", new Tt(r,2).copyVector2sArray(t.uvs))
                        }
                        if (t.uvs2.length > 0) {
                            var a = new Float32Array(2 * t.uvs2.length);
                            this.addAttribute("uv2", new Tt(a,2).copyVector2sArray(t.uvs2))
                        }
                        if (t.indices.length > 0) {
                            var o = t.vertices.length > 65535 ? Uint32Array : Uint16Array
                              , s = new o(3 * t.indices.length);
                            this.setIndex(new Tt(s,1).copyIndicesArray(t.indices))
                        }
                        this.groups = t.groups;
                        for (var l in t.morphTargets) {
                            for (var h = [], c = t.morphTargets[l], u = 0, p = c.length; u < p; u++) {
                                var d = c[u]
                                  , f = new Ot(3 * d.length,3);
                                h.push(f.copyVector3sArray(d))
                            }
                            this.morphAttributes[l] = h
                        }
                        if (t.skinIndices.length > 0) {
                            var m = new Ot(4 * t.skinIndices.length,4);
                            this.addAttribute("skinIndex", m.copyVector4sArray(t.skinIndices))
                        }
                        if (t.skinWeights.length > 0) {
                            var g = new Ot(4 * t.skinWeights.length,4);
                            this.addAttribute("skinWeight", g.copyVector4sArray(t.skinWeights))
                        }
                        return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                        this
                    },
                    computeBoundingBox: function() {
                        null === this.boundingBox && (this.boundingBox = new it);
                        var t = this.attributes.position.array;
                        void 0 !== t ? this.boundingBox.setFromArray(t) : this.boundingBox.makeEmpty(),
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    },
                    computeBoundingSphere: function() {
                        var t = new it
                          , e = new l;
                        return function() {
                            null === this.boundingSphere && (this.boundingSphere = new nt);
                            var i = this.attributes.position;
                            if (i) {
                                var n = i.array
                                  , r = this.boundingSphere.center;
                                t.setFromArray(n),
                                t.center(r);
                                for (var a = 0, o = 0, s = n.length; o < s; o += 3)
                                    e.fromArray(n, o),
                                    a = Math.max(a, r.distanceToSquared(e));
                                this.boundingSphere.radius = Math.sqrt(a),
                                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                    }(),
                    computeFaceNormals: function() {},
                    computeVertexNormals: function() {
                        var t = this.index
                          , e = this.attributes
                          , i = this.groups;
                        if (e.position) {
                            var n = e.position.array;
                            if (void 0 === e.normal)
                                this.addAttribute("normal", new Tt(new Float32Array(n.length),3));
                            else
                                for (var r = e.normal.array, a = 0, o = r.length; a < o; a++)
                                    r[a] = 0;
                            var s, h, c, u = e.normal.array, p = new l, d = new l, f = new l, m = new l, g = new l;
                            if (t) {
                                var v = t.array;
                                0 === i.length && this.addGroup(0, v.length);
                                for (var _ = 0, y = i.length; _ < y; ++_)
                                    for (var x = i[_], b = x.start, w = x.count, a = b, o = b + w; a < o; a += 3)
                                        s = 3 * v[a + 0],
                                        h = 3 * v[a + 1],
                                        c = 3 * v[a + 2],
                                        p.fromArray(n, s),
                                        d.fromArray(n, h),
                                        f.fromArray(n, c),
                                        m.subVectors(f, d),
                                        g.subVectors(p, d),
                                        m.cross(g),
                                        u[s] += m.x,
                                        u[s + 1] += m.y,
                                        u[s + 2] += m.z,
                                        u[h] += m.x,
                                        u[h + 1] += m.y,
                                        u[h + 2] += m.z,
                                        u[c] += m.x,
                                        u[c + 1] += m.y,
                                        u[c + 2] += m.z
                            } else
                                for (var a = 0, o = n.length; a < o; a += 9)
                                    p.fromArray(n, a),
                                    d.fromArray(n, a + 3),
                                    f.fromArray(n, a + 6),
                                    m.subVectors(f, d),
                                    g.subVectors(p, d),
                                    m.cross(g),
                                    u[a] = m.x,
                                    u[a + 1] = m.y,
                                    u[a + 2] = m.z,
                                    u[a + 3] = m.x,
                                    u[a + 4] = m.y,
                                    u[a + 5] = m.z,
                                    u[a + 6] = m.x,
                                    u[a + 7] = m.y,
                                    u[a + 8] = m.z;
                            this.normalizeNormals(),
                            e.normal.needsUpdate = !0
                        }
                    },
                    merge: function(t, e) {
                        if ((t && t.isBufferGeometry) === !1)
                            return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                        void 0 === e && (e = 0);
                        var i = this.attributes;
                        for (var n in i)
                            if (void 0 !== t.attributes[n])
                                for (var r = i[n], a = r.array, o = t.attributes[n], s = o.array, l = o.itemSize, h = 0, c = l * e; h < s.length; h++,
                                c++)
                                    a[c] = s[h];
                        return this
                    },
                    normalizeNormals: function() {
                        for (var t, e, i, n, r = this.attributes.normal.array, a = 0, o = r.length; a < o; a += 3)
                            t = r[a],
                            e = r[a + 1],
                            i = r[a + 2],
                            n = 1 / Math.sqrt(t * t + e * e + i * i),
                            r[a] *= n,
                            r[a + 1] *= n,
                            r[a + 2] *= n
                    },
                    toNonIndexed: function() {
                        if (null === this.index)
                            return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                            this;
                        var t = new Ht
                          , e = this.index.array
                          , i = this.attributes;
                        for (var n in i) {
                            for (var r = i[n], a = r.array, o = r.itemSize, s = new a.constructor(e.length * o), l = 0, h = 0, c = 0, u = e.length; c < u; c++) {
                                l = e[c] * o;
                                for (var p = 0; p < o; p++)
                                    s[h++] = a[l++]
                            }
                            t.addAttribute(n, new Tt(s,o))
                        }
                        return t
                    },
                    toJSON: function() {
                        var t = {
                            metadata: {
                                version: 4.4,
                                type: "BufferGeometry",
                                generator: "BufferGeometry.toJSON"
                            }
                        };
                        if (t.uuid = this.uuid,
                        t.type = this.type,
                        "" !== this.name && (t.name = this.name),
                        void 0 !== this.parameters) {
                            var e = this.parameters;
                            for (var i in e)
                                void 0 !== e[i] && (t[i] = e[i]);
                            return t
                        }
                        t.data = {
                            attributes: {}
                        };
                        var n = this.index;
                        if (null !== n) {
                            var r = Array.prototype.slice.call(n.array);
                            t.data.index = {
                                type: n.array.constructor.name,
                                array: r
                            }
                        }
                        var a = this.attributes;
                        for (var i in a) {
                            var o = a[i]
                              , r = Array.prototype.slice.call(o.array);
                            t.data.attributes[i] = {
                                itemSize: o.itemSize,
                                type: o.array.constructor.name,
                                array: r,
                                normalized: o.normalized
                            }
                        }
                        var s = this.groups;
                        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                        var l = this.boundingSphere;
                        return null !== l && (t.data.boundingSphere = {
                            center: l.center.toArray(),
                            radius: l.radius
                        }),
                        t
                    },
                    clone: function() {
                        return (new Ht).copy(this)
                    },
                    copy: function(t) {
                        var e = t.index;
                        null !== e && this.setIndex(e.clone());
                        var i = t.attributes;
                        for (var n in i) {
                            var r = i[n];
                            this.addAttribute(n, r.clone())
                        }
                        for (var a = t.groups, o = 0, s = a.length; o < s; o++) {
                            var l = a[o];
                            this.addGroup(l.start, l.count, l.materialIndex)
                        }
                        return this
                    },
                    dispose: function() {
                        this.dispatchEvent({
                            type: "dispose"
                        })
                    }
                }),
                Ht.MaxIndex = 65535,
                Kt.prototype = Object.create(Q.prototype),
                Kt.prototype.constructor = Kt,
                Kt.prototype.isWebGLRenderTargetCube = !0,
                $t.prototype = Object.create(Ht.prototype),
                $t.prototype.constructor = $t,
                te.prototype = {
                    constructor: te,
                    set: function(t, e) {
                        return this.origin.copy(t),
                        this.direction.copy(e),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.origin.copy(t.origin),
                        this.direction.copy(t.direction),
                        this
                    },
                    at: function(t, e) {
                        var i = e || new l;
                        return i.copy(this.direction).multiplyScalar(t).add(this.origin)
                    },
                    lookAt: function(t) {
                        return this.direction.copy(t).sub(this.origin).normalize(),
                        this
                    },
                    recast: function() {
                        var t = new l;
                        return function(e) {
                            return this.origin.copy(this.at(e, t)),
                            this
                        }
                    }(),
                    closestPointToPoint: function(t, e) {
                        var i = e || new l;
                        i.subVectors(t, this.origin);
                        var n = i.dot(this.direction);
                        return n < 0 ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
                    },
                    distanceToPoint: function(t) {
                        return Math.sqrt(this.distanceSqToPoint(t))
                    },
                    distanceSqToPoint: function() {
                        var t = new l;
                        return function(e) {
                            var i = t.subVectors(e, this.origin).dot(this.direction);
                            return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin),
                            t.distanceToSquared(e))
                        }
                    }(),
                    distanceSqToSegment: function() {
                        var t = new l
                          , e = new l
                          , i = new l;
                        return function(n, r, a, o) {
                            t.copy(n).add(r).multiplyScalar(.5),
                            e.copy(r).sub(n).normalize(),
                            i.copy(this.origin).sub(t);
                            var s, l, h, c, u = .5 * n.distanceTo(r), p = -this.direction.dot(e), d = i.dot(this.direction), f = -i.dot(e), m = i.lengthSq(), g = Math.abs(1 - p * p);
                            if (g > 0)
                                if (s = p * f - d,
                                l = p * d - f,
                                c = u * g,
                                s >= 0)
                                    if (l >= -c)
                                        if (l <= c) {
                                            var v = 1 / g;
                                            s *= v,
                                            l *= v,
                                            h = s * (s + p * l + 2 * d) + l * (p * s + l + 2 * f) + m
                                        } else
                                            l = u,
                                            s = Math.max(0, -(p * l + d)),
                                            h = -s * s + l * (l + 2 * f) + m;
                                    else
                                        l = -u,
                                        s = Math.max(0, -(p * l + d)),
                                        h = -s * s + l * (l + 2 * f) + m;
                                else
                                    l <= -c ? (s = Math.max(0, -(-p * u + d)),
                                    l = s > 0 ? -u : Math.min(Math.max(-u, -f), u),
                                    h = -s * s + l * (l + 2 * f) + m) : l <= c ? (s = 0,
                                    l = Math.min(Math.max(-u, -f), u),
                                    h = l * (l + 2 * f) + m) : (s = Math.max(0, -(p * u + d)),
                                    l = s > 0 ? u : Math.min(Math.max(-u, -f), u),
                                    h = -s * s + l * (l + 2 * f) + m);
                            else
                                l = p > 0 ? -u : u,
                                s = Math.max(0, -(p * l + d)),
                                h = -s * s + l * (l + 2 * f) + m;
                            return a && a.copy(this.direction).multiplyScalar(s).add(this.origin),
                            o && o.copy(e).multiplyScalar(l).add(t),
                            h
                        }
                    }(),
                    intersectSphere: function() {
                        var t = new l;
                        return function(e, i) {
                            t.subVectors(e.center, this.origin);
                            var n = t.dot(this.direction)
                              , r = t.dot(t) - n * n
                              , a = e.radius * e.radius;
                            if (r > a)
                                return null;
                            var o = Math.sqrt(a - r)
                              , s = n - o
                              , l = n + o;
                            return s < 0 && l < 0 ? null : s < 0 ? this.at(l, i) : this.at(s, i)
                        }
                    }(),
                    intersectsSphere: function(t) {
                        return this.distanceToPoint(t.center) <= t.radius
                    },
                    distanceToPlane: function(t) {
                        var e = t.normal.dot(this.direction);
                        if (0 === e)
                            return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                        var i = -(this.origin.dot(t.normal) + t.constant) / e;
                        return i >= 0 ? i : null
                    },
                    intersectPlane: function(t, e) {
                        var i = this.distanceToPlane(t);
                        return null === i ? null : this.at(i, e)
                    },
                    intersectsPlane: function(t) {
                        var e = t.distanceToPoint(this.origin);
                        if (0 === e)
                            return !0;
                        var i = t.normal.dot(this.direction);
                        return i * e < 0
                    },
                    intersectBox: function(t, e) {
                        var i, n, r, a, o, s, l = 1 / this.direction.x, h = 1 / this.direction.y, c = 1 / this.direction.z, u = this.origin;
                        return l >= 0 ? (i = (t.min.x - u.x) * l,
                        n = (t.max.x - u.x) * l) : (i = (t.max.x - u.x) * l,
                        n = (t.min.x - u.x) * l),
                        h >= 0 ? (r = (t.min.y - u.y) * h,
                        a = (t.max.y - u.y) * h) : (r = (t.max.y - u.y) * h,
                        a = (t.min.y - u.y) * h),
                        i > a || r > n ? null : ((r > i || i !== i) && (i = r),
                        (a < n || n !== n) && (n = a),
                        c >= 0 ? (o = (t.min.z - u.z) * c,
                        s = (t.max.z - u.z) * c) : (o = (t.max.z - u.z) * c,
                        s = (t.min.z - u.z) * c),
                        i > s || o > n ? null : ((o > i || i !== i) && (i = o),
                        (s < n || n !== n) && (n = s),
                        n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                    },
                    intersectsBox: function() {
                        var t = new l;
                        return function(e) {
                            return null !== this.intersectBox(e, t)
                        }
                    }(),
                    intersectTriangle: function() {
                        var t = new l
                          , e = new l
                          , i = new l
                          , n = new l;
                        return function(r, a, o, s, l) {
                            e.subVectors(a, r),
                            i.subVectors(o, r),
                            n.crossVectors(e, i);
                            var h, c = this.direction.dot(n);
                            if (c > 0) {
                                if (s)
                                    return null;
                                h = 1
                            } else {
                                if (!(c < 0))
                                    return null;
                                h = -1,
                                c = -c
                            }
                            t.subVectors(this.origin, r);
                            var u = h * this.direction.dot(i.crossVectors(t, i));
                            if (u < 0)
                                return null;
                            var p = h * this.direction.dot(e.cross(t));
                            if (p < 0)
                                return null;
                            if (u + p > c)
                                return null;
                            var d = -h * t.dot(n);
                            return d < 0 ? null : this.at(d / c, l)
                        }
                    }(),
                    applyMatrix4: function(t) {
                        return this.direction.add(this.origin).applyMatrix4(t),
                        this.origin.applyMatrix4(t),
                        this.direction.sub(this.origin),
                        this.direction.normalize(),
                        this
                    },
                    equals: function(t) {
                        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                    }
                },
                ee.prototype = {
                    constructor: ee,
                    set: function(t, e) {
                        return this.start.copy(t),
                        this.end.copy(e),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.start.copy(t.start),
                        this.end.copy(t.end),
                        this
                    },
                    center: function(t) {
                        var e = t || new l;
                        return e.addVectors(this.start, this.end).multiplyScalar(.5)
                    },
                    delta: function(t) {
                        var e = t || new l;
                        return e.subVectors(this.end, this.start)
                    },
                    distanceSq: function() {
                        return this.start.distanceToSquared(this.end)
                    },
                    distance: function() {
                        return this.start.distanceTo(this.end)
                    },
                    at: function(t, e) {
                        var i = e || new l;
                        return this.delta(i).multiplyScalar(t).add(this.start)
                    },
                    closestPointToPointParameter: function() {
                        var t = new l
                          , i = new l;
                        return function(n, r) {
                            t.subVectors(n, this.start),
                            i.subVectors(this.end, this.start);
                            var a = i.dot(i)
                              , o = i.dot(t)
                              , s = o / a;
                            return r && (s = e.Math.clamp(s, 0, 1)),
                            s
                        }
                    }(),
                    closestPointToPoint: function(t, e, i) {
                        var n = this.closestPointToPointParameter(t, e)
                          , r = i || new l;
                        return this.delta(r).multiplyScalar(n).add(this.start)
                    },
                    applyMatrix4: function(t) {
                        return this.start.applyMatrix4(t),
                        this.end.applyMatrix4(t),
                        this
                    },
                    equals: function(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                },
                ie.normal = function() {
                    var t = new l;
                    return function(e, i, n, r) {
                        var a = r || new l;
                        a.subVectors(n, i),
                        t.subVectors(e, i),
                        a.cross(t);
                        var o = a.lengthSq();
                        return o > 0 ? a.multiplyScalar(1 / Math.sqrt(o)) : a.set(0, 0, 0)
                    }
                }(),
                ie.barycoordFromPoint = function() {
                    var t = new l
                      , e = new l
                      , i = new l;
                    return function(n, r, a, o, s) {
                        t.subVectors(o, r),
                        e.subVectors(a, r),
                        i.subVectors(n, r);
                        var h = t.dot(t)
                          , c = t.dot(e)
                          , u = t.dot(i)
                          , p = e.dot(e)
                          , d = e.dot(i)
                          , f = h * p - c * c
                          , m = s || new l;
                        if (0 === f)
                            return m.set(-2, -1, -1);
                        var g = 1 / f
                          , v = (p * u - c * d) * g
                          , _ = (h * d - c * u) * g;
                        return m.set(1 - v - _, _, v)
                    }
                }(),
                ie.containsPoint = function() {
                    var t = new l;
                    return function(e, i, n, r) {
                        var a = ie.barycoordFromPoint(e, i, n, r, t);
                        return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1
                    }
                }(),
                ie.prototype = {
                    constructor: ie,
                    set: function(t, e, i) {
                        return this.a.copy(t),
                        this.b.copy(e),
                        this.c.copy(i),
                        this
                    },
                    setFromPointsAndIndices: function(t, e, i, n) {
                        return this.a.copy(t[e]),
                        this.b.copy(t[i]),
                        this.c.copy(t[n]),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.a.copy(t.a),
                        this.b.copy(t.b),
                        this.c.copy(t.c),
                        this
                    },
                    area: function() {
                        var t = new l
                          , e = new l;
                        return function() {
                            return t.subVectors(this.c, this.b),
                            e.subVectors(this.a, this.b),
                            .5 * t.cross(e).length()
                        }
                    }(),
                    midpoint: function(t) {
                        var e = t || new l;
                        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    },
                    normal: function(t) {
                        return ie.normal(this.a, this.b, this.c, t)
                    },
                    plane: function(t) {
                        var e = t || new at;
                        return e.setFromCoplanarPoints(this.a, this.b, this.c)
                    },
                    barycoordFromPoint: function(t, e) {
                        return ie.barycoordFromPoint(t, this.a, this.b, this.c, e)
                    },
                    containsPoint: function(t) {
                        return ie.containsPoint(t, this.a, this.b, this.c)
                    },
                    closestPointToPoint: function() {
                        var t, e, i, n;
                        return function(r, a) {
                            void 0 === t && (t = new at,
                            e = [new ee, new ee, new ee],
                            i = new l,
                            n = new l);
                            var o = a || new l
                              , s = 1 / 0;
                            if (t.setFromCoplanarPoints(this.a, this.b, this.c),
                            t.projectPoint(r, i),
                            this.containsPoint(i) === !0)
                                o.copy(i);
                            else {
                                e[0].set(this.a, this.b),
                                e[1].set(this.b, this.c),
                                e[2].set(this.c, this.a);
                                for (var h = 0; h < e.length; h++) {
                                    e[h].closestPointToPoint(i, !0, n);
                                    var c = i.distanceToSquared(n);
                                    c < s && (s = c,
                                    o.copy(n))
                                }
                            }
                            return o
                        }
                    }(),
                    equals: function(t) {
                        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                    }
                },
                ne.prototype = Object.create(J.prototype),
                ne.prototype.constructor = ne,
                ne.prototype.isMeshBasicMaterial = !0,
                ne.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.specularMap = t.specularMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.combine = t.combine,
                    this.reflectivity = t.reflectivity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this
                }
                ,
                re.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: re,
                    isMesh: !0,
                    setDrawMode: function(t) {
                        this.drawMode = t
                    },
                    copy: function(t) {
                        return zt.prototype.copy.call(this, t),
                        this.drawMode = t.drawMode,
                        this
                    },
                    updateMorphTargets: function() {
                        if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
                            this.morphTargetBase = -1,
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (var t = 0, e = this.geometry.morphTargets.length; t < e; t++)
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[this.geometry.morphTargets[t].name] = t
                        }
                    },
                    getMorphTargetIndexByName: function(t) {
                        return void 0 !== this.morphTargetDictionary[t] ? this.morphTargetDictionary[t] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + t + " does not exist. Returning 0."),
                        0)
                    },
                    raycast: function() {
                        function t(t, e, i, n, r, a, o) {
                            return ie.barycoordFromPoint(t, e, i, n, _),
                            r.multiplyScalar(_.x),
                            a.multiplyScalar(_.y),
                            o.multiplyScalar(_.z),
                            r.add(a).add(o),
                            r.clone()
                        }
                        function e(t, e, i, n, r, a, o) {
                            var s, l = t.material;
                            if (s = l.side === br ? i.intersectTriangle(a, r, n, !0, o) : i.intersectTriangle(n, r, a, l.side !== wr, o),
                            null === s)
                                return null;
                            x.copy(o),
                            x.applyMatrix4(t.matrixWorld);
                            var h = e.ray.origin.distanceTo(x);
                            return h < e.near || h > e.far ? null : {
                                distance: h,
                                point: x.clone(),
                                object: t
                            }
                        }
                        function i(i, n, r, a, o, s, l, p) {
                            h.fromArray(a, 3 * s),
                            c.fromArray(a, 3 * l),
                            u.fromArray(a, 3 * p);
                            var d = e(i, n, r, h, c, u, y);
                            return d && (o && (m.fromArray(o, 2 * s),
                            g.fromArray(o, 2 * l),
                            v.fromArray(o, 2 * p),
                            d.uv = t(y, h, c, u, m, g, v)),
                            d.face = new Ut(s,l,p,ie.normal(h, c, u)),
                            d.faceIndex = s),
                            d
                        }
                        var r = new o
                          , a = new te
                          , s = new nt
                          , h = new l
                          , c = new l
                          , u = new l
                          , p = new l
                          , d = new l
                          , f = new l
                          , m = new n
                          , g = new n
                          , v = new n
                          , _ = new l
                          , y = new l
                          , x = new l;
                        return function(n, o) {
                            var l = this.geometry
                              , _ = this.material
                              , x = this.matrixWorld;
                            if (void 0 !== _ && (null === l.boundingSphere && l.computeBoundingSphere(),
                            s.copy(l.boundingSphere),
                            s.applyMatrix4(x),
                            n.ray.intersectsSphere(s) !== !1 && (r.getInverse(x),
                            a.copy(n.ray).applyMatrix4(r),
                            null === l.boundingBox || a.intersectsBox(l.boundingBox) !== !1))) {
                                var b, w;
                                if (l && l.isBufferGeometry) {
                                    var M, T, S, E = l.index, A = l.attributes, P = A.position.array;
                                    if (void 0 !== A.uv && (b = A.uv.array),
                                    null !== E)
                                        for (var R = E.array, L = 0, C = R.length; L < C; L += 3)
                                            M = R[L],
                                            T = R[L + 1],
                                            S = R[L + 2],
                                            w = i(this, n, a, P, b, M, T, S),
                                            w && (w.faceIndex = Math.floor(L / 3),
                                            o.push(w));
                                    else
                                        for (var L = 0, C = P.length; L < C; L += 9)
                                            M = L / 3,
                                            T = M + 1,
                                            S = M + 2,
                                            w = i(this, n, a, P, b, M, T, S),
                                            w && (w.index = M,
                                            o.push(w))
                                } else if (l && l.isGeometry) {
                                    var O, I, D, U = _ && _.isMultiMaterial, F = U === !0 ? _.materials : null, N = l.vertices, z = l.faces, B = l.faceVertexUvs[0];
                                    B.length > 0 && (b = B);
                                    for (var k = 0, G = z.length; k < G; k++) {
                                        var V = z[k]
                                          , H = U === !0 ? F[V.materialIndex] : _;
                                        if (void 0 !== H) {
                                            if (O = N[V.a],
                                            I = N[V.b],
                                            D = N[V.c],
                                            H.morphTargets === !0) {
                                                var j = l.morphTargets
                                                  , W = this.morphTargetInfluences;
                                                h.set(0, 0, 0),
                                                c.set(0, 0, 0),
                                                u.set(0, 0, 0);
                                                for (var X = 0, Y = j.length; X < Y; X++) {
                                                    var q = W[X];
                                                    if (0 !== q) {
                                                        var Z = j[X].vertices;
                                                        h.addScaledVector(p.subVectors(Z[V.a], O), q),
                                                        c.addScaledVector(d.subVectors(Z[V.b], I), q),
                                                        u.addScaledVector(f.subVectors(Z[V.c], D), q)
                                                    }
                                                }
                                                h.add(O),
                                                c.add(I),
                                                u.add(D),
                                                O = h,
                                                I = c,
                                                D = u
                                            }
                                            if (w = e(this, n, a, O, I, D, y)) {
                                                if (b) {
                                                    var Q = b[k];
                                                    m.copy(Q[0]),
                                                    g.copy(Q[1]),
                                                    v.copy(Q[2]),
                                                    w.uv = t(y, O, I, D, m, g, v)
                                                }
                                                w.face = V,
                                                w.faceIndex = k,
                                                o.push(w)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.geometry,this.material).copy(this)
                    }
                }),
                ae.prototype = Object.create(Ht.prototype),
                ae.prototype.constructor = ae,
                oe.prototype = Object.create(zt.prototype),
                oe.prototype.constructor = oe,
                oe.prototype.isCamera = !0,
                oe.prototype.getWorldDirection = function() {
                    var t = new s;
                    return function(e) {
                        var i = e || new l;
                        return this.getWorldQuaternion(t),
                        i.set(0, 0, -1).applyQuaternion(t)
                    }
                }(),
                oe.prototype.lookAt = function() {
                    var t = new o;
                    return function(e) {
                        t.lookAt(this.position, e, this.up),
                        this.quaternion.setFromRotationMatrix(t)
                    }
                }(),
                oe.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }
                ,
                oe.prototype.copy = function(t) {
                    return zt.prototype.copy.call(this, t),
                    this.matrixWorldInverse.copy(t.matrixWorldInverse),
                    this.projectionMatrix.copy(t.projectionMatrix),
                    this
                }
                ,
                se.prototype = Object.assign(Object.create(oe.prototype), {
                    constructor: se,
                    isPerspectiveCamera: !0,
                    copy: function(t) {
                        return oe.prototype.copy.call(this, t),
                        this.fov = t.fov,
                        this.zoom = t.zoom,
                        this.near = t.near,
                        this.far = t.far,
                        this.focus = t.focus,
                        this.aspect = t.aspect,
                        this.view = null === t.view ? null : Object.assign({}, t.view),
                        this.filmGauge = t.filmGauge,
                        this.filmOffset = t.filmOffset,
                        this
                    },
                    setFocalLength: function(t) {
                        var i = .5 * this.getFilmHeight() / t;
                        this.fov = 2 * e.Math.RAD2DEG * Math.atan(i),
                        this.updateProjectionMatrix()
                    },
                    getFocalLength: function() {
                        var t = Math.tan(.5 * e.Math.DEG2RAD * this.fov);
                        return .5 * this.getFilmHeight() / t
                    },
                    getEffectiveFOV: function() {
                        return 2 * e.Math.RAD2DEG * Math.atan(Math.tan(.5 * e.Math.DEG2RAD * this.fov) / this.zoom)
                    },
                    getFilmWidth: function() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    },
                    getFilmHeight: function() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    },
                    setViewOffset: function(t, e, i, n, r, a) {
                        this.aspect = t / e,
                        this.view = {
                            fullWidth: t,
                            fullHeight: e,
                            offsetX: i,
                            offsetY: n,
                            width: r,
                            height: a
                        },
                        this.updateProjectionMatrix()
                    },
                    clearViewOffset: function() {
                        this.view = null,
                        this.updateProjectionMatrix()
                    },
                    updateProjectionMatrix: function() {
                        var t = this.near
                          , i = t * Math.tan(.5 * e.Math.DEG2RAD * this.fov) / this.zoom
                          , n = 2 * i
                          , r = this.aspect * n
                          , a = -.5 * r
                          , o = this.view;
                        if (null !== o) {
                            var s = o.fullWidth
                              , l = o.fullHeight;
                            a += o.offsetX * r / s,
                            i -= o.offsetY * n / l,
                            r *= o.width / s,
                            n *= o.height / l
                        }
                        var h = this.filmOffset;
                        0 !== h && (a += t * h / this.getFilmWidth()),
                        this.projectionMatrix.makeFrustum(a, a + r, i - n, i, t, this.far)
                    },
                    toJSON: function(t) {
                        var e = zt.prototype.toJSON.call(this, t);
                        return e.object.fov = this.fov,
                        e.object.zoom = this.zoom,
                        e.object.near = this.near,
                        e.object.far = this.far,
                        e.object.focus = this.focus,
                        e.object.aspect = this.aspect,
                        null !== this.view && (e.object.view = Object.assign({}, this.view)),
                        e.object.filmGauge = this.filmGauge,
                        e.object.filmOffset = this.filmOffset,
                        e
                    }
                }),
                le.prototype = Object.assign(Object.create(oe.prototype), {
                    constructor: le,
                    isOrthographicCamera: !0,
                    copy: function(t) {
                        return oe.prototype.copy.call(this, t),
                        this.left = t.left,
                        this.right = t.right,
                        this.top = t.top,
                        this.bottom = t.bottom,
                        this.near = t.near,
                        this.far = t.far,
                        this.zoom = t.zoom,
                        this.view = null === t.view ? null : Object.assign({}, t.view),
                        this
                    },
                    setViewOffset: function(t, e, i, n, r, a) {
                        this.view = {
                            fullWidth: t,
                            fullHeight: e,
                            offsetX: i,
                            offsetY: n,
                            width: r,
                            height: a
                        },
                        this.updateProjectionMatrix()
                    },
                    clearViewOffset: function() {
                        this.view = null,
                        this.updateProjectionMatrix()
                    },
                    updateProjectionMatrix: function() {
                        var t = (this.right - this.left) / (2 * this.zoom)
                          , e = (this.top - this.bottom) / (2 * this.zoom)
                          , i = (this.right + this.left) / 2
                          , n = (this.top + this.bottom) / 2
                          , r = i - t
                          , a = i + t
                          , o = n + e
                          , s = n - e;
                        if (null !== this.view) {
                            var l = this.zoom / (this.view.width / this.view.fullWidth)
                              , h = this.zoom / (this.view.height / this.view.fullHeight)
                              , c = (this.right - this.left) / this.view.width
                              , u = (this.top - this.bottom) / this.view.height;
                            r += c * (this.view.offsetX / l),
                            a = r + c * (this.view.width / l),
                            o -= u * (this.view.offsetY / h),
                            s = o - u * (this.view.height / h)
                        }
                        this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far)
                    },
                    toJSON: function(t) {
                        var e = zt.prototype.toJSON.call(this, t);
                        return e.object.zoom = this.zoom,
                        e.object.left = this.left,
                        e.object.right = this.right,
                        e.object.top = this.top,
                        e.object.bottom = this.bottom,
                        e.object.near = this.near,
                        e.object.far = this.far,
                        null !== this.view && (e.object.view = Object.assign({}, this.view)),
                        e
                    }
                }),
                ce.prototype.isFogExp2 = !0,
                ce.prototype.clone = function() {
                    return new ce(this.color.getHex(),this.density)
                }
                ,
                ce.prototype.toJSON = function(t) {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
                ,
                ue.prototype.isFog = !0,
                ue.prototype.clone = function() {
                    return new ue(this.color.getHex(),this.near,this.far)
                }
                ,
                ue.prototype.toJSON = function(t) {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
                ,
                pe.prototype = Object.create(zt.prototype),
                pe.prototype.constructor = pe,
                pe.prototype.copy = function(t, e) {
                    return zt.prototype.copy.call(this, t, e),
                    null !== t.background && (this.background = t.background.clone()),
                    null !== t.fog && (this.fog = t.fog.clone()),
                    null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
                    this.autoUpdate = t.autoUpdate,
                    this.matrixAutoUpdate = t.matrixAutoUpdate,
                    this
                }
                ,
                pe.prototype.toJSON = function(t) {
                    var e = zt.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)),
                    null !== this.fog && (e.object.fog = this.fog.toJSON()),
                    e
                }
                ,
                de.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: de,
                    isLensFlare: !0,
                    copy: function(t) {
                        zt.prototype.copy.call(this, t),
                        this.positionScreen.copy(t.positionScreen),
                        this.customUpdateCallback = t.customUpdateCallback;
                        for (var e = 0, i = t.lensFlares.length; e < i; e++)
                            this.lensFlares.push(t.lensFlares[e]);
                        return this
                    },
                    add: function(t, e, i, n, r, a) {
                        void 0 === e && (e = -1),
                        void 0 === i && (i = 0),
                        void 0 === a && (a = 1),
                        void 0 === r && (r = new tt(16777215)),
                        void 0 === n && (n = Rr),
                        i = Math.min(i, Math.max(0, i)),
                        this.lensFlares.push({
                            texture: t,
                            size: e,
                            distance: i,
                            x: 0,
                            y: 0,
                            z: 0,
                            scale: 1,
                            rotation: 0,
                            opacity: a,
                            color: r,
                            blending: n
                        })
                    },
                    updateLensFlares: function() {
                        var t, e, i = this.lensFlares.length, n = 2 * -this.positionScreen.x, r = 2 * -this.positionScreen.y;
                        for (t = 0; t < i; t++)
                            e = this.lensFlares[t],
                            e.x = this.positionScreen.x + n * e.distance,
                            e.y = this.positionScreen.y + r * e.distance,
                            e.wantedRotation = e.x * Math.PI * .25,
                            e.rotation += .25 * (e.wantedRotation - e.rotation)
                    }
                }),
                fe.prototype = Object.create(J.prototype),
                fe.prototype.constructor = fe,
                fe.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.rotation = t.rotation,
                    this
                }
                ,
                me.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: me,
                    isSprite: !0,
                    raycast: function() {
                        var t = new l;
                        return function(e, i) {
                            t.setFromMatrixPosition(this.matrixWorld);
                            var n = e.ray.distanceSqToPoint(t)
                              , r = this.scale.x * this.scale.y / 4;
                            n > r || i.push({
                                distance: Math.sqrt(n),
                                point: this.position,
                                face: null,
                                object: this
                            })
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.material).copy(this)
                    }
                }),
                ge.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: ge,
                    copy: function(t) {
                        zt.prototype.copy.call(this, t, !1);
                        for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                            var r = e[i];
                            this.addLevel(r.object.clone(), r.distance)
                        }
                        return this
                    },
                    addLevel: function(t, e) {
                        void 0 === e && (e = 0),
                        e = Math.abs(e);
                        for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++)
                            ;
                        i.splice(n, 0, {
                            distance: e,
                            object: t
                        }),
                        this.add(t)
                    },
                    getObjectForDistance: function(t) {
                        for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++)
                            ;
                        return e[i - 1].object
                    },
                    raycast: function() {
                        var t = new l;
                        return function(e, i) {
                            t.setFromMatrixPosition(this.matrixWorld);
                            var n = e.ray.origin.distanceTo(t);
                            this.getObjectForDistance(n).raycast(e, i)
                        }
                    }(),
                    update: function() {
                        var t = new l
                          , e = new l;
                        return function(i) {
                            var n = this.levels;
                            if (n.length > 1) {
                                t.setFromMatrixPosition(i.matrixWorld),
                                e.setFromMatrixPosition(this.matrixWorld);
                                var r = t.distanceTo(e);
                                n[0].object.visible = !0;
                                for (var a = 1, o = n.length; a < o && r >= n[a].distance; a++)
                                    n[a - 1].object.visible = !1,
                                    n[a].object.visible = !0;
                                for (; a < o; a++)
                                    n[a].object.visible = !1
                            }
                        }
                    }(),
                    toJSON: function(t) {
                        var e = zt.prototype.toJSON.call(this, t);
                        e.object.levels = [];
                        for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                            var a = i[n];
                            e.object.levels.push({
                                object: a.object.uuid,
                                distance: a.distance
                            })
                        }
                        return e
                    }
                }),
                ve.prototype = Object.create(r.prototype),
                ve.prototype.constructor = ve,
                ve.prototype.isDataTexture = !0,
                Object.assign(_e.prototype, {
                    calculateInverses: function() {
                        this.boneInverses = [];
                        for (var t = 0, e = this.bones.length; t < e; t++) {
                            var i = new o;
                            this.bones[t] && i.getInverse(this.bones[t].matrixWorld),
                            this.boneInverses.push(i)
                        }
                    },
                    pose: function() {
                        for (var t, e = 0, i = this.bones.length; e < i; e++)
                            t = this.bones[e],
                            t && t.matrixWorld.getInverse(this.boneInverses[e]);
                        for (var e = 0, i = this.bones.length; e < i; e++)
                            t = this.bones[e],
                            t && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld),
                            t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                            t.matrix.decompose(t.position, t.quaternion, t.scale))
                    },
                    update: function() {
                        var t = new o;
                        return function() {
                            for (var e = 0, i = this.bones.length; e < i; e++) {
                                var n = this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix;
                                t.multiplyMatrices(n, this.boneInverses[e]),
                                t.toArray(this.boneMatrices, 16 * e)
                            }
                            this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                        }
                    }(),
                    clone: function() {
                        return new _e(this.bones,this.boneInverses,this.useVertexTexture)
                    }
                }),
                ye.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: ye,
                    isBone: !0,
                    copy: function(t) {
                        return zt.prototype.copy.call(this, t),
                        this.skin = t.skin,
                        this
                    }
                }),
                xe.prototype = Object.assign(Object.create(re.prototype), {
                    constructor: xe,
                    isSkinnedMesh: !0,
                    bind: function(t, e) {
                        this.skeleton = t,
                        void 0 === e && (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        e = this.matrixWorld),
                        this.bindMatrix.copy(e),
                        this.bindMatrixInverse.getInverse(e)
                    },
                    pose: function() {
                        this.skeleton.pose()
                    },
                    normalizeSkinWeights: function() {
                        if (this.geometry && this.geometry.isGeometry)
                            for (var t = 0; t < this.geometry.skinWeights.length; t++) {
                                var e = this.geometry.skinWeights[t]
                                  , i = 1 / e.lengthManhattan();
                                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0)
                            }
                        else if (this.geometry && this.geometry.isBufferGeometry)
                            for (var n = new q, r = this.geometry.attributes.skinWeight, t = 0; t < r.count; t++) {
                                n.x = r.getX(t),
                                n.y = r.getY(t),
                                n.z = r.getZ(t),
                                n.w = r.getW(t);
                                var i = 1 / n.lengthManhattan();
                                i !== 1 / 0 ? n.multiplyScalar(i) : n.set(1, 0, 0, 0),
                                r.setXYZW(t, n.x, n.y, n.z, n.w)
                            }
                    },
                    updateMatrixWorld: function(t) {
                        re.prototype.updateMatrixWorld.call(this, !0),
                        "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
                    },
                    clone: function() {
                        return new this.constructor(this.geometry,this.material,this.skeleton.useVertexTexture).copy(this)
                    }
                }),
                be.prototype = Object.create(J.prototype),
                be.prototype.constructor = be,
                be.prototype.isLineBasicMaterial = !0,
                be.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.linewidth = t.linewidth,
                    this.linecap = t.linecap,
                    this.linejoin = t.linejoin,
                    this
                }
                ,
                we.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: we,
                    isLine: !0,
                    raycast: function() {
                        var t = new o
                          , e = new te
                          , i = new nt;
                        return function(n, r) {
                            var a = n.linePrecision
                              , o = a * a
                              , s = this.geometry
                              , h = this.matrixWorld;
                            if (null === s.boundingSphere && s.computeBoundingSphere(),
                            i.copy(s.boundingSphere),
                            i.applyMatrix4(h),
                            n.ray.intersectsSphere(i) !== !1) {
                                t.getInverse(h),
                                e.copy(n.ray).applyMatrix4(t);
                                var c = new l
                                  , u = new l
                                  , p = new l
                                  , d = new l
                                  , f = this && this.isLineSegments ? 2 : 1;
                                if (s && s.isBufferGeometry) {
                                    var m = s.index
                                      , g = s.attributes
                                      , v = g.position.array;
                                    if (null !== m)
                                        for (var _ = m.array, y = 0, x = _.length - 1; y < x; y += f) {
                                            var b = _[y]
                                              , w = _[y + 1];
                                            c.fromArray(v, 3 * b),
                                            u.fromArray(v, 3 * w);
                                            var M = e.distanceSqToSegment(c, u, d, p);
                                            if (!(M > o)) {
                                                d.applyMatrix4(this.matrixWorld);
                                                var T = n.ray.origin.distanceTo(d);
                                                T < n.near || T > n.far || r.push({
                                                    distance: T,
                                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                                    index: y,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        }
                                    else
                                        for (var y = 0, x = v.length / 3 - 1; y < x; y += f) {
                                            c.fromArray(v, 3 * y),
                                            u.fromArray(v, 3 * y + 3);
                                            var M = e.distanceSqToSegment(c, u, d, p);
                                            if (!(M > o)) {
                                                d.applyMatrix4(this.matrixWorld);
                                                var T = n.ray.origin.distanceTo(d);
                                                T < n.near || T > n.far || r.push({
                                                    distance: T,
                                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                                    index: y,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        }
                                } else if (s && s.isGeometry)
                                    for (var S = s.vertices, E = S.length, y = 0; y < E - 1; y += f) {
                                        var M = e.distanceSqToSegment(S[y], S[y + 1], d, p);
                                        if (!(M > o)) {
                                            d.applyMatrix4(this.matrixWorld);
                                            var T = n.ray.origin.distanceTo(d);
                                            T < n.near || T > n.far || r.push({
                                                distance: T,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: y,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                            }
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.geometry,this.material).copy(this)
                    }
                }),
                Me.prototype = Object.assign(Object.create(we.prototype), {
                    constructor: Me,
                    isLineSegments: !0
                }),
                Te.prototype = Object.create(J.prototype),
                Te.prototype.constructor = Te,
                Te.prototype.isPointsMaterial = !0,
                Te.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.size = t.size,
                    this.sizeAttenuation = t.sizeAttenuation,
                    this
                }
                ,
                Se.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: Se,
                    isPoints: !0,
                    raycast: function() {
                        var t = new o
                          , e = new te
                          , i = new nt;
                        return function(n, r) {
                            function a(t, i) {
                                var a = e.distanceSqToPoint(t);
                                if (a < p) {
                                    var s = e.closestPointToPoint(t);
                                    s.applyMatrix4(h);
                                    var l = n.ray.origin.distanceTo(s);
                                    if (l < n.near || l > n.far)
                                        return;
                                    r.push({
                                        distance: l,
                                        distanceToRay: Math.sqrt(a),
                                        point: s.clone(),
                                        index: i,
                                        face: null,
                                        object: o
                                    })
                                }
                            }
                            var o = this
                              , s = this.geometry
                              , h = this.matrixWorld
                              , c = n.params.Points.threshold;
                            if (null === s.boundingSphere && s.computeBoundingSphere(),
                            i.copy(s.boundingSphere),
                            i.applyMatrix4(h),
                            n.ray.intersectsSphere(i) !== !1) {
                                t.getInverse(h),
                                e.copy(n.ray).applyMatrix4(t);
                                var u = c / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                                  , p = u * u
                                  , d = new l;
                                if (s && s.isBufferGeometry) {
                                    var f = s.index
                                      , m = s.attributes
                                      , g = m.position.array;
                                    if (null !== f)
                                        for (var v = f.array, _ = 0, y = v.length; _ < y; _++) {
                                            var x = v[_];
                                            d.fromArray(g, 3 * x),
                                            a(d, x)
                                        }
                                    else
                                        for (var _ = 0, b = g.length / 3; _ < b; _++)
                                            d.fromArray(g, 3 * _),
                                            a(d, _)
                                } else
                                    for (var w = s.vertices, _ = 0, b = w.length; _ < b; _++)
                                        a(w[_], _)
                            }
                        }
                    }(),
                    clone: function() {
                        return new this.constructor(this.geometry,this.material).copy(this)
                    }
                }),
                Ee.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: Ee
                }),
                Ae.prototype = Object.create(r.prototype),
                Ae.prototype.constructor = Ae,
                Pe.prototype = Object.create(r.prototype),
                Pe.prototype.constructor = Pe,
                Pe.prototype.isCompressedTexture = !0,
                Re.prototype = Object.create(r.prototype),
                Re.prototype.constructor = Re,
                Le.prototype = Object.create(r.prototype),
                Le.prototype.constructor = Le,
                Le.prototype.isDepthTexture = !0,
                Ce.prototype = Object.create($.prototype),
                Ce.prototype.constructor = Ce,
                Ce.prototype.isShadowMaterial = !0,
                Oe.prototype = Object.create($.prototype),
                Oe.prototype.constructor = Oe,
                Oe.prototype.isRawShaderMaterial = !0,
                Ie.prototype = {
                    constructor: Ie,
                    isMultiMaterial: !0,
                    toJSON: function(t) {
                        for (var e = {
                            metadata: {
                                version: 4.2,
                                type: "material",
                                generator: "MaterialExporter"
                            },
                            uuid: this.uuid,
                            type: this.type,
                            materials: []
                        }, i = this.materials, n = 0, r = i.length; n < r; n++) {
                            var a = i[n].toJSON(t);
                            delete a.metadata,
                            e.materials.push(a)
                        }
                        return e.visible = this.visible,
                        e
                    },
                    clone: function() {
                        for (var t = new this.constructor, e = 0; e < this.materials.length; e++)
                            t.materials.push(this.materials[e].clone());
                        return t.visible = this.visible,
                        t
                    }
                },
                De.prototype = Object.create(J.prototype),
                De.prototype.constructor = De,
                De.prototype.isMeshStandardMaterial = !0,
                De.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.color.copy(t.color),
                    this.roughness = t.roughness,
                    this.metalness = t.metalness,
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.roughnessMap = t.roughnessMap,
                    this.metalnessMap = t.metalnessMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.envMapIntensity = t.envMapIntensity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this
                }
                ,
                Ue.prototype = Object.create(De.prototype),
                Ue.prototype.constructor = Ue,
                Ue.prototype.isMeshPhysicalMaterial = !0,
                Ue.prototype.copy = function(t) {
                    return De.prototype.copy.call(this, t),
                    this.defines = {
                        PHYSICAL: ""
                    },
                    this.reflectivity = t.reflectivity,
                    this.clearCoat = t.clearCoat,
                    this.clearCoatRoughness = t.clearCoatRoughness,
                    this
                }
                ,
                Fe.prototype = Object.create(J.prototype),
                Fe.prototype.constructor = Fe,
                Fe.prototype.isMeshPhongMaterial = !0,
                Fe.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.specular.copy(t.specular),
                    this.shininess = t.shininess,
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.bumpMap = t.bumpMap,
                    this.bumpScale = t.bumpScale,
                    this.normalMap = t.normalMap,
                    this.normalScale.copy(t.normalScale),
                    this.displacementMap = t.displacementMap,
                    this.displacementScale = t.displacementScale,
                    this.displacementBias = t.displacementBias,
                    this.specularMap = t.specularMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.combine = t.combine,
                    this.reflectivity = t.reflectivity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this
                }
                ,
                Ne.prototype = Object.create(J.prototype),
                Ne.prototype.constructor = Ne,
                Ne.prototype.isMeshNormalMaterial = !0,
                Ne.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this
                }
                ,
                ze.prototype = Object.create(J.prototype),
                ze.prototype.constructor = ze,
                ze.prototype.isMeshLambertMaterial = !0,
                ze.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.map = t.map,
                    this.lightMap = t.lightMap,
                    this.lightMapIntensity = t.lightMapIntensity,
                    this.aoMap = t.aoMap,
                    this.aoMapIntensity = t.aoMapIntensity,
                    this.emissive.copy(t.emissive),
                    this.emissiveMap = t.emissiveMap,
                    this.emissiveIntensity = t.emissiveIntensity,
                    this.specularMap = t.specularMap,
                    this.alphaMap = t.alphaMap,
                    this.envMap = t.envMap,
                    this.combine = t.combine,
                    this.reflectivity = t.reflectivity,
                    this.refractionRatio = t.refractionRatio,
                    this.wireframe = t.wireframe,
                    this.wireframeLinewidth = t.wireframeLinewidth,
                    this.wireframeLinecap = t.wireframeLinecap,
                    this.wireframeLinejoin = t.wireframeLinejoin,
                    this.skinning = t.skinning,
                    this.morphTargets = t.morphTargets,
                    this.morphNormals = t.morphNormals,
                    this
                }
                ,
                Be.prototype = Object.create(J.prototype),
                Be.prototype.constructor = Be,
                Be.prototype.isLineDashedMaterial = !0,
                Be.prototype.copy = function(t) {
                    return J.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.linewidth = t.linewidth,
                    this.scale = t.scale,
                    this.dashSize = t.dashSize,
                    this.gapSize = t.gapSize,
                    this
                }
                ,
                e.Cache = {
                    enabled: !1,
                    files: {},
                    add: function(t, e) {
                        this.enabled !== !1 && (this.files[t] = e)
                    },
                    get: function(t) {
                        if (this.enabled !== !1)
                            return this.files[t]
                    },
                    remove: function(t) {
                        delete this.files[t]
                    },
                    clear: function() {
                        this.files = {}
                    }
                },
                e.DefaultLoadingManager = new ke,
                Object.assign(Ge.prototype, {
                    load: function(t, i, n, r) {
                        void 0 !== this.path && (t = this.path + t);
                        var a = this
                          , o = e.Cache.get(t);
                        if (void 0 !== o)
                            return a.manager.itemStart(t),
                            setTimeout(function() {
                                i && i(o),
                                a.manager.itemEnd(t)
                            }, 0),
                            o;
                        var s = new XMLHttpRequest;
                        return s.open("GET", t, !0),
                        s.addEventListener("load", function(n) {
                            var o = n.target.response;
                            e.Cache.add(t, o),
                            200 === this.status ? (i && i(o),
                            a.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."),
                            i && i(o),
                            a.manager.itemEnd(t)) : (r && r(n),
                            a.manager.itemError(t))
                        }, !1),
                        void 0 !== n && s.addEventListener("progress", function(t) {
                            n(t)
                        }, !1),
                        s.addEventListener("error", function(e) {
                            r && r(e),
                            a.manager.itemError(t)
                        }, !1),
                        void 0 !== this.responseType && (s.responseType = this.responseType),
                        void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials),
                        s.overrideMimeType && s.overrideMimeType("text/plain"),
                        s.send(null),
                        a.manager.itemStart(t),
                        s
                    },
                    setPath: function(t) {
                        return this.path = t,
                        this
                    },
                    setResponseType: function(t) {
                        return this.responseType = t,
                        this
                    },
                    setWithCredentials: function(t) {
                        return this.withCredentials = t,
                        this
                    }
                }),
                Object.assign(Ve.prototype, {
                    load: function(t, e, i, n) {
                        function r(r) {
                            l.load(t[r], function(t) {
                                var i = a._parser(t, !0);
                                o[r] = {
                                    width: i.width,
                                    height: i.height,
                                    format: i.format,
                                    mipmaps: i.mipmaps
                                },
                                h += 1,
                                6 === h && (1 === i.mipmapCount && (s.minFilter = Ea),
                                s.format = i.format,
                                s.needsUpdate = !0,
                                e && e(s))
                            }, i, n)
                        }
                        var a = this
                          , o = []
                          , s = new Pe;
                        s.image = o;
                        var l = new Ge(this.manager);
                        if (l.setPath(this.path),
                        l.setResponseType("arraybuffer"),
                        Array.isArray(t))
                            for (var h = 0, c = 0, u = t.length; c < u; ++c)
                                r(c);
                        else
                            l.load(t, function(t) {
                                var i = a._parser(t, !0);
                                if (i.isCubemap)
                                    for (var n = i.mipmaps.length / i.mipmapCount, r = 0; r < n; r++) {
                                        o[r] = {
                                            mipmaps: []
                                        };
                                        for (var l = 0; l < i.mipmapCount; l++)
                                            o[r].mipmaps.push(i.mipmaps[r * i.mipmapCount + l]),
                                            o[r].format = i.format,
                                            o[r].width = i.width,
                                            o[r].height = i.height
                                    }
                                else
                                    s.image.width = i.width,
                                    s.image.height = i.height,
                                    s.mipmaps = i.mipmaps;
                                1 === i.mipmapCount && (s.minFilter = Ea),
                                s.format = i.format,
                                s.needsUpdate = !0,
                                e && e(s)
                            }, i, n);
                        return s
                    },
                    setPath: function(t) {
                        return this.path = t,
                        this
                    }
                });
                var Nl = He;
                Object.assign(He.prototype, {
                    load: function(t, e, i, n) {
                        var r = this
                          , a = new ve
                          , o = new Ge(this.manager);
                        return o.setResponseType("arraybuffer"),
                        o.load(t, function(t) {
                            var i = r._parser(t);
                            i && (void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a.image.width = i.width,
                            a.image.height = i.height,
                            a.image.data = i.data),
                            a.wrapS = void 0 !== i.wrapS ? i.wrapS : ba,
                            a.wrapT = void 0 !== i.wrapT ? i.wrapT : ba,
                            a.magFilter = void 0 !== i.magFilter ? i.magFilter : Ea,
                            a.minFilter = void 0 !== i.minFilter ? i.minFilter : Pa,
                            a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1,
                            void 0 !== i.format && (a.format = i.format),
                            void 0 !== i.type && (a.type = i.type),
                            void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps),
                            1 === i.mipmapCount && (a.minFilter = Ea),
                            a.needsUpdate = !0,
                            e && e(a, i))
                        }, i, n),
                        a
                    }
                }),
                Object.assign(je.prototype, {
                    load: function(t, e, i, n) {
                        var r = this
                          , a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                        if (a.onload = function() {
                            URL.revokeObjectURL(a.src),
                            e && e(a),
                            r.manager.itemEnd(t)
                        }
                        ,
                        0 === t.indexOf("data:"))
                            a.src = t;
                        else {
                            var o = new Ge;
                            o.setPath(this.path),
                            o.setResponseType("blob"),
                            o.setWithCredentials(this.withCredentials),
                            o.load(t, function(t) {
                                a.src = URL.createObjectURL(t)
                            }, i, n)
                        }
                        return r.manager.itemStart(t),
                        a
                    },
                    setCrossOrigin: function(t) {
                        return this.crossOrigin = t,
                        this
                    },
                    setWithCredentials: function(t) {
                        return this.withCredentials = t,
                        this
                    },
                    setPath: function(t) {
                        return this.path = t,
                        this
                    }
                }),
                Object.assign(We.prototype, {
                    load: function(t, e, i, n) {
                        function r(i) {
                            o.load(t[i], function(t) {
                                a.images[i] = t,
                                s++,
                                6 === s && (a.needsUpdate = !0,
                                e && e(a))
                            }, void 0, n)
                        }
                        var a = new p
                          , o = new je(this.manager);
                        o.setCrossOrigin(this.crossOrigin),
                        o.setPath(this.path);
                        for (var s = 0, l = 0; l < t.length; ++l)
                            r(l);
                        return a
                    },
                    setCrossOrigin: function(t) {
                        return this.crossOrigin = t,
                        this
                    },
                    setPath: function(t) {
                        return this.path = t,
                        this
                    }
                }),
                Object.assign(Xe.prototype, {
                    load: function(t, e, i, n) {
                        var a = new r
                          , o = new je(this.manager);
                        return o.setCrossOrigin(this.crossOrigin),
                        o.setWithCredentials(this.withCredentials),
                        o.setPath(this.path),
                        o.load(t, function(i) {
                            var n = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                            a.format = n ? Va : Ha,
                            a.image = i,
                            a.needsUpdate = !0,
                            void 0 !== e && e(a)
                        }, i, n),
                        a
                    },
                    setCrossOrigin: function(t) {
                        return this.crossOrigin = t,
                        this
                    },
                    setWithCredentials: function(t) {
                        return this.withCredentials = t,
                        this
                    },
                    setPath: function(t) {
                        return this.path = t,
                        this
                    }
                }),
                Ye.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: Ye,
                    isLight: !0,
                    copy: function(t) {
                        return zt.prototype.copy.call(this, t),
                        this.color.copy(t.color),
                        this.intensity = t.intensity,
                        this
                    },
                    toJSON: function(t) {
                        var e = zt.prototype.toJSON.call(this, t);
                        return e.object.color = this.color.getHex(),
                        e.object.intensity = this.intensity,
                        void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                        void 0 !== this.distance && (e.object.distance = this.distance),
                        void 0 !== this.angle && (e.object.angle = this.angle),
                        void 0 !== this.decay && (e.object.decay = this.decay),
                        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
                        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                        e
                    }
                }),
                qe.prototype = Object.assign(Object.create(Ye.prototype), {
                    constructor: qe,
                    isHemisphereLight: !0,
                    copy: function(t) {
                        return Ye.prototype.copy.call(this, t),
                        this.groundColor.copy(t.groundColor),
                        this
                    }
                }),
                Object.assign(Ze.prototype, {
                    copy: function(t) {
                        return this.camera = t.camera.clone(),
                        this.bias = t.bias,
                        this.radius = t.radius,
                        this.mapSize.copy(t.mapSize),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    toJSON: function() {
                        var t = {};
                        return 0 !== this.bias && (t.bias = this.bias),
                        1 !== this.radius && (t.radius = this.radius),
                        512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                        t.camera = this.camera.toJSON(!1).object,
                        delete t.camera.matrix,
                        t
                    }
                }),
                Qe.prototype = Object.assign(Object.create(Ze.prototype), {
                    constructor: Qe,
                    isSpotLightShadow: !0,
                    update: function(t) {
                        var i = 2 * e.Math.RAD2DEG * t.angle
                          , n = this.mapSize.width / this.mapSize.height
                          , r = t.distance || 500
                          , a = this.camera;
                        i === a.fov && n === a.aspect && r === a.far || (a.fov = i,
                        a.aspect = n,
                        a.far = r,
                        a.updateProjectionMatrix())
                    }
                }),
                Je.prototype = Object.assign(Object.create(Ye.prototype), {
                    constructor: Je,
                    isSpotLight: !0,
                    copy: function(t) {
                        return Ye.prototype.copy.call(this, t),
                        this.distance = t.distance,
                        this.angle = t.angle,
                        this.penumbra = t.penumbra,
                        this.decay = t.decay,
                        this.target = t.target.clone(),
                        this.shadow = t.shadow.clone(),
                        this
                    }
                }),
                Ke.prototype = Object.assign(Object.create(Ye.prototype), {
                    constructor: Ke,
                    isPointLight: !0,
                    copy: function(t) {
                        return Ye.prototype.copy.call(this, t),
                        this.distance = t.distance,
                        this.decay = t.decay,
                        this.shadow = t.shadow.clone(),
                        this
                    }
                }),
                $e.prototype = Object.assign(Object.create(Ze.prototype), {
                    constructor: $e
                }),
                ti.prototype = Object.assign(Object.create(Ye.prototype), {
                    constructor: ti,
                    isDirectionalLight: !0,
                    copy: function(t) {
                        return Ye.prototype.copy.call(this, t),
                        this.target = t.target.clone(),
                        this.shadow = t.shadow.clone(),
                        this
                    }
                }),
                ei.prototype = Object.assign(Object.create(Ye.prototype), {
                    constructor: ei,
                    isAmbientLight: !0
                }),
                e.AnimationUtils = {
                    arraySlice: function(t, i, n) {
                        return e.AnimationUtils.isTypedArray(t) ? new t.constructor(t.subarray(i, n)) : t.slice(i, n)
                    },
                    convertArray: function(t, e, i) {
                        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        function e(e, i) {
                            return t[e] - t[i]
                        }
                        for (var i = t.length, n = new Array(i), r = 0; r !== i; ++r)
                            n[r] = r;
                        return n.sort(e),
                        n
                    },
                    sortedArray: function(t, e, i) {
                        for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
                            for (var s = i[a] * e, l = 0; l !== e; ++l)
                                r[o++] = t[s + l];
                        return r
                    },
                    flattenJSON: function(t, e, i, n) {
                        for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n]; )
                            a = t[r++];
                        if (void 0 !== a) {
                            var o = a[n];
                            if (void 0 !== o)
                                if (Array.isArray(o)) {
                                    do
                                        o = a[n],
                                        void 0 !== o && (e.push(a.time),
                                        i.push.apply(i, o)),
                                        a = t[r++];
                                    while (void 0 !== a)
                                } else if (void 0 !== o.toArray) {
                                    do
                                        o = a[n],
                                        void 0 !== o && (e.push(a.time),
                                        o.toArray(i, i.length)),
                                        a = t[r++];
                                    while (void 0 !== a)
                                } else
                                    do
                                        o = a[n],
                                        void 0 !== o && (e.push(a.time),
                                        i.push(o)),
                                        a = t[r++];
                                    while (void 0 !== a)
                        }
                    }
                },
                ii.prototype = {
                    constructor: ii,
                    evaluate: function(t) {
                        var e = this.parameterPositions
                          , i = this._cachedIndex
                          , n = e[i]
                          , r = e[i - 1];
                        t: {
                            e: {
                                var a;
                                i: {
                                    n: if (!(t < n)) {
                                        for (var o = i + 2; ; ) {
                                            if (void 0 === n) {
                                                if (t < r)
                                                    break n;
                                                return i = e.length,
                                                this._cachedIndex = i,
                                                this.afterEnd_(i - 1, t, r)
                                            }
                                            if (i === o)
                                                break;
                                            if (r = n,
                                            n = e[++i],
                                            t < n)
                                                break e
                                        }
                                        a = e.length;
                                        break i
                                    }
                                    {
                                        if (t >= r)
                                            break t;
                                        var s = e[1];
                                        t < s && (i = 2,
                                        r = s);
                                        for (var o = i - 2; ; ) {
                                            if (void 0 === r)
                                                return this._cachedIndex = 0,
                                                this.beforeStart_(0, t, n);
                                            if (i === o)
                                                break;
                                            if (n = r,
                                            r = e[--i - 1],
                                            t >= r)
                                                break e
                                        }
                                        a = i,
                                        i = 0
                                    }
                                }
                                for (; i < a; ) {
                                    var l = i + a >>> 1;
                                    t < e[l] ? a = l : i = l + 1
                                }
                                if (n = e[i],
                                r = e[i - 1],
                                void 0 === r)
                                    return this._cachedIndex = 0,
                                    this.beforeStart_(0, t, n);
                                if (void 0 === n)
                                    return i = e.length,
                                    this._cachedIndex = i,
                                    this.afterEnd_(i - 1, r, t)
                            }
                            this._cachedIndex = i,
                            this.intervalChanged_(i, r, n)
                        }
                        return this.interpolate_(i, r, t, n)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(t) {
                        for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, a = 0; a !== n; ++a)
                            e[a] = i[r + a];
                        return e
                    },
                    interpolate_: function(t, e, i, n) {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function(t, e, i) {}
                },
                Object.assign(ii.prototype, {
                    beforeStart_: ii.prototype.copySampleValue_,
                    afterEnd_: ii.prototype.copySampleValue_
                }),
                ni.prototype = Object.assign(Object.create(ii.prototype), {
                    constructor: ni,
                    DefaultSettings_: {
                        endingStart: co,
                        endingEnd: co
                    },
                    intervalChanged_: function(t, e, i) {
                        var n = this.parameterPositions
                          , r = t - 2
                          , a = t + 1
                          , o = n[r]
                          , s = n[a];
                        if (void 0 === o)
                            switch (this.getSettings_().endingStart) {
                            case uo:
                                r = t,
                                o = 2 * e - i;
                                break;
                            case po:
                                r = n.length - 2,
                                o = e + n[r] - n[r + 1];
                                break;
                            default:
                                r = t,
                                o = i
                            }
                        if (void 0 === s)
                            switch (this.getSettings_().endingEnd) {
                            case uo:
                                a = t,
                                s = 2 * i - e;
                                break;
                            case po:
                                a = 1,
                                s = i + n[1] - n[0];
                                break;
                            default:
                                a = t - 1,
                                s = e
                            }
                        var l = .5 * (i - e)
                          , h = this.valueSize;
                        this._weightPrev = l / (e - o),
                        this._weightNext = l / (s - i),
                        this._offsetPrev = r * h,
                        this._offsetNext = a * h
                    },
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, l = s - o, h = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - e) / (n - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, _ = (-1 - p) * m + (1.5 + p) * f + .5 * d, y = p * m - p * f, x = 0; x !== o; ++x)
                            r[x] = g * a[h + x] + v * a[l + x] + _ * a[s + x] + y * a[c + x];
                        return r
                    }
                }),
                ri.prototype = Object.assign(Object.create(ii.prototype), {
                    constructor: ri,
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, l = s - o, h = (i - e) / (n - e), c = 1 - h, u = 0; u !== o; ++u)
                            r[u] = a[l + u] * c + a[s + u] * h;
                        return r
                    }
                }),
                ai.prototype = Object.assign(Object.create(ii.prototype), {
                    constructor: ai,
                    interpolate_: function(t, e, i, n) {
                        return this.copySampleValue_(t - 1)
                    }
                });
                var zl;
                zl = {
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: lo,
                    InterpolantFactoryMethodDiscrete: function(t) {
                        return new ai(this.times,this.values,this.getValueSize(),t)
                    },
                    InterpolantFactoryMethodLinear: function(t) {
                        return new ri(this.times,this.values,this.getValueSize(),t)
                    },
                    InterpolantFactoryMethodSmooth: function(t) {
                        return new ni(this.times,this.values,this.getValueSize(),t)
                    },
                    setInterpolation: function(t) {
                        var e;
                        switch (t) {
                        case so:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case lo:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case ho:
                            e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation)
                                    throw new Error(i);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return void console.warn(i)
                        }
                        this.createInterpolant = e
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return so;
                        case this.InterpolantFactoryMethodLinear:
                            return lo;
                        case this.InterpolantFactoryMethodSmooth:
                            return ho
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(t) {
                        if (0 !== t)
                            for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
                                e[i] += t;
                        return this
                    },
                    scale: function(t) {
                        if (1 !== t)
                            for (var e = this.times, i = 0, n = e.length; i !== n; ++i)
                                e[i] *= t;
                        return this
                    },
                    trim: function(t, i) {
                        for (var n = this.times, r = n.length, a = 0, o = r - 1; a !== r && n[a] < t; )
                            ++a;
                        for (; o !== -1 && n[o] > i; )
                            --o;
                        if (++o,
                        0 !== a || o !== r) {
                            a >= o && (o = Math.max(o, 1),
                            a = o - 1);
                            var s = this.getValueSize();
                            this.times = e.AnimationUtils.arraySlice(n, a, o),
                            this.values = e.AnimationUtils.arraySlice(this.values, a * s, o * s)
                        }
                        return this
                    },
                    validate: function() {
                        var t = !0
                          , i = this.getValueSize();
                        i - Math.floor(i) !== 0 && (console.error("invalid value size in track", this),
                        t = !1);
                        var n = this.times
                          , r = this.values
                          , a = n.length;
                        0 === a && (console.error("track is empty", this),
                        t = !1);
                        for (var o = null, s = 0; s !== a; s++) {
                            var l = n[s];
                            if ("number" == typeof l && isNaN(l)) {
                                console.error("time is not a valid number", this, s, l),
                                t = !1;
                                break
                            }
                            if (null !== o && o > l) {
                                console.error("out of order keys", this, s, l, o),
                                t = !1;
                                break
                            }
                            o = l
                        }
                        if (void 0 !== r && e.AnimationUtils.isTypedArray(r))
                            for (var s = 0, h = r.length; s !== h; ++s) {
                                var c = r[s];
                                if (isNaN(c)) {
                                    console.error("value is not a valid number", this, s, c),
                                    t = !1;
                                    break
                                }
                            }
                        return t
                    },
                    optimize: function() {
                        for (var t = this.times, i = this.values, n = this.getValueSize(), r = 1, a = 1, o = t.length - 1; a <= o; ++a) {
                            var s = !1
                              , l = t[a]
                              , h = t[a + 1];
                            if (l !== h && (1 !== a || l !== l[0]))
                                for (var c = a * n, u = c - n, p = c + n, d = 0; d !== n; ++d) {
                                    var f = i[c + d];
                                    if (f !== i[u + d] || f !== i[p + d]) {
                                        s = !0;
                                        break
                                    }
                                }
                            if (s) {
                                if (a !== r) {
                                    t[r] = t[a];
                                    for (var m = a * n, g = r * n, d = 0; d !== n; ++d)
                                        i[g + d] = i[m + d]
                                }
                                ++r
                            }
                        }
                        return r !== t.length && (this.times = e.AnimationUtils.arraySlice(t, 0, r),
                        this.values = e.AnimationUtils.arraySlice(i, 0, r * n)),
                        this
                    }
                },
                si.prototype = Object.assign(Object.create(zl), {
                    constructor: si,
                    ValueTypeName: "vector"
                }),
                li.prototype = Object.assign(Object.create(ii.prototype), {
                    constructor: li,
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = t * o, h = (i - e) / (n - e), c = l + o; l !== c; l += 4)
                            s.slerpFlat(r, 0, a, l - o, a, l, h);
                        return r
                    }
                }),
                hi.prototype = Object.assign(Object.create(zl), {
                    constructor: hi,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: lo,
                    InterpolantFactoryMethodLinear: function(t) {
                        return new li(this.times,this.values,this.getValueSize(),t)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }),
                ci.prototype = Object.assign(Object.create(zl), {
                    constructor: ci,
                    ValueTypeName: "number"
                }),
                ui.prototype = Object.assign(Object.create(zl), {
                    constructor: ui,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: so,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }),
                pi.prototype = Object.assign(Object.create(zl), {
                    constructor: pi,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: so,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }),
                di.prototype = Object.assign(Object.create(zl), {
                    constructor: di,
                    ValueTypeName: "color"
                }),
                fi.prototype = zl,
                zl.constructor = fi,
                Object.assign(fi, {
                    parse: function(t) {
                        if (void 0 === t.type)
                            throw new Error("track type undefined, can not parse");
                        var i = fi._getTrackTypeForValueTypeName(t.type);
                        if (void 0 === t.times) {
                            var n = []
                              , r = [];
                            e.AnimationUtils.flattenJSON(t.keys, n, r, "value"),
                            t.times = n,
                            t.values = r
                        }
                        return void 0 !== i.parse ? i.parse(t) : new i(t.name,t.times,t.values,t.interpolation)
                    },
                    toJSON: function(t) {
                        var i, n = t.constructor;
                        if (void 0 !== n.toJSON)
                            i = n.toJSON(t);
                        else {
                            i = {
                                name: t.name,
                                times: e.AnimationUtils.convertArray(t.times, Array),
                                values: e.AnimationUtils.convertArray(t.values, Array)
                            };
                            var r = t.getInterpolation();
                            r !== t.DefaultInterpolation && (i.interpolation = r)
                        }
                        return i.type = t.ValueTypeName,
                        i
                    },
                    _getTrackTypeForValueTypeName: function(t) {
                        switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return ci;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return si;
                        case "color":
                            return di;
                        case "quaternion":
                            return hi;
                        case "bool":
                        case "boolean":
                            return pi;
                        case "string":
                            return ui
                        }
                        throw new Error("Unsupported typeName: " + t)
                    }
                }),
                mi.prototype = {
                    constructor: mi,
                    resetDuration: function() {
                        for (var t = this.tracks, e = 0, i = 0, n = t.length; i !== n; ++i) {
                            var r = this.tracks[i];
                            e = Math.max(e, r.times[r.times.length - 1])
                        }
                        this.duration = e
                    },
                    trim: function() {
                        for (var t = 0; t < this.tracks.length; t++)
                            this.tracks[t].trim(0, this.duration);
                        return this
                    },
                    optimize: function() {
                        for (var t = 0; t < this.tracks.length; t++)
                            this.tracks[t].optimize();
                        return this
                    }
                },
                Object.assign(mi, {
                    parse: function(t) {
                        for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r)
                            e.push(fi.parse(i[r]).scale(n));
                        return new mi(t.name,t.duration,e)
                    },
                    toJSON: function(t) {
                        for (var e = [], i = t.tracks, n = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e
                        }, r = 0, a = i.length; r !== a; ++r)
                            e.push(fi.toJSON(i[r]));
                        return n
                    },
                    CreateFromMorphTargetSequence: function(t, i, n, r) {
                        for (var a = i.length, o = [], s = 0; s < a; s++) {
                            var l = []
                              , h = [];
                            l.push((s + a - 1) % a, s, (s + 1) % a),
                            h.push(0, 1, 0);
                            var c = e.AnimationUtils.getKeyframeOrder(l);
                            l = e.AnimationUtils.sortedArray(l, 1, c),
                            h = e.AnimationUtils.sortedArray(h, 1, c),
                            r || 0 !== l[0] || (l.push(a),
                            h.push(h[0])),
                            o.push(new ci(".morphTargetInfluences[" + i[s].name + "]",l,h).scale(1 / n))
                        }
                        return new mi(t,-1,o)
                    },
                    findByName: function(t, e) {
                        var i = t;
                        if (!Array.isArray(t)) {
                            var n = t;
                            i = n.geometry && n.geometry.animations || n.animations
                        }
                        for (var r = 0; r < i.length; r++)
                            if (i[r].name === e)
                                return i[r];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(t, e, i) {
                        for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                            var s = t[a]
                              , l = s.name.match(r);
                            if (l && l.length > 1) {
                                var h = l[1]
                                  , c = n[h];
                                c || (n[h] = c = []),
                                c.push(s)
                            }
                        }
                        var u = [];
                        for (var h in n)
                            u.push(mi.CreateFromMorphTargetSequence(h, n[h], e, i));
                        return u
                    },
                    parseAnimation: function(t, i, n) {
                        if (!t)
                            return console.error("  no animation in JSONLoader data"),
                            null;
                        for (var r = function(t, i, n, r, a) {
                            if (0 !== n.length) {
                                var o = []
                                  , s = [];
                                e.AnimationUtils.flattenJSON(n, o, s, r),
                                0 !== o.length && a.push(new t(i,o,s))
                            }
                        }, a = [], o = t.name || "default", s = t.length || -1, l = t.fps || 30, h = t.hierarchy || [], c = 0; c < h.length; c++) {
                            var u = h[c].keys;
                            if (u && 0 !== u.length)
                                if (u[0].morphTargets) {
                                    for (var p = {}, d = 0; d < u.length; d++)
                                        if (u[d].morphTargets)
                                            for (var f = 0; f < u[d].morphTargets.length; f++)
                                                p[u[d].morphTargets[f]] = -1;
                                    for (var m in p) {
                                        for (var g = [], v = [], f = 0; f !== u[d].morphTargets.length; ++f) {
                                            var _ = u[d];
                                            g.push(_.time),
                                            v.push(_.morphTarget === m ? 1 : 0)
                                        }
                                        a.push(new ci(".morphTargetInfluence[" + m + "]",g,v))
                                    }
                                    s = p.length * (l || 1)
                                } else {
                                    var y = ".bones[" + i[c].name + "]";
                                    r(si, y + ".position", u, "pos", a),
                                    r(hi, y + ".quaternion", u, "rot", a),
                                    r(si, y + ".scale", u, "scl", a)
                                }
                        }
                        if (0 === a.length)
                            return null;
                        var x = new mi(o,s,a);
                        return x
                    }
                }),
                Object.assign(gi.prototype, {
                    load: function(t, e, i, n) {
                        var r = this
                          , a = new Ge(r.manager);
                        a.load(t, function(t) {
                            e(r.parse(JSON.parse(t)))
                        }, i, n)
                    },
                    setTextures: function(t) {
                        this.textures = t
                    },
                    parse: function(e) {
                        function i(t) {
                            return void 0 === r[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                            r[t]
                        }
                        var r = this.textures
                          , a = new t[e.type];
                        if (void 0 !== e.uuid && (a.uuid = e.uuid),
                        void 0 !== e.name && (a.name = e.name),
                        void 0 !== e.color && a.color.setHex(e.color),
                        void 0 !== e.roughness && (a.roughness = e.roughness),
                        void 0 !== e.metalness && (a.metalness = e.metalness),
                        void 0 !== e.emissive && a.emissive.setHex(e.emissive),
                        void 0 !== e.specular && a.specular.setHex(e.specular),
                        void 0 !== e.shininess && (a.shininess = e.shininess),
                        void 0 !== e.uniforms && (a.uniforms = e.uniforms),
                        void 0 !== e.vertexShader && (a.vertexShader = e.vertexShader),
                        void 0 !== e.fragmentShader && (a.fragmentShader = e.fragmentShader),
                        void 0 !== e.vertexColors && (a.vertexColors = e.vertexColors),
                        void 0 !== e.fog && (a.fog = e.fog),
                        void 0 !== e.shading && (a.shading = e.shading),
                        void 0 !== e.blending && (a.blending = e.blending),
                        void 0 !== e.side && (a.side = e.side),
                        void 0 !== e.opacity && (a.opacity = e.opacity),
                        void 0 !== e.transparent && (a.transparent = e.transparent),
                        void 0 !== e.alphaTest && (a.alphaTest = e.alphaTest),
                        void 0 !== e.depthTest && (a.depthTest = e.depthTest),
                        void 0 !== e.depthWrite && (a.depthWrite = e.depthWrite),
                        void 0 !== e.colorWrite && (a.colorWrite = e.colorWrite),
                        void 0 !== e.wireframe && (a.wireframe = e.wireframe),
                        void 0 !== e.wireframeLinewidth && (a.wireframeLinewidth = e.wireframeLinewidth),
                        void 0 !== e.wireframeLinecap && (a.wireframeLinecap = e.wireframeLinecap),
                        void 0 !== e.wireframeLinejoin && (a.wireframeLinejoin = e.wireframeLinejoin),
                        void 0 !== e.skinning && (a.skinning = e.skinning),
                        void 0 !== e.morphTargets && (a.morphTargets = e.morphTargets),
                        void 0 !== e.size && (a.size = e.size),
                        void 0 !== e.sizeAttenuation && (a.sizeAttenuation = e.sizeAttenuation),
                        void 0 !== e.map && (a.map = i(e.map)),
                        void 0 !== e.alphaMap && (a.alphaMap = i(e.alphaMap),
                        a.transparent = !0),
                        void 0 !== e.bumpMap && (a.bumpMap = i(e.bumpMap)),
                        void 0 !== e.bumpScale && (a.bumpScale = e.bumpScale),
                        void 0 !== e.normalMap && (a.normalMap = i(e.normalMap)),
                        void 0 !== e.normalScale) {
                            var o = e.normalScale;
                            Array.isArray(o) === !1 && (o = [o, o]),
                            a.normalScale = (new n).fromArray(o)
                        }
                        if (void 0 !== e.displacementMap && (a.displacementMap = i(e.displacementMap)),
                        void 0 !== e.displacementScale && (a.displacementScale = e.displacementScale),
                        void 0 !== e.displacementBias && (a.displacementBias = e.displacementBias),
                        void 0 !== e.roughnessMap && (a.roughnessMap = i(e.roughnessMap)),
                        void 0 !== e.metalnessMap && (a.metalnessMap = i(e.metalnessMap)),
                        void 0 !== e.emissiveMap && (a.emissiveMap = i(e.emissiveMap)),
                        void 0 !== e.emissiveIntensity && (a.emissiveIntensity = e.emissiveIntensity),
                        void 0 !== e.specularMap && (a.specularMap = i(e.specularMap)),
                        void 0 !== e.envMap && (a.envMap = i(e.envMap)),
                        void 0 !== e.reflectivity && (a.reflectivity = e.reflectivity),
                        void 0 !== e.lightMap && (a.lightMap = i(e.lightMap)),
                        void 0 !== e.lightMapIntensity && (a.lightMapIntensity = e.lightMapIntensity),
                        void 0 !== e.aoMap && (a.aoMap = i(e.aoMap)),
                        void 0 !== e.aoMapIntensity && (a.aoMapIntensity = e.aoMapIntensity),
                        void 0 !== e.materials)
                            for (var s = 0, l = e.materials.length; s < l; s++)
                                a.materials.push(this.parse(e.materials[s]));
                        return a
                    }
                }),
                Object.assign(vi.prototype, {
                    load: function(t, e, i, n) {
                        var r = this
                          , a = new Ge(r.manager);
                        a.load(t, function(t) {
                            e(r.parse(JSON.parse(t)))
                        }, i, n)
                    },
                    parse: function(t) {
                        var e = new Ht
                          , i = t.data.index
                          , n = {
                            Int8Array: Int8Array,
                            Uint8Array: Uint8Array,
                            Uint8ClampedArray: Uint8ClampedArray,
                            Int16Array: Int16Array,
                            Uint16Array: Uint16Array,
                            Int32Array: Int32Array,
                            Uint32Array: Uint32Array,
                            Float32Array: Float32Array,
                            Float64Array: Float64Array
                        };
                        if (void 0 !== i) {
                            var r = new n[i.type](i.array);
                            e.setIndex(new Tt(r,1))
                        }
                        var a = t.data.attributes;
                        for (var o in a) {
                            var s = a[o]
                              , r = new n[s.type](s.array);
                            e.addAttribute(o, new Tt(r,s.itemSize,s.normalized))
                        }
                        var h = t.data.groups || t.data.drawcalls || t.data.offsets;
                        if (void 0 !== h)
                            for (var c = 0, u = h.length; c !== u; ++c) {
                                var p = h[c];
                                e.addGroup(p.start, p.count, p.materialIndex)
                            }
                        var d = t.data.boundingSphere;
                        if (void 0 !== d) {
                            var f = new l;
                            void 0 !== d.center && f.fromArray(d.center),
                            e.boundingSphere = new nt(f,d.radius)
                        }
                        return e
                    }
                }),
                _i.prototype = {
                    constructor: _i,
                    crossOrigin: void 0,
                    extractUrlBase: function(t) {
                        var e = t.split("/");
                        return 1 === e.length ? "./" : (e.pop(),
                        e.join("/") + "/")
                    },
                    initMaterials: function(t, e, i) {
                        for (var n = [], r = 0; r < t.length; ++r)
                            n[r] = this.createMaterial(t[r], e, i);
                        return n
                    },
                    createMaterial: function() {
                        var i, n, r;
                        return function(a, o, s) {
                            function l(t, i, r, a, l) {
                                var c, u = o + t, p = _i.Handlers.get(u);
                                null !== p ? c = p.load(u) : (n.setCrossOrigin(s),
                                c = n.load(u)),
                                void 0 !== i && (c.repeat.fromArray(i),
                                1 !== i[0] && (c.wrapS = xa),
                                1 !== i[1] && (c.wrapT = xa)),
                                void 0 !== r && c.offset.fromArray(r),
                                void 0 !== a && ("repeat" === a[0] && (c.wrapS = xa),
                                "mirror" === a[0] && (c.wrapS = wa),
                                "repeat" === a[1] && (c.wrapT = xa),
                                "mirror" === a[1] && (c.wrapT = wa)),
                                void 0 !== l && (c.anisotropy = l);
                                var d = e.Math.generateUUID();
                                return h[d] = c,
                                d
                            }
                            void 0 === i && (i = new tt),
                            void 0 === n && (n = new Xe),
                            void 0 === r && (r = new gi);
                            var h = {}
                              , c = {
                                uuid: e.Math.generateUUID(),
                                type: "MeshLambertMaterial"
                            };
                            for (var u in a) {
                                var p = a[u];
                                switch (u) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    c.name = p;
                                    break;
                                case "blending":
                                    c.blending = t[p];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    c.color = i.fromArray(p).getHex();
                                    break;
                                case "colorSpecular":
                                    c.specular = i.fromArray(p).getHex();
                                    break;
                                case "colorEmissive":
                                    c.emissive = i.fromArray(p).getHex();
                                    break;
                                case "specularCoef":
                                    c.shininess = p;
                                    break;
                                case "shading":
                                    "basic" === p.toLowerCase() && (c.type = "MeshBasicMaterial"),
                                    "phong" === p.toLowerCase() && (c.type = "MeshPhongMaterial"),
                                    "standard" === p.toLowerCase() && (c.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    c.map = l(p, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    c.emissiveMap = l(p, a.mapEmissiveRepeat, a.mapEmissiveOffset, a.mapEmissiveWrap, a.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    c.lightMap = l(p, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    c.aoMap = l(p, a.mapAORepeat, a.mapAOOffset, a.mapAOWrap, a.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    c.bumpMap = l(p, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    c.bumpScale = p;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    c.normalMap = l(p, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    c.normalScale = [p, p];
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    c.specularMap = l(p, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    c.metalnessMap = l(p, a.mapMetalnessRepeat, a.mapMetalnessOffset, a.mapMetalnessWrap, a.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    c.roughnessMap = l(p, a.mapRoughnessRepeat, a.mapRoughnessOffset, a.mapRoughnessWrap, a.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    c.alphaMap = l(p, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    c.side = br;
                                    break;
                                case "doubleSided":
                                    c.side = wr;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                                    c.opacity = p;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    c[u] = p;
                                    break;
                                case "vertexColors":
                                    p === !0 && (c.vertexColors = Ar),
                                    "face" === p && (c.vertexColors = Er);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", u, p)
                                }
                            }
                            return "MeshBasicMaterial" === c.type && delete c.emissive,
                            "MeshPhongMaterial" !== c.type && delete c.specular,
                            c.opacity < 1 && (c.transparent = !0),
                            r.setTextures(h),
                            r.parse(c)
                        }
                    }()
                },
                _i.Handlers = {
                    handlers: [],
                    add: function(t, e) {
                        this.handlers.push(t, e)
                    },
                    get: function(t) {
                        for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                            var r = e[i]
                              , a = e[i + 1];
                            if (r.test(t))
                                return a
                        }
                        return null
                    }
                },
                Object.assign(yi.prototype, {
                    load: function(t, e, i, n) {
                        var r = this
                          , a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : _i.prototype.extractUrlBase(t)
                          , o = new Ge(this.manager);
                        o.setWithCredentials(this.withCredentials),
                        o.load(t, function(i) {
                            var n = JSON.parse(i)
                              , o = n.metadata;
                            if (void 0 !== o) {
                                var s = o.type;
                                if (void 0 !== s) {
                                    if ("object" === s.toLowerCase())
                                        return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                                    if ("scene" === s.toLowerCase())
                                        return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                                }
                            }
                            var l = r.parse(n, a);
                            e(l.geometry, l.materials)
                        }, i, n)
                    },
                    setTexturePath: function(t) {
                        this.texturePath = t
                    },
                    parse: function(t, e) {
                        function i(e) {
                            function i(t, e) {
                                return t & 1 << e
                            }
                            var r, a, o, h, c, u, p, d, f, m, g, v, _, y, x, b, w, M, T, S, E, A, P, R, L, C, O, I = t.faces, D = t.vertices, U = t.normals, F = t.colors, N = 0;
                            if (void 0 !== t.uvs) {
                                for (r = 0; r < t.uvs.length; r++)
                                    t.uvs[r].length && N++;
                                for (r = 0; r < N; r++)
                                    s.faceVertexUvs[r] = []
                            }
                            for (h = 0,
                            c = D.length; h < c; )
                                M = new l,
                                M.x = D[h++] * e,
                                M.y = D[h++] * e,
                                M.z = D[h++] * e,
                                s.vertices.push(M);
                            for (h = 0,
                            c = I.length; h < c; )
                                if (m = I[h++],
                                g = i(m, 0),
                                v = i(m, 1),
                                _ = i(m, 3),
                                y = i(m, 4),
                                x = i(m, 5),
                                b = i(m, 6),
                                w = i(m, 7),
                                g) {
                                    if (S = new Ut,
                                    S.a = I[h],
                                    S.b = I[h + 1],
                                    S.c = I[h + 3],
                                    E = new Ut,
                                    E.a = I[h + 1],
                                    E.b = I[h + 2],
                                    E.c = I[h + 3],
                                    h += 4,
                                    v && (f = I[h++],
                                    S.materialIndex = f,
                                    E.materialIndex = f),
                                    o = s.faces.length,
                                    _)
                                        for (r = 0; r < N; r++)
                                            for (R = t.uvs[r],
                                            s.faceVertexUvs[r][o] = [],
                                            s.faceVertexUvs[r][o + 1] = [],
                                            a = 0; a < 4; a++)
                                                d = I[h++],
                                                C = R[2 * d],
                                                O = R[2 * d + 1],
                                                L = new n(C,O),
                                                2 !== a && s.faceVertexUvs[r][o].push(L),
                                                0 !== a && s.faceVertexUvs[r][o + 1].push(L);
                                    if (y && (p = 3 * I[h++],
                                    S.normal.set(U[p++], U[p++], U[p]),
                                    E.normal.copy(S.normal)),
                                    x)
                                        for (r = 0; r < 4; r++)
                                            p = 3 * I[h++],
                                            P = new l(U[p++],U[p++],U[p]),
                                            2 !== r && S.vertexNormals.push(P),
                                            0 !== r && E.vertexNormals.push(P);
                                    if (b && (u = I[h++],
                                    A = F[u],
                                    S.color.setHex(A),
                                    E.color.setHex(A)),
                                    w)
                                        for (r = 0; r < 4; r++)
                                            u = I[h++],
                                            A = F[u],
                                            2 !== r && S.vertexColors.push(new tt(A)),
                                            0 !== r && E.vertexColors.push(new tt(A));
                                    s.faces.push(S),
                                    s.faces.push(E)
                                } else {
                                    if (T = new Ut,
                                    T.a = I[h++],
                                    T.b = I[h++],
                                    T.c = I[h++],
                                    v && (f = I[h++],
                                    T.materialIndex = f),
                                    o = s.faces.length,
                                    _)
                                        for (r = 0; r < N; r++)
                                            for (R = t.uvs[r],
                                            s.faceVertexUvs[r][o] = [],
                                            a = 0; a < 3; a++)
                                                d = I[h++],
                                                C = R[2 * d],
                                                O = R[2 * d + 1],
                                                L = new n(C,O),
                                                s.faceVertexUvs[r][o].push(L);
                                    if (y && (p = 3 * I[h++],
                                    T.normal.set(U[p++], U[p++], U[p])),
                                    x)
                                        for (r = 0; r < 3; r++)
                                            p = 3 * I[h++],
                                            P = new l(U[p++],U[p++],U[p]),
                                            T.vertexNormals.push(P);
                                    if (b && (u = I[h++],
                                    T.color.setHex(F[u])),
                                    w)
                                        for (r = 0; r < 3; r++)
                                            u = I[h++],
                                            T.vertexColors.push(new tt(F[u]));
                                    s.faces.push(T)
                                }
                        }
                        function r() {
                            var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                            if (t.skinWeights)
                                for (var i = 0, n = t.skinWeights.length; i < n; i += e) {
                                    var r = t.skinWeights[i]
                                      , a = e > 1 ? t.skinWeights[i + 1] : 0
                                      , o = e > 2 ? t.skinWeights[i + 2] : 0
                                      , l = e > 3 ? t.skinWeights[i + 3] : 0;
                                    s.skinWeights.push(new q(r,a,o,l))
                                }
                            if (t.skinIndices)
                                for (var i = 0, n = t.skinIndices.length; i < n; i += e) {
                                    var h = t.skinIndices[i]
                                      , c = e > 1 ? t.skinIndices[i + 1] : 0
                                      , u = e > 2 ? t.skinIndices[i + 2] : 0
                                      , p = e > 3 ? t.skinIndices[i + 3] : 0;
                                    s.skinIndices.push(new q(h,c,u,p))
                                }
                            s.bones = t.bones,
                            s.bones && s.bones.length > 0 && (s.skinWeights.length !== s.skinIndices.length || s.skinIndices.length !== s.vertices.length) && console.warn("When skinning, number of vertices (" + s.vertices.length + "), skinIndices (" + s.skinIndices.length + "), and skinWeights (" + s.skinWeights.length + ") should match.")
                        }
                        function a(e) {
                            if (void 0 !== t.morphTargets)
                                for (var i = 0, n = t.morphTargets.length; i < n; i++) {
                                    s.morphTargets[i] = {},
                                    s.morphTargets[i].name = t.morphTargets[i].name,
                                    s.morphTargets[i].vertices = [];
                                    for (var r = s.morphTargets[i].vertices, a = t.morphTargets[i].vertices, o = 0, h = a.length; o < h; o += 3) {
                                        var c = new l;
                                        c.x = a[o] * e,
                                        c.y = a[o + 1] * e,
                                        c.z = a[o + 2] * e,
                                        r.push(c)
                                    }
                                }
                            if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                                console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                                for (var u = s.faces, p = t.morphColors[0].colors, i = 0, n = u.length; i < n; i++)
                                    u[i].color.fromArray(p, 3 * i)
                            }
                        }
                        function o() {
                            var e = []
                              , i = [];
                            void 0 !== t.animation && i.push(t.animation),
                            void 0 !== t.animations && (t.animations.length ? i = i.concat(t.animations) : i.push(t.animations));
                            for (var n = 0; n < i.length; n++) {
                                var r = mi.parseAnimation(i[n], s.bones);
                                r && e.push(r)
                            }
                            if (s.morphTargets) {
                                var a = mi.CreateClipsFromMorphTargetSequences(s.morphTargets, 10);
                                e = e.concat(a)
                            }
                            e.length > 0 && (s.animations = e)
                        }
                        var s = new kt
                          , h = void 0 !== t.scale ? 1 / t.scale : 1;
                        if (i(h),
                        r(),
                        a(h),
                        o(),
                        s.computeFaceNormals(),
                        s.computeBoundingSphere(),
                        void 0 === t.materials || 0 === t.materials.length)
                            return {
                                geometry: s
                            };
                        var c = _i.prototype.initMaterials(t.materials, e, this.crossOrigin);
                        return {
                            geometry: s,
                            materials: c
                        }
                    }
                }),
                Object.assign(xi.prototype, {
                    load: function(t, e, i, n) {
                        "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                        var r = this
                          , a = new Ge(r.manager);
                        a.load(t, function(t) {
                            r.parse(JSON.parse(t), e)
                        }, i, n)
                    },
                    setTexturePath: function(t) {
                        this.texturePath = t
                    },
                    setCrossOrigin: function(t) {
                        this.crossOrigin = t
                    },
                    parse: function(t, e) {
                        var i = this.parseGeometries(t.geometries)
                          , n = this.parseImages(t.images, function() {
                            void 0 !== e && e(o)
                        })
                          , r = this.parseTextures(t.textures, n)
                          , a = this.parseMaterials(t.materials, r)
                          , o = this.parseObject(t.object, i, a);
                        return t.animations && (o.animations = this.parseAnimations(t.animations)),
                        void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o),
                        o
                    },
                    parseGeometries: function(e) {
                        var i = {};
                        if (void 0 !== e)
                            for (var n = new yi, r = new vi, a = 0, o = e.length; a < o; a++) {
                                var s, l = e[a];
                                switch (l.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new t[l.type](l.width,l.height,l.widthSegments,l.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new t[l.type](l.width,l.height,l.depth,l.widthSegments,l.heightSegments,l.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new t[l.type](l.radius,l.segments,l.thetaStart,l.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new t[l.type](l.radiusTop,l.radiusBottom,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new t[l.type](l.radius,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new t[l.type](l.radius,l.widthSegments,l.heightSegments,l.phiStart,l.phiLength,l.thetaStart,l.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "IcosahedronGeometry":
                                case "OctahedronGeometry":
                                case "TetrahedronGeometry":
                                    s = new t[l.type](l.radius,l.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new t[l.type](l.innerRadius,l.outerRadius,l.thetaSegments,l.phiSegments,l.thetaStart,l.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new t[l.type](l.radius,l.tube,l.radialSegments,l.tubularSegments,l.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new t[l.type](l.radius,l.tube,l.tubularSegments,l.radialSegments,l.p,l.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new t[l.type](l.points,l.segments,l.phiStart,l.phiLength);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(l);
                                    break;
                                case "Geometry":
                                    s = n.parse(l.data, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"');
                                    continue
                                }
                                s.uuid = l.uuid,
                                void 0 !== l.name && (s.name = l.name),
                                i[l.uuid] = s
                            }
                        return i
                    },
                    parseMaterials: function(t, e) {
                        var i = {};
                        if (void 0 !== t) {
                            var n = new gi;
                            n.setTextures(e);
                            for (var r = 0, a = t.length; r < a; r++) {
                                var o = n.parse(t[r]);
                                i[o.uuid] = o
                            }
                        }
                        return i
                    },
                    parseAnimations: function(t) {
                        for (var e = [], i = 0; i < t.length; i++) {
                            var n = mi.parse(t[i]);
                            e.push(n)
                        }
                        return e
                    },
                    parseImages: function(t, e) {
                        function i(t) {
                            return n.manager.itemStart(t),
                            o.load(t, function() {
                                n.manager.itemEnd(t)
                            }, void 0, function() {
                                n.manager.itemError(t)
                            })
                        }
                        var n = this
                          , r = {};
                        if (void 0 !== t && t.length > 0) {
                            var a = new ke(e)
                              , o = new je(a);
                            o.setCrossOrigin(this.crossOrigin);
                            for (var s = 0, l = t.length; s < l; s++) {
                                var h = t[s]
                                  , c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : n.texturePath + h.url;
                                r[h.uuid] = i(c)
                            }
                        }
                        return r
                    },
                    parseTextures: function(e, i) {
                        function n(e) {
                            return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                            t[e])
                        }
                        var a = {};
                        if (void 0 !== e)
                            for (var o = 0, s = e.length; o < s; o++) {
                                var l = e[o];
                                void 0 === l.image && console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid),
                                void 0 === i[l.image] && console.warn("THREE.ObjectLoader: Undefined image", l.image);
                                var h = new r(i[l.image]);
                                h.needsUpdate = !0,
                                h.uuid = l.uuid,
                                void 0 !== l.name && (h.name = l.name),
                                void 0 !== l.mapping && (h.mapping = n(l.mapping)),
                                void 0 !== l.offset && h.offset.fromArray(l.offset),
                                void 0 !== l.repeat && h.repeat.fromArray(l.repeat),
                                void 0 !== l.wrap && (h.wrapS = n(l.wrap[0]),
                                h.wrapT = n(l.wrap[1])),
                                void 0 !== l.minFilter && (h.minFilter = n(l.minFilter)),
                                void 0 !== l.magFilter && (h.magFilter = n(l.magFilter)),
                                void 0 !== l.anisotropy && (h.anisotropy = l.anisotropy),
                                void 0 !== l.flipY && (h.flipY = l.flipY),
                                a[l.uuid] = h
                            }
                        return a
                    },
                    parseObject: function() {
                        var e = new o;
                        return function(i, n, r) {
                            function a(t) {
                                return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t),
                                n[t]
                            }
                            function o(t) {
                                if (void 0 !== t)
                                    return void 0 === r[t] && console.warn("THREE.ObjectLoader: Undefined material", t),
                                    r[t]
                            }
                            var s;
                            switch (i.type) {
                            case "Scene":
                                s = new pe,
                                void 0 !== i.background && Number.isInteger(i.background) && (s.background = new t.Color(i.background)),
                                void 0 !== i.fog && ("Fog" === i.fog.type ? s.fog = new ue(i.fog.color,i.fog.near,i.fog.far) : "FogExp2" === i.fog.type && (s.fog = new ce(i.fog.color,i.fog.density)));
                                break;
                            case "PerspectiveCamera":
                                s = new se(i.fov,i.aspect,i.near,i.far),
                                void 0 !== i.focus && (s.focus = i.focus),
                                void 0 !== i.zoom && (s.zoom = i.zoom),
                                void 0 !== i.filmGauge && (s.filmGauge = i.filmGauge),
                                void 0 !== i.filmOffset && (s.filmOffset = i.filmOffset),
                                void 0 !== i.view && (s.view = Object.assign({}, i.view));
                                break;
                            case "OrthographicCamera":
                                s = new le(i.left,i.right,i.top,i.bottom,i.near,i.far);
                                break;
                            case "AmbientLight":
                                s = new ei(i.color,i.intensity);
                                break;
                            case "DirectionalLight":
                                s = new ti(i.color,i.intensity);
                                break;
                            case "PointLight":
                                s = new Ke(i.color,i.intensity,i.distance,i.decay);
                                break;
                            case "SpotLight":
                                s = new Je(i.color,i.intensity,i.distance,i.angle,i.penumbra,i.decay);
                                break;
                            case "HemisphereLight":
                                s = new qe(i.color,i.groundColor,i.intensity);
                                break;
                            case "Mesh":
                                var l = a(i.geometry)
                                  , h = o(i.material);
                                s = l.bones && l.bones.length > 0 ? new xe(l,h) : new re(l,h);
                                break;
                            case "LOD":
                                s = new ge;
                                break;
                            case "Line":
                                s = new we(a(i.geometry),o(i.material),i.mode);
                                break;
                            case "LineSegments":
                                s = new Me(a(i.geometry),o(i.material));
                                break;
                            case "PointCloud":
                            case "Points":
                                s = new Se(a(i.geometry),o(i.material));
                                break;
                            case "Sprite":
                                s = new me(o(i.material));
                                break;
                            case "Group":
                                s = new Ee;
                                break;
                            default:
                                s = new zt
                            }
                            if (s.uuid = i.uuid,
                            void 0 !== i.name && (s.name = i.name),
                            void 0 !== i.matrix ? (e.fromArray(i.matrix),
                            e.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== i.position && s.position.fromArray(i.position),
                            void 0 !== i.rotation && s.rotation.fromArray(i.rotation),
                            void 0 !== i.quaternion && s.quaternion.fromArray(i.quaternion),
                            void 0 !== i.scale && s.scale.fromArray(i.scale)),
                            void 0 !== i.castShadow && (s.castShadow = i.castShadow),
                            void 0 !== i.receiveShadow && (s.receiveShadow = i.receiveShadow),
                            i.shadow && (void 0 !== i.shadow.bias && (s.shadow.bias = i.shadow.bias),
                            void 0 !== i.shadow.radius && (s.shadow.radius = i.shadow.radius),
                            void 0 !== i.shadow.mapSize && s.shadow.mapSize.fromArray(i.shadow.mapSize),
                            void 0 !== i.shadow.camera && (s.shadow.camera = this.parseObject(i.shadow.camera))),
                            void 0 !== i.visible && (s.visible = i.visible),
                            void 0 !== i.userData && (s.userData = i.userData),
                            void 0 !== i.children)
                                for (var c in i.children)
                                    s.add(this.parseObject(i.children[c], n, r));
                            if ("LOD" === i.type)
                                for (var u = i.levels, p = 0; p < u.length; p++) {
                                    var d = u[p]
                                      , c = s.getObjectByProperty("uuid", d.object);
                                    void 0 !== c && s.addLevel(c, d.distance)
                                }
                            return s
                        }
                    }()
                }),
                e.ShapeUtils = {
                    area: function(t) {
                        for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++)
                            i += t[n].x * t[r].y - t[r].x * t[n].y;
                        return .5 * i
                    },
                    triangulate: function() {
                        function t(t, e, i, n, r, a) {
                            var o, s, l, h, c, u, p, d, f;
                            if (s = t[a[e]].x,
                            l = t[a[e]].y,
                            h = t[a[i]].x,
                            c = t[a[i]].y,
                            u = t[a[n]].x,
                            p = t[a[n]].y,
                            Number.EPSILON > (h - s) * (p - l) - (c - l) * (u - s))
                                return !1;
                            var m, g, v, _, y, x, b, w, M, T, S, E, A, P, R;
                            for (m = u - h,
                            g = p - c,
                            v = s - u,
                            _ = l - p,
                            y = h - s,
                            x = c - l,
                            o = 0; o < r; o++)
                                if (d = t[a[o]].x,
                                f = t[a[o]].y,
                                !(d === s && f === l || d === h && f === c || d === u && f === p) && (b = d - s,
                                w = f - l,
                                M = d - h,
                                T = f - c,
                                S = d - u,
                                E = f - p,
                                R = m * T - g * M,
                                A = y * w - x * b,
                                P = v * E - _ * S,
                                R >= -Number.EPSILON && P >= -Number.EPSILON && A >= -Number.EPSILON))
                                    return !1;
                            return !0
                        }
                        return function(i, n) {
                            var r = i.length;
                            if (r < 3)
                                return null;
                            var a, o, s, l = [], h = [], c = [];
                            if (e.ShapeUtils.area(i) > 0)
                                for (o = 0; o < r; o++)
                                    h[o] = o;
                            else
                                for (o = 0; o < r; o++)
                                    h[o] = r - 1 - o;
                            var u = r
                              , p = 2 * u;
                            for (o = u - 1; u > 2; ) {
                                if (p-- <= 0)
                                    return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                                    n ? c : l;
                                if (a = o,
                                u <= a && (a = 0),
                                o = a + 1,
                                u <= o && (o = 0),
                                s = o + 1,
                                u <= s && (s = 0),
                                t(i, a, o, s, u, h)) {
                                    var d, f, m, g, v;
                                    for (d = h[a],
                                    f = h[o],
                                    m = h[s],
                                    l.push([i[d], i[f], i[m]]),
                                    c.push([h[a], h[o], h[s]]),
                                    g = o,
                                    v = o + 1; v < u; g++,
                                    v++)
                                        h[g] = h[v];
                                    u--,
                                    p = 2 * u
                                }
                            }
                            return n ? c : l
                        }
                    }(),
                    triangulateShape: function(t, i) {
                        function n(t) {
                            var e = t.length;
                            e > 2 && t[e - 1].equals(t[0]) && t.pop()
                        }
                        function r(t, e, i) {
                            return t.x !== e.x ? t.x < e.x ? t.x <= i.x && i.x <= e.x : e.x <= i.x && i.x <= t.x : t.y < e.y ? t.y <= i.y && i.y <= e.y : e.y <= i.y && i.y <= t.y
                        }
                        function a(t, e, i, n, a) {
                            var o = e.x - t.x
                              , s = e.y - t.y
                              , l = n.x - i.x
                              , h = n.y - i.y
                              , c = t.x - i.x
                              , u = t.y - i.y
                              , p = s * l - o * h
                              , d = s * c - o * u;
                            if (Math.abs(p) > Number.EPSILON) {
                                var f;
                                if (p > 0) {
                                    if (d < 0 || d > p)
                                        return [];
                                    if (f = h * c - l * u,
                                    f < 0 || f > p)
                                        return []
                                } else {
                                    if (d > 0 || d < p)
                                        return [];
                                    if (f = h * c - l * u,
                                    f > 0 || f < p)
                                        return []
                                }
                                if (0 === f)
                                    return !a || 0 !== d && d !== p ? [t] : [];
                                if (f === p)
                                    return !a || 0 !== d && d !== p ? [e] : [];
                                if (0 === d)
                                    return [i];
                                if (d === p)
                                    return [n];
                                var m = f / p;
                                return [{
                                    x: t.x + m * o,
                                    y: t.y + m * s
                                }]
                            }
                            if (0 !== d || h * c !== l * u)
                                return [];
                            var g = 0 === o && 0 === s
                              , v = 0 === l && 0 === h;
                            if (g && v)
                                return t.x !== i.x || t.y !== i.y ? [] : [t];
                            if (g)
                                return r(i, n, t) ? [t] : [];
                            if (v)
                                return r(t, e, i) ? [i] : [];
                            var _, y, x, b, w, M, T, S;
                            return 0 !== o ? (t.x < e.x ? (_ = t,
                            x = t.x,
                            y = e,
                            b = e.x) : (_ = e,
                            x = e.x,
                            y = t,
                            b = t.x),
                            i.x < n.x ? (w = i,
                            T = i.x,
                            M = n,
                            S = n.x) : (w = n,
                            T = n.x,
                            M = i,
                            S = i.x)) : (t.y < e.y ? (_ = t,
                            x = t.y,
                            y = e,
                            b = e.y) : (_ = e,
                            x = e.y,
                            y = t,
                            b = t.y),
                            i.y < n.y ? (w = i,
                            T = i.y,
                            M = n,
                            S = n.y) : (w = n,
                            T = n.y,
                            M = i,
                            S = i.y)),
                            x <= T ? b < T ? [] : b === T ? a ? [] : [w] : b <= S ? [w, y] : [w, M] : x > S ? [] : x === S ? a ? [] : [_] : b <= S ? [_, y] : [_, M]
                        }
                        function o(t, e, i, n) {
                            var r = e.x - t.x
                              , a = e.y - t.y
                              , o = i.x - t.x
                              , s = i.y - t.y
                              , l = n.x - t.x
                              , h = n.y - t.y
                              , c = r * s - a * o
                              , u = r * h - a * l;
                            if (Math.abs(c) > Number.EPSILON) {
                                var p = l * s - h * o;
                                return c > 0 ? u >= 0 && p >= 0 : u >= 0 || p >= 0
                            }
                            return u > 0
                        }
                        function s(t, e) {
                            function i(t, e) {
                                var i = _.length - 1
                                  , n = t - 1;
                                n < 0 && (n = i);
                                var r = t + 1;
                                r > i && (r = 0);
                                var a = o(_[t], _[n], _[r], s[e]);
                                if (!a)
                                    return !1;
                                var l = s.length - 1
                                  , h = e - 1;
                                h < 0 && (h = l);
                                var c = e + 1;
                                return c > l && (c = 0),
                                a = o(s[e], s[h], s[c], _[t]),
                                !!a
                            }
                            function n(t, e) {
                                var i, n, r;
                                for (i = 0; i < _.length; i++)
                                    if (n = i + 1,
                                    n %= _.length,
                                    r = a(t, e, _[i], _[n], !0),
                                    r.length > 0)
                                        return !0;
                                return !1
                            }
                            function r(t, i) {
                                var n, r, o, s, l;
                                for (n = 0; n < y.length; n++)
                                    for (r = e[y[n]],
                                    o = 0; o < r.length; o++)
                                        if (s = o + 1,
                                        s %= r.length,
                                        l = a(t, i, r[o], r[s], !0),
                                        l.length > 0)
                                            return !0;
                                return !1
                            }
                            for (var s, l, h, c, u, p, d, f, m, g, v, _ = t.concat(), y = [], x = [], b = 0, w = e.length; b < w; b++)
                                y.push(b);
                            for (var M = 0, T = 2 * y.length; y.length > 0; ) {
                                if (T--,
                                T < 0) {
                                    console.log("Infinite Loop! Holes left:" + y.length + ", Probably Hole outside Shape!");
                                    break
                                }
                                for (h = M; h < _.length; h++) {
                                    c = _[h],
                                    l = -1;
                                    for (var b = 0; b < y.length; b++)
                                        if (p = y[b],
                                        d = c.x + ":" + c.y + ":" + p,
                                        void 0 === x[d]) {
                                            s = e[p];
                                            for (var S = 0; S < s.length; S++)
                                                if (u = s[S],
                                                i(h, S) && !n(c, u) && !r(c, u)) {
                                                    l = S,
                                                    y.splice(b, 1),
                                                    f = _.slice(0, h + 1),
                                                    m = _.slice(h),
                                                    g = s.slice(l),
                                                    v = s.slice(0, l + 1),
                                                    _ = f.concat(g).concat(v).concat(m),
                                                    M = h;
                                                    break
                                                }
                                            if (l >= 0)
                                                break;
                                            x[d] = !0
                                        }
                                    if (l >= 0)
                                        break
                                }
                            }
                            return _
                        }
                        n(t),
                        i.forEach(n);
                        for (var l, h, c, u, p, d, f = {}, m = t.concat(), g = 0, v = i.length; g < v; g++)
                            Array.prototype.push.apply(m, i[g]);
                        for (l = 0,
                        h = m.length; l < h; l++)
                            p = m[l].x + ":" + m[l].y,
                            void 0 !== f[p] && console.warn("THREE.ShapeUtils: Duplicate point", p, l),
                            f[p] = l;
                        var _ = s(t, i)
                          , y = e.ShapeUtils.triangulate(_, !1);
                        for (l = 0,
                        h = y.length; l < h; l++)
                            for (u = y[l],
                            c = 0; c < 3; c++)
                                p = u[c].x + ":" + u[c].y,
                                d = f[p],
                                void 0 !== d && (u[c] = d);
                        return y.concat()
                    },
                    isClockWise: function(t) {
                        return e.ShapeUtils.area(t) < 0
                    },
                    b2: function() {
                        function t(t, e) {
                            var i = 1 - t;
                            return i * i * e
                        }
                        function e(t, e) {
                            return 2 * (1 - t) * t * e
                        }
                        function i(t, e) {
                            return t * t * e
                        }
                        return function(n, r, a, o) {
                            return t(n, r) + e(n, a) + i(n, o)
                        }
                    }(),
                    b3: function() {
                        function t(t, e) {
                            var i = 1 - t;
                            return i * i * i * e
                        }
                        function e(t, e) {
                            var i = 1 - t;
                            return 3 * i * i * t * e
                        }
                        function i(t, e) {
                            var i = 1 - t;
                            return 3 * i * t * t * e
                        }
                        function n(t, e) {
                            return t * t * t * e
                        }
                        return function(r, a, o, s, l) {
                            return t(r, a) + e(r, o) + i(r, s) + n(r, l)
                        }
                    }()
                },
                bi.prototype = {
                    constructor: bi,
                    getPoint: function(t) {
                        return console.warn("THREE.Curve: Warning, getPoint() not implemented!"),
                        null
                    },
                    getPointAt: function(t) {
                        var e = this.getUtoTmapping(t);
                        return this.getPoint(e)
                    },
                    getPoints: function(t) {
                        t || (t = 5);
                        for (var e = [], i = 0; i <= t; i++)
                            e.push(this.getPoint(i / t));
                        return e
                    },
                    getSpacedPoints: function(t) {
                        t || (t = 5);
                        for (var e = [], i = 0; i <= t; i++)
                            e.push(this.getPointAt(i / t));
                        return e
                    },
                    getLength: function() {
                        var t = this.getLengths();
                        return t[t.length - 1]
                    },
                    getLengths: function(t) {
                        if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200),
                        this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                            return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        var e, i, n = [], r = this.getPoint(0), a = 0;
                        for (n.push(0),
                        i = 1; i <= t; i++)
                            e = this.getPoint(i / t),
                            a += e.distanceTo(r),
                            n.push(a),
                            r = e;
                        return this.cacheArcLengths = n,
                        n
                    },
                    updateArcLengths: function() {
                        this.needsUpdate = !0,
                        this.getLengths()
                    },
                    getUtoTmapping: function(t, e) {
                        var i, n = this.getLengths(), r = 0, a = n.length;
                        i = e ? e : t * n[a - 1];
                        for (var o, s = 0, l = a - 1; s <= l; )
                            if (r = Math.floor(s + (l - s) / 2),
                            o = n[r] - i,
                            o < 0)
                                s = r + 1;
                            else {
                                if (!(o > 0)) {
                                    l = r;
                                    break
                                }
                                l = r - 1
                            }
                        if (r = l,
                        n[r] === i) {
                            var h = r / (a - 1);
                            return h
                        }
                        var c = n[r]
                          , u = n[r + 1]
                          , p = u - c
                          , d = (i - c) / p
                          , h = (r + d) / (a - 1);
                        return h
                    },
                    getTangent: function(t) {
                        var e = 1e-4
                          , i = t - e
                          , n = t + e;
                        i < 0 && (i = 0),
                        n > 1 && (n = 1);
                        var r = this.getPoint(i)
                          , a = this.getPoint(n)
                          , o = a.clone().sub(r);
                        return o.normalize()
                    },
                    getTangentAt: function(t) {
                        var e = this.getUtoTmapping(t);
                        return this.getTangent(e)
                    }
                },
                bi.create = function(t, e) {
                    return t.prototype = Object.create(bi.prototype),
                    t.prototype.constructor = t,
                    t.prototype.getPoint = e,
                    t
                }
                ,
                wi.prototype = Object.create(bi.prototype),
                wi.prototype.constructor = wi,
                wi.prototype.isLineCurve = !0,
                wi.prototype.getPoint = function(t) {
                    if (1 === t)
                        return this.v2.clone();
                    var e = this.v2.clone().sub(this.v1);
                    return e.multiplyScalar(t).add(this.v1),
                    e
                }
                ,
                wi.prototype.getPointAt = function(t) {
                    return this.getPoint(t)
                }
                ,
                wi.prototype.getTangent = function(t) {
                    var e = this.v2.clone().sub(this.v1);
                    return e.normalize()
                }
                ,
                Mi.prototype = Object.assign(Object.create(bi.prototype), {
                    constructor: Mi,
                    add: function(t) {
                        this.curves.push(t)
                    },
                    closePath: function() {
                        var t = this.curves[0].getPoint(0)
                          , e = this.curves[this.curves.length - 1].getPoint(1);
                        t.equals(e) || this.curves.push(new wi(e,t))
                    },
                    getPoint: function(t) {
                        for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length; ) {
                            if (i[n] >= e) {
                                var r = i[n] - e
                                  , a = this.curves[n]
                                  , o = a.getLength()
                                  , s = 0 === o ? 0 : 1 - r / o;
                                return a.getPointAt(s)
                            }
                            n++
                        }
                        return null
                    },
                    getLength: function() {
                        var t = this.getCurveLengths();
                        return t[t.length - 1]
                    },
                    updateArcLengths: function() {
                        this.needsUpdate = !0,
                        this.cacheLengths = null,
                        this.getLengths()
                    },
                    getCurveLengths: function() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                            return this.cacheLengths;
                        for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
                            e += this.curves[i].getLength(),
                            t.push(e);
                        return this.cacheLengths = t,
                        t
                    },
                    getSpacedPoints: function(t) {
                        t || (t = 40);
                        for (var e = [], i = 0; i <= t; i++)
                            e.push(this.getPoint(i / t));
                        return this.autoClose && e.push(e[0]),
                        e
                    },
                    getPoints: function(t) {
                        t = t || 12;
                        for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                            for (var a = r[n], o = a && a.isEllipseCurve ? 2 * t : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), l = 0; l < s.length; l++) {
                                var h = s[l];
                                e && e.equals(h) || (i.push(h),
                                e = h)
                            }
                        return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]),
                        i
                    },
                    createPointsGeometry: function(t) {
                        var e = this.getPoints(t);
                        return this.createGeometry(e)
                    },
                    createSpacedPointsGeometry: function(t) {
                        var e = this.getSpacedPoints(t);
                        return this.createGeometry(e)
                    },
                    createGeometry: function(t) {
                        for (var e = new kt, i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            e.vertices.push(new l(r.x,r.y,r.z || 0))
                        }
                        return e
                    }
                }),
                Ti.prototype = Object.create(bi.prototype),
                Ti.prototype.constructor = Ti,
                Ti.prototype.isEllipseCurve = !0,
                Ti.prototype.getPoint = function(t) {
                    for (var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, r = Math.abs(i) < Number.EPSILON; i < 0; )
                        i += e;
                    for (; i > e; )
                        i -= e;
                    i < Number.EPSILON && (i = r ? 0 : e),
                    this.aClockwise !== !0 || r || (i === e ? i = -e : i -= e);
                    var a = this.aStartAngle + t * i
                      , o = this.aX + this.xRadius * Math.cos(a)
                      , s = this.aY + this.yRadius * Math.sin(a);
                    if (0 !== this.aRotation) {
                        var l = Math.cos(this.aRotation)
                          , h = Math.sin(this.aRotation)
                          , c = o - this.aX
                          , u = s - this.aY;
                        o = c * l - u * h + this.aX,
                        s = c * h + u * l + this.aY
                    }
                    return new n(o,s)
                }
                ,
                e.CurveUtils = {
                    tangentQuadraticBezier: function(t, e, i, n) {
                        return 2 * (1 - t) * (i - e) + 2 * t * (n - i)
                    },
                    tangentCubicBezier: function(t, e, i, n, r) {
                        return -3 * e * (1 - t) * (1 - t) + 3 * i * (1 - t) * (1 - t) - 6 * t * i * (1 - t) + 6 * t * n * (1 - t) - 3 * t * t * n + 3 * t * t * r
                    },
                    tangentSpline: function(t, e, i, n, r) {
                        var a = 6 * t * t - 6 * t
                          , o = 3 * t * t - 4 * t + 1
                          , s = -6 * t * t + 6 * t
                          , l = 3 * t * t - 2 * t;
                        return a + o + s + l
                    },
                    interpolate: function(t, e, i, n, r) {
                        var a = .5 * (i - t)
                          , o = .5 * (n - e)
                          , s = r * r
                          , l = r * s;
                        return (2 * e - 2 * i + a + o) * l + (-3 * e + 3 * i - 2 * a - o) * s + a * r + e
                    }
                },
                Si.prototype = Object.create(bi.prototype),
                Si.prototype.constructor = Si,
                Si.prototype.isSplineCurve = !0,
                Si.prototype.getPoint = function(t) {
                    var i = this.points
                      , r = (i.length - 1) * t
                      , a = Math.floor(r)
                      , o = r - a
                      , s = i[0 === a ? a : a - 1]
                      , l = i[a]
                      , h = i[a > i.length - 2 ? i.length - 1 : a + 1]
                      , c = i[a > i.length - 3 ? i.length - 1 : a + 2]
                      , u = e.CurveUtils.interpolate;
                    return new n(u(s.x, l.x, h.x, c.x, o),u(s.y, l.y, h.y, c.y, o))
                }
                ,
                Ei.prototype = Object.create(bi.prototype),
                Ei.prototype.constructor = Ei,
                Ei.prototype.getPoint = function(t) {
                    var i = e.ShapeUtils.b3;
                    return new n(i(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),i(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
                }
                ,
                Ei.prototype.getTangent = function(t) {
                    var i = e.CurveUtils.tangentCubicBezier;
                    return new n(i(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),i(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
                }
                ,
                Ai.prototype = Object.create(bi.prototype),
                Ai.prototype.constructor = Ai,
                Ai.prototype.getPoint = function(t) {
                    var i = e.ShapeUtils.b2;
                    return new n(i(t, this.v0.x, this.v1.x, this.v2.x),i(t, this.v0.y, this.v1.y, this.v2.y))
                }
                ,
                Ai.prototype.getTangent = function(t) {
                    var i = e.CurveUtils.tangentQuadraticBezier;
                    return new n(i(t, this.v0.x, this.v1.x, this.v2.x),i(t, this.v0.y, this.v1.y, this.v2.y)).normalize()
                }
                ;
                var Bl = Object.assign(Object.create(Mi.prototype), {
                    fromPoints: function(t) {
                        this.moveTo(t[0].x, t[0].y);
                        for (var e = 1, i = t.length; e < i; e++)
                            this.lineTo(t[e].x, t[e].y)
                    },
                    moveTo: function(t, e) {
                        this.currentPoint.set(t, e)
                    },
                    lineTo: function(t, e) {
                        var i = new wi(this.currentPoint.clone(),new n(t,e));
                        this.curves.push(i),
                        this.currentPoint.set(t, e)
                    },
                    quadraticCurveTo: function(t, e, i, r) {
                        var a = new Ai(this.currentPoint.clone(),new n(t,e),new n(i,r));
                        this.curves.push(a),
                        this.currentPoint.set(i, r)
                    },
                    bezierCurveTo: function(t, e, i, r, a, o) {
                        var s = new Ei(this.currentPoint.clone(),new n(t,e),new n(i,r),new n(a,o));
                        this.curves.push(s),
                        this.currentPoint.set(a, o)
                    },
                    splineThru: function(t) {
                        var e = [this.currentPoint.clone()].concat(t)
                          , i = new Si(e);
                        this.curves.push(i),
                        this.currentPoint.copy(t[t.length - 1])
                    },
                    arc: function(t, e, i, n, r, a) {
                        var o = this.currentPoint.x
                          , s = this.currentPoint.y;
                        this.absarc(t + o, e + s, i, n, r, a)
                    },
                    absarc: function(t, e, i, n, r, a) {
                        this.absellipse(t, e, i, i, n, r, a)
                    },
                    ellipse: function(t, e, i, n, r, a, o, s) {
                        var l = this.currentPoint.x
                          , h = this.currentPoint.y;
                        this.absellipse(t + l, e + h, i, n, r, a, o, s)
                    },
                    absellipse: function(t, e, i, n, r, a, o, s) {
                        var l = new Ti(t,e,i,n,r,a,o,s);
                        if (this.curves.length > 0) {
                            var h = l.getPoint(0);
                            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
                        }
                        this.curves.push(l);
                        var c = l.getPoint(1);
                        this.currentPoint.copy(c)
                    }
                });
                Pi.prototype = Object.create(kt.prototype),
                Pi.prototype.constructor = Pi,
                Pi.NoTaper = function(t) {
                    return 1
                }
                ,
                Pi.SinusoidalTaper = function(t) {
                    return Math.sin(Math.PI * t)
                }
                ,
                Pi.FrenetFrames = function(t, i, n) {
                    function r() {
                        g[0] = new l,
                        v[0] = new l,
                        s = Number.MAX_VALUE,
                        h = Math.abs(m[0].x),
                        c = Math.abs(m[0].y),
                        u = Math.abs(m[0].z),
                        h <= s && (s = h,
                        f.set(1, 0, 0)),
                        c <= s && (s = c,
                        f.set(0, 1, 0)),
                        u <= s && f.set(0, 0, 1),
                        _.crossVectors(m[0], f).normalize(),
                        g[0].crossVectors(m[0], _),
                        v[0].crossVectors(m[0], g[0])
                    }
                    var a, s, h, c, u, p, d, f = new l, m = [], g = [], v = [], _ = new l, y = new o, x = i + 1;
                    for (this.tangents = m,
                    this.normals = g,
                    this.binormals = v,
                    p = 0; p < x; p++)
                        d = p / (x - 1),
                        m[p] = t.getTangentAt(d),
                        m[p].normalize();
                    for (r(),
                    p = 1; p < x; p++)
                        g[p] = g[p - 1].clone(),
                        v[p] = v[p - 1].clone(),
                        _.crossVectors(m[p - 1], m[p]),
                        _.length() > Number.EPSILON && (_.normalize(),
                        a = Math.acos(e.Math.clamp(m[p - 1].dot(m[p]), -1, 1)),
                        g[p].applyMatrix4(y.makeRotationAxis(_, a))),
                        v[p].crossVectors(m[p], g[p]);
                    if (n)
                        for (a = Math.acos(e.Math.clamp(g[0].dot(g[x - 1]), -1, 1)),
                        a /= x - 1,
                        m[0].dot(_.crossVectors(g[0], g[x - 1])) > 0 && (a = -a),
                        p = 1; p < x; p++)
                            g[p].applyMatrix4(y.makeRotationAxis(m[p], a * p)),
                            v[p].crossVectors(m[p], g[p])
                }
                ,
                Ri.prototype = Object.create(kt.prototype),
                Ri.prototype.constructor = Ri,
                Ri.prototype.addShapeList = function(t, e) {
                    for (var i = t.length, n = 0; n < i; n++) {
                        var r = t[n];
                        this.addShape(r, e)
                    }
                }
                ,
                Ri.prototype.addShape = function(t, i) {
                    function r(t, e, i) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        e.clone().multiplyScalar(i).add(t)
                    }
                    function a(t, e, i) {
                        var r, a, o = 1, s = t.x - e.x, l = t.y - e.y, h = i.x - t.x, c = i.y - t.y, u = s * s + l * l, p = s * c - l * h;
                        if (Math.abs(p) > Number.EPSILON) {
                            var d = Math.sqrt(u)
                              , f = Math.sqrt(h * h + c * c)
                              , m = e.x - l / d
                              , g = e.y + s / d
                              , v = i.x - c / f
                              , _ = i.y + h / f
                              , y = ((v - m) * c - (_ - g) * h) / (s * c - l * h);
                            r = m + s * y - t.x,
                            a = g + l * y - t.y;
                            var x = r * r + a * a;
                            if (x <= 2)
                                return new n(r,a);
                            o = Math.sqrt(x / 2)
                        } else {
                            var b = !1;
                            s > Number.EPSILON ? h > Number.EPSILON && (b = !0) : s < -Number.EPSILON ? h < -Number.EPSILON && (b = !0) : Math.sign(l) === Math.sign(c) && (b = !0),
                            b ? (r = -l,
                            a = s,
                            o = Math.sqrt(u)) : (r = s,
                            a = l,
                            o = Math.sqrt(u / 2))
                        }
                        return new n(r / o,a / o)
                    }
                    function o() {
                        if (w) {
                            var t = 0
                              , e = W * t;
                            for (q = 0; q < X; q++)
                                j = N[q],
                                u(j[2] + e, j[1] + e, j[0] + e);
                            for (t = T + 2 * b,
                            e = W * t,
                            q = 0; q < X; q++)
                                j = N[q],
                                u(j[0] + e, j[1] + e, j[2] + e)
                        } else {
                            for (q = 0; q < X; q++)
                                j = N[q],
                                u(j[2], j[1], j[0]);
                            for (q = 0; q < X; q++)
                                j = N[q],
                                u(j[0] + W * T, j[1] + W * T, j[2] + W * T)
                        }
                    }
                    function s() {
                        var t = 0;
                        for (h(z, t),
                        t += z.length,
                        R = 0,
                        L = U.length; R < L; R++)
                            P = U[R],
                            h(P, t),
                            t += P.length
                    }
                    function h(t, e) {
                        var i, n;
                        for (q = t.length; --q >= 0; ) {
                            i = q,
                            n = q - 1,
                            n < 0 && (n = t.length - 1);
                            var r = 0
                              , a = T + 2 * b;
                            for (r = 0; r < a; r++) {
                                var o = W * r
                                  , s = W * (r + 1)
                                  , l = e + i + o
                                  , h = e + n + o
                                  , c = e + n + s
                                  , u = e + i + s;
                                p(l, h, c, u, t, r, a, i, n)
                            }
                        }
                    }
                    function c(t, e, i) {
                        C.vertices.push(new l(t,e,i))
                    }
                    function u(t, e, i) {
                        t += O,
                        e += O,
                        i += O,
                        C.faces.push(new Ut(t,e,i,null,null,0));
                        var n = A.generateTopUV(C, t, e, i);
                        C.faceVertexUvs[0].push(n)
                    }
                    function p(t, e, i, n, r, a, o, s, l) {
                        t += O,
                        e += O,
                        i += O,
                        n += O,
                        C.faces.push(new Ut(t,e,n,null,null,1)),
                        C.faces.push(new Ut(e,i,n,null,null,1));
                        var h = A.generateSideWallUV(C, t, e, i, n);
                        C.faceVertexUvs[0].push([h[0], h[1], h[3]]),
                        C.faceVertexUvs[0].push([h[1], h[2], h[3]])
                    }
                    var d, f, m, g, v, _ = void 0 !== i.amount ? i.amount : 100, y = void 0 !== i.bevelThickness ? i.bevelThickness : 6, x = void 0 !== i.bevelSize ? i.bevelSize : y - 2, b = void 0 !== i.bevelSegments ? i.bevelSegments : 3, w = void 0 === i.bevelEnabled || i.bevelEnabled, M = void 0 !== i.curveSegments ? i.curveSegments : 12, T = void 0 !== i.steps ? i.steps : 1, S = i.extrudePath, E = !1, A = void 0 !== i.UVGenerator ? i.UVGenerator : Ri.WorldUVGenerator;
                    S && (d = S.getSpacedPoints(T),
                    E = !0,
                    w = !1,
                    f = void 0 !== i.frames ? i.frames : new Pi.FrenetFrames(S,T,!1),
                    m = new l,
                    g = new l,
                    v = new l),
                    w || (b = 0,
                    y = 0,
                    x = 0);
                    var P, R, L, C = this, O = this.vertices.length, I = t.extractPoints(M), D = I.shape, U = I.holes, F = !e.ShapeUtils.isClockWise(D);
                    if (F) {
                        for (D = D.reverse(),
                        R = 0,
                        L = U.length; R < L; R++)
                            P = U[R],
                            e.ShapeUtils.isClockWise(P) && (U[R] = P.reverse());
                        F = !1
                    }
                    var N = e.ShapeUtils.triangulateShape(D, U)
                      , z = D;
                    for (R = 0,
                    L = U.length; R < L; R++)
                        P = U[R],
                        D = D.concat(P);
                    for (var B, k, G, V, H, j, W = D.length, X = N.length, Y = [], q = 0, Z = z.length, Q = Z - 1, J = q + 1; q < Z; q++,
                    Q++,
                    J++)
                        Q === Z && (Q = 0),
                        J === Z && (J = 0),
                        Y[q] = a(z[q], z[Q], z[J]);
                    var K, $ = [], tt = Y.concat();
                    for (R = 0,
                    L = U.length; R < L; R++) {
                        for (P = U[R],
                        K = [],
                        q = 0,
                        Z = P.length,
                        Q = Z - 1,
                        J = q + 1; q < Z; q++,
                        Q++,
                        J++)
                            Q === Z && (Q = 0),
                            J === Z && (J = 0),
                            K[q] = a(P[q], P[Q], P[J]);
                        $.push(K),
                        tt = tt.concat(K)
                    }
                    for (B = 0; B < b; B++) {
                        for (G = B / b,
                        V = y * Math.cos(G * Math.PI / 2),
                        k = x * Math.sin(G * Math.PI / 2),
                        q = 0,
                        Z = z.length; q < Z; q++)
                            H = r(z[q], Y[q], k),
                            c(H.x, H.y, -V);
                        for (R = 0,
                        L = U.length; R < L; R++)
                            for (P = U[R],
                            K = $[R],
                            q = 0,
                            Z = P.length; q < Z; q++)
                                H = r(P[q], K[q], k),
                                c(H.x, H.y, -V)
                    }
                    for (k = x,
                    q = 0; q < W; q++)
                        H = w ? r(D[q], tt[q], k) : D[q],
                        E ? (g.copy(f.normals[0]).multiplyScalar(H.x),
                        m.copy(f.binormals[0]).multiplyScalar(H.y),
                        v.copy(d[0]).add(g).add(m),
                        c(v.x, v.y, v.z)) : c(H.x, H.y, 0);
                    var et;
                    for (et = 1; et <= T; et++)
                        for (q = 0; q < W; q++)
                            H = w ? r(D[q], tt[q], k) : D[q],
                            E ? (g.copy(f.normals[et]).multiplyScalar(H.x),
                            m.copy(f.binormals[et]).multiplyScalar(H.y),
                            v.copy(d[et]).add(g).add(m),
                            c(v.x, v.y, v.z)) : c(H.x, H.y, _ / T * et);
                    for (B = b - 1; B >= 0; B--) {
                        for (G = B / b,
                        V = y * Math.cos(G * Math.PI / 2),
                        k = x * Math.sin(G * Math.PI / 2),
                        q = 0,
                        Z = z.length; q < Z; q++)
                            H = r(z[q], Y[q], k),
                            c(H.x, H.y, _ + V);
                        for (R = 0,
                        L = U.length; R < L; R++)
                            for (P = U[R],
                            K = $[R],
                            q = 0,
                            Z = P.length; q < Z; q++)
                                H = r(P[q], K[q], k),
                                E ? c(H.x, H.y + d[T - 1].y, d[T - 1].x + V) : c(H.x, H.y, _ + V)
                    }
                    o(),
                    s()
                }
                ,
                Ri.WorldUVGenerator = {
                    generateTopUV: function(t, e, i, r) {
                        var a = t.vertices
                          , o = a[e]
                          , s = a[i]
                          , l = a[r];
                        return [new n(o.x,o.y), new n(s.x,s.y), new n(l.x,l.y)]
                    },
                    generateSideWallUV: function(t, e, i, r, a) {
                        var o = t.vertices
                          , s = o[e]
                          , l = o[i]
                          , h = o[r]
                          , c = o[a];
                        return Math.abs(s.y - l.y) < .01 ? [new n(s.x,1 - s.z), new n(l.x,1 - l.z), new n(h.x,1 - h.z), new n(c.x,1 - c.z)] : [new n(s.y,1 - s.z), new n(l.y,1 - l.z), new n(h.y,1 - h.z), new n(c.y,1 - c.z)]
                    }
                },
                Li.prototype = Object.create(kt.prototype),
                Li.prototype.constructor = Li,
                Li.prototype.addShapeList = function(t, e) {
                    for (var i = 0, n = t.length; i < n; i++)
                        this.addShape(t[i], e);
                    return this
                }
                ,
                Li.prototype.addShape = function(t, i) {
                    void 0 === i && (i = {});
                    var n, r, a, o = void 0 !== i.curveSegments ? i.curveSegments : 12, s = i.material, h = void 0 === i.UVGenerator ? Ri.WorldUVGenerator : i.UVGenerator, c = this.vertices.length, u = t.extractPoints(o), p = u.shape, d = u.holes, f = !e.ShapeUtils.isClockWise(p);
                    if (f) {
                        for (p = p.reverse(),
                        n = 0,
                        r = d.length; n < r; n++)
                            a = d[n],
                            e.ShapeUtils.isClockWise(a) && (d[n] = a.reverse());
                        f = !1
                    }
                    var m = e.ShapeUtils.triangulateShape(p, d);
                    for (n = 0,
                    r = d.length; n < r; n++)
                        a = d[n],
                        p = p.concat(a);
                    var g, v, _ = p.length, y = m.length;
                    for (n = 0; n < _; n++)
                        g = p[n],
                        this.vertices.push(new l(g.x,g.y,0));
                    for (n = 0; n < y; n++) {
                        v = m[n];
                        var x = v[0] + c
                          , b = v[1] + c
                          , w = v[2] + c;
                        this.faces.push(new Ut(x,b,w,null,null,s)),
                        this.faceVertexUvs[0].push(h.generateTopUV(this, x, b, w))
                    }
                }
                ,
                Ci.prototype = Object.assign(Object.create(Bl), {
                    constructor: Ci,
                    extrude: function(t) {
                        return new Ri(this,t)
                    },
                    makeGeometry: function(t) {
                        return new Li(this,t)
                    },
                    getPointsHoles: function(t) {
                        for (var e = [], i = 0, n = this.holes.length; i < n; i++)
                            e[i] = this.holes[i].getPoints(t);
                        return e
                    },
                    extractAllPoints: function(t) {
                        return {
                            shape: this.getPoints(t),
                            holes: this.getPointsHoles(t)
                        }
                    },
                    extractPoints: function(t) {
                        return this.extractAllPoints(t)
                    }
                }),
                Oi.prototype = Bl,
                Bl.constructor = Oi,
                Ii.prototype = {
                    moveTo: function(t, e) {
                        this.currentPath = new Oi,
                        this.subPaths.push(this.currentPath),
                        this.currentPath.moveTo(t, e)
                    },
                    lineTo: function(t, e) {
                        this.currentPath.lineTo(t, e)
                    },
                    quadraticCurveTo: function(t, e, i, n) {
                        this.currentPath.quadraticCurveTo(t, e, i, n)
                    },
                    bezierCurveTo: function(t, e, i, n, r, a) {
                        this.currentPath.bezierCurveTo(t, e, i, n, r, a)
                    },
                    splineThru: function(t) {
                        this.currentPath.splineThru(t)
                    },
                    toShapes: function(t, i) {
                        function n(t) {
                            for (var e = [], i = 0, n = t.length; i < n; i++) {
                                var r = t[i]
                                  , a = new Ci;
                                a.curves = r.curves,
                                e.push(a)
                            }
                            return e
                        }
                        function r(t, e) {
                            for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                                var o = e[r]
                                  , s = e[a]
                                  , l = s.x - o.x
                                  , h = s.y - o.y;
                                if (Math.abs(h) > Number.EPSILON) {
                                    if (h < 0 && (o = e[a],
                                    l = -l,
                                    s = e[r],
                                    h = -h),
                                    t.y < o.y || t.y > s.y)
                                        continue;
                                    if (t.y === o.y) {
                                        if (t.x === o.x)
                                            return !0
                                    } else {
                                        var c = h * (t.x - o.x) - l * (t.y - o.y);
                                        if (0 === c)
                                            return !0;
                                        if (c < 0)
                                            continue;
                                        n = !n
                                    }
                                } else {
                                    if (t.y !== o.y)
                                        continue;
                                    if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x)
                                        return !0
                                }
                            }
                            return n
                        }
                        var a = e.ShapeUtils.isClockWise
                          , o = this.subPaths;
                        if (0 === o.length)
                            return [];
                        if (i === !0)
                            return n(o);
                        var s, l, h, c = [];
                        if (1 === o.length)
                            return l = o[0],
                            h = new Ci,
                            h.curves = l.curves,
                            c.push(h),
                            c;
                        var u = !a(o[0].getPoints());
                        u = t ? !u : u;
                        var p, d = [], f = [], m = [], g = 0;
                        f[g] = void 0,
                        m[g] = [];
                        for (var v = 0, _ = o.length; v < _; v++)
                            l = o[v],
                            p = l.getPoints(),
                            s = a(p),
                            s = t ? !s : s,
                            s ? (!u && f[g] && g++,
                            f[g] = {
                                s: new Ci,
                                p: p
                            },
                            f[g].s.curves = l.curves,
                            u && g++,
                            m[g] = []) : m[g].push({
                                h: l,
                                p: p[0]
                            });
                        if (!f[0])
                            return n(o);
                        if (f.length > 1) {
                            for (var y = !1, x = [], b = 0, w = f.length; b < w; b++)
                                d[b] = [];
                            for (var b = 0, w = f.length; b < w; b++)
                                for (var M = m[b], T = 0; T < M.length; T++) {
                                    for (var S = M[T], E = !0, A = 0; A < f.length; A++)
                                        r(S.p, f[A].p) && (b !== A && x.push({
                                            froms: b,
                                            tos: A,
                                            hole: T
                                        }),
                                        E ? (E = !1,
                                        d[A].push(S)) : y = !0);
                                    E && d[b].push(S)
                                }
                            x.length > 0 && (y || (m = d))
                        }
                        for (var P, v = 0, R = f.length; v < R; v++) {
                            h = f[v].s,
                            c.push(h),
                            P = m[v];
                            for (var L = 0, C = P.length; L < C; L++)
                                h.holes.push(P[L].h)
                        }
                        return c
                    }
                },
                Object.assign(Di.prototype, {
                    isFont: !0,
                    generateShapes: function(t, i, n) {
                        function r(t) {
                            for (var e = String(t).split(""), n = i / o.resolution, r = 0, s = [], l = 0; l < e.length; l++) {
                                var h = a(e[l], n, r);
                                r += h.offset,
                                s.push(h.path)
                            }
                            return s
                        }
                        function a(t, i, r) {
                            var a = o.glyphs[t] || o.glyphs["?"];
                            if (a) {
                                var s, l, h, c, u, p, d, f, m, g, v, _ = new Ii, y = [], x = e.ShapeUtils.b2, b = e.ShapeUtils.b3;
                                if (a.o)
                                    for (var w = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), M = 0, T = w.length; M < T; ) {
                                        var S = w[M++];
                                        switch (S) {
                                        case "m":
                                            s = w[M++] * i + r,
                                            l = w[M++] * i,
                                            _.moveTo(s, l);
                                            break;
                                        case "l":
                                            s = w[M++] * i + r,
                                            l = w[M++] * i,
                                            _.lineTo(s, l);
                                            break;
                                        case "q":
                                            if (h = w[M++] * i + r,
                                            c = w[M++] * i,
                                            d = w[M++] * i + r,
                                            f = w[M++] * i,
                                            _.quadraticCurveTo(d, f, h, c),
                                            v = y[y.length - 1]) {
                                                u = v.x,
                                                p = v.y;
                                                for (var E = 1; E <= n; E++) {
                                                    var A = E / n;
                                                    x(A, u, d, h),
                                                    x(A, p, f, c)
                                                }
                                            }
                                            break;
                                        case "b":
                                            if (h = w[M++] * i + r,
                                            c = w[M++] * i,
                                            d = w[M++] * i + r,
                                            f = w[M++] * i,
                                            m = w[M++] * i + r,
                                            g = w[M++] * i,
                                            _.bezierCurveTo(d, f, m, g, h, c),
                                            v = y[y.length - 1]) {
                                                u = v.x,
                                                p = v.y;
                                                for (var E = 1; E <= n; E++) {
                                                    var A = E / n;
                                                    b(A, u, d, m, h),
                                                    b(A, p, f, g, c)
                                                }
                                            }
                                        }
                                    }
                                return {
                                    offset: a.ha * i,
                                    path: _
                                }
                            }
                        }
                        void 0 === i && (i = 100),
                        void 0 === n && (n = 4);
                        for (var o = this.data, s = r(t), l = [], h = 0, c = s.length; h < c; h++)
                            Array.prototype.push.apply(l, s[h].toShapes());
                        return l
                    }
                }),
                Object.assign(Ui.prototype, {
                    load: function(t, e, i, n) {
                        var r = this
                          , a = new Ge(this.manager);
                        a.load(t, function(t) {
                            var i;
                            try {
                                i = JSON.parse(t)
                            } catch (e) {
                                console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                                i = JSON.parse(t.substring(65, t.length - 2))
                            }
                            var n = r.parse(i);
                            e && e(n)
                        }, i, n)
                    },
                    parse: function(t) {
                        return new Di(t)
                    }
                });
                var kl;
                Object.assign(Ni.prototype, {
                    load: function(t, e, i, n) {
                        var r = new Ge(this.manager);
                        r.setResponseType("arraybuffer"),
                        r.load(t, function(t) {
                            var i = Fi();
                            i.decodeAudioData(t, function(t) {
                                e(t)
                            })
                        }, i, n)
                    }
                }),
                Object.assign(zi.prototype, {
                    update: function() {
                        var t, i, n, r, a, s = new o, l = new o;
                        return function(o) {
                            var h = t !== o.focus || i !== o.fov || n !== o.aspect * this.aspect || r !== o.near || a !== o.far;
                            if (h) {
                                t = o.focus,
                                i = o.fov,
                                n = o.aspect * this.aspect,
                                r = o.near,
                                a = o.far;
                                var c, u, p = o.projectionMatrix.clone(), d = this.eyeSep / 2, f = d * r / t, m = r * Math.tan(e.Math.DEG2RAD * i * .5);
                                l.elements[12] = -d,
                                s.elements[12] = d,
                                c = -m * n + f,
                                u = m * n + f,
                                p.elements[0] = 2 * r / (u - c),
                                p.elements[8] = (u + c) / (u - c),
                                this.cameraL.projectionMatrix.copy(p),
                                c = -m * n - f,
                                u = m * n - f,
                                p.elements[0] = 2 * r / (u - c),
                                p.elements[8] = (u + c) / (u - c),
                                this.cameraR.projectionMatrix.copy(p)
                            }
                            this.cameraL.matrixWorld.copy(o.matrixWorld).multiply(l),
                            this.cameraR.matrixWorld.copy(o.matrixWorld).multiply(s)
                        }
                    }()
                }),
                Bi.prototype = Object.create(zt.prototype),
                Bi.prototype.constructor = Bi,
                ki.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: ki,
                    getInput: function() {
                        return this.gain
                    },
                    removeFilter: function() {
                        null !== this.filter && (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination),
                        this.gain.connect(this.context.destination),
                        this.filter = null)
                    },
                    getFilter: function() {
                        return this.filter
                    },
                    setFilter: function(t) {
                        null !== this.filter ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                        this.filter = t,
                        this.gain.connect(this.filter),
                        this.filter.connect(this.context.destination)
                    },
                    getMasterVolume: function() {
                        return this.gain.gain.value
                    },
                    setMasterVolume: function(t) {
                        this.gain.gain.value = t
                    },
                    updateMatrixWorld: function() {
                        var t = new l
                          , e = new s
                          , i = new l
                          , n = new l;
                        return function(r) {
                            zt.prototype.updateMatrixWorld.call(this, r);
                            var a = this.context.listener
                              , o = this.up;
                            this.matrixWorld.decompose(t, e, i),
                            n.set(0, 0, -1).applyQuaternion(e),
                            a.setPosition(t.x, t.y, t.z),
                            a.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z)
                        }
                    }()
                }),
                Gi.prototype = Object.assign(Object.create(zt.prototype), {
                    constructor: Gi,
                    getOutput: function() {
                        return this.gain
                    },
                    setNodeSource: function(t) {
                        return this.hasPlaybackControl = !1,
                        this.sourceType = "audioNode",
                        this.source = t,
                        this.connect(),
                        this
                    },
                    setBuffer: function(t) {
                        return this.source.buffer = t,
                        this.sourceType = "buffer",
                        this.autoplay && this.play(),
                        this
                    },
                    play: function() {
                        if (this.isPlaying === !0)
                            return void console.warn("THREE.Audio: Audio is already playing.");
                        if (this.hasPlaybackControl === !1)
                            return void console.warn("THREE.Audio: this Audio has no playback control.");
                        var t = this.context.createBufferSource();
                        return t.buffer = this.source.buffer,
                        t.loop = this.source.loop,
                        t.onended = this.source.onended,
                        t.start(0, this.startTime),
                        t.playbackRate.value = this.playbackRate,
                        this.isPlaying = !0,
                        this.source = t,
                        this.connect()
                    },
                    pause: function() {
                        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
                        this.startTime = this.context.currentTime,
                        this.isPlaying = !1,
                        this)
                    },
                    stop: function() {
                        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(),
                        this.startTime = 0,
                        this.isPlaying = !1,
                        this)
                    },
                    connect: function() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (var t = 1, e = this.filters.length; t < e; t++)
                                this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else
                            this.source.connect(this.getOutput());
                        return this
                    },
                    disconnect: function() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (var t = 1, e = this.filters.length; t < e; t++)
                                this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else
                            this.source.disconnect(this.getOutput());
                        return this
                    },
                    getFilters: function() {
                        return this.filters
                    },
                    setFilters: function(t) {
                        return t || (t = []),
                        this.isPlaying === !0 ? (this.disconnect(),
                        this.filters = t,
                        this.connect()) : this.filters = t,
                        this
                    },
                    getFilter: function() {
                        return this.getFilters()[0]
                    },
                    setFilter: function(t) {
                        return this.setFilters(t ? [t] : [])
                    },
                    setPlaybackRate: function(t) {
                        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t,
                        this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate),
                        this)
                    },
                    getPlaybackRate: function() {
                        return this.playbackRate
                    },
                    onEnded: function() {
                        this.isPlaying = !1
                    },
                    getLoop: function() {
                        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                        !1) : this.source.loop
                    },
                    setLoop: function(t) {
                        return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void (this.source.loop = t)
                    },
                    getVolume: function() {
                        return this.gain.gain.value
                    },
                    setVolume: function(t) {
                        return this.gain.gain.value = t,
                        this
                    }
                }),
                Vi.prototype = Object.assign(Object.create(Gi.prototype), {
                    constructor: Vi,
                    getOutput: function() {
                        return this.panner
                    },
                    getRefDistance: function() {
                        return this.panner.refDistance
                    },
                    setRefDistance: function(t) {
                        this.panner.refDistance = t
                    },
                    getRolloffFactor: function() {
                        return this.panner.rolloffFactor
                    },
                    setRolloffFactor: function(t) {
                        this.panner.rolloffFactor = t
                    },
                    getDistanceModel: function() {
                        return this.panner.distanceModel
                    },
                    setDistanceModel: function(t) {
                        this.panner.distanceModel = t
                    },
                    getMaxDistance: function() {
                        return this.panner.maxDistance
                    },
                    setMaxDistance: function(t) {
                        this.panner.maxDistance = t
                    },
                    updateMatrixWorld: function() {
                        var t = new l;
                        return function(e) {
                            zt.prototype.updateMatrixWorld.call(this, e),
                            t.setFromMatrixPosition(this.matrixWorld),
                            this.panner.setPosition(t.x, t.y, t.z)
                        }
                    }()
                }),
                Object.assign(Hi.prototype, {
                    getFrequencyData: function() {
                        return this.analyser.getByteFrequencyData(this.data),
                        this.data
                    },
                    getAverageFrequency: function() {
                        for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)
                            t += e[i];
                        return t / e.length
                    }
                }),
                ji.prototype = {
                    constructor: ji,
                    accumulate: function(t, e) {
                        var i = this.buffer
                          , n = this.valueSize
                          , r = t * n + n
                          , a = this.cumulativeWeight;
                        if (0 === a) {
                            for (var o = 0; o !== n; ++o)
                                i[r + o] = i[o];
                            a = e
                        } else {
                            a += e;
                            var s = e / a;
                            this._mixBufferRegion(i, r, 0, s, n)
                        }
                        this.cumulativeWeight = a
                    },
                    apply: function(t) {
                        var e = this.valueSize
                          , i = this.buffer
                          , n = t * e + e
                          , r = this.cumulativeWeight
                          , a = this.binding;
                        if (this.cumulativeWeight = 0,
                        r < 1) {
                            var o = 3 * e;
                            this._mixBufferRegion(i, n, o, 1 - r, e)
                        }
                        for (var s = e, l = e + e; s !== l; ++s)
                            if (i[s] !== i[s + e]) {
                                a.setValue(i, n);
                                break
                            }
                    },
                    saveOriginalState: function() {
                        var t = this.binding
                          , e = this.buffer
                          , i = this.valueSize
                          , n = 3 * i;
                        t.getValue(e, n);
                        for (var r = i, a = n; r !== a; ++r)
                            e[r] = e[n + r % i];
                        this.cumulativeWeight = 0
                    },
                    restoreOriginalState: function() {
                        var t = 3 * this.valueSize;
                        this.binding.setValue(this.buffer, t)
                    },
                    _select: function(t, e, i, n, r) {
                        if (n >= .5)
                            for (var a = 0; a !== r; ++a)
                                t[e + a] = t[i + a]
                    },
                    _slerp: function(t, e, i, n, r) {
                        s.slerpFlat(t, e, t, e, t, i, n)
                    },
                    _lerp: function(t, e, i, n, r) {
                        for (var a = 1 - n, o = 0; o !== r; ++o) {
                            var s = e + o;
                            t[s] = t[s] * a + t[i + o] * n
                        }
                    }
                },
                Wi.prototype = {
                    constructor: Wi,
                    getValue: function(t, e) {
                        this.bind(),
                        this.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        this.bind(),
                        this.setValue(t, e)
                    },
                    bind: function() {
                        var t = this.node
                          , e = this.parsedPath
                          , i = e.objectName
                          , n = e.propertyName
                          , r = e.propertyIndex;
                        if (t || (t = Wi.findNode(this.rootNode, e.nodeName) || this.rootNode,
                        this.node = t),
                        this.getValue = this._getValue_unavailable,
                        this.setValue = this._setValue_unavailable,
                        !t)
                            return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                        if (i) {
                            var a = e.objectIndex;
                            switch (i) {
                            case "materials":
                                if (!t.material)
                                    return void console.error("  can not bind to material as node does not have a material", this);
                                if (!t.material.materials)
                                    return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton)
                                    return void console.error("  can not bind to bones as node does not have a skeleton", this);
                                t = t.skeleton.bones;
                                for (var o = 0; o < t.length; o++)
                                    if (t[o].name === a) {
                                        a = o;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[i])
                                    return void console.error("  can not bind to objectName of node, undefined", this);
                                t = t[i]
                            }
                            if (void 0 !== a) {
                                if (void 0 === t[a])
                                    return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
                                t = t[a]
                            }
                        }
                        var s = t[n];
                        if (void 0 === s) {
                            var l = e.nodeName;
                            return void console.error("  trying to update property for track: " + l + "." + n + " but it wasn't found.", t)
                        }
                        var h = this.Versioning.None;
                        void 0 !== t.needsUpdate ? (h = this.Versioning.NeedsUpdate,
                        this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate,
                        this.targetObject = t);
                        var c = this.BindingType.Direct;
                        if (void 0 !== r) {
                            if ("morphTargetInfluences" === n) {
                                if (!t.geometry)
                                    return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                                if (!t.geometry.morphTargets)
                                    return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                                for (var o = 0; o < this.node.geometry.morphTargets.length; o++)
                                    if (t.geometry.morphTargets[o].name === r) {
                                        r = o;
                                        break
                                    }
                            }
                            c = this.BindingType.ArrayElement,
                            this.resolvedProperty = s,
                            this.propertyIndex = r
                        } else
                            void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray,
                            this.resolvedProperty = s) : void 0 !== s.length ? (c = this.BindingType.EntireArray,
                            this.resolvedProperty = s) : this.propertyName = n;
                        this.getValue = this.GetterByBindingType[c],
                        this.setValue = this.SetterByBindingTypeAndVersioning[c][h]
                    },
                    unbind: function() {
                        this.node = null,
                        this.getValue = this._getValue_unbound,
                        this.setValue = this._setValue_unbound
                    }
                },
                Object.assign(Wi.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    _getValue_unbound: Wi.prototype.getValue,
                    _setValue_unbound: Wi.prototype.setValue,
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(t, e) {
                        t[e] = this.node[this.propertyName]
                    }
                    , function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                            t[e++] = i[n]
                    }
                    , function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }
                    , function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }
                    ],
                    SetterByBindingTypeAndVersioning: [[function(t, e) {
                        this.node[this.propertyName] = t[e]
                    }
                    , function(t, e) {
                        this.node[this.propertyName] = t[e],
                        this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        this.node[this.propertyName] = t[e],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ], [function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                            i[n] = t[e++]
                    }
                    , function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                            i[n] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                            i[n] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ], [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }
                    , function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e],
                        this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e],
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ], [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }
                    , function(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                        this.targetObject.needsUpdate = !0
                    }
                    , function(t, e) {
                        this.resolvedProperty.fromArray(t, e),
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    ]]
                }),
                Wi.Composite = function(t, e, i) {
                    var n = i || Wi.parseTrackName(e);
                    this._targetGroup = t,
                    this._bindings = t.subscribe_(e, n)
                }
                ,
                Wi.Composite.prototype = {
                    constructor: Wi.Composite,
                    getValue: function(t, e) {
                        this.bind();
                        var i = this._targetGroup.nCachedObjects_
                          , n = this._bindings[i];
                        void 0 !== n && n.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
                            i[n].setValue(t, e)
                    },
                    bind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                            t[e].bind()
                    },
                    unbind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)
                            t[e].unbind()
                    }
                },
                Wi.create = function(t, e, i) {
                    return t && t.isAnimationObjectGroup ? new Wi.Composite(t,e,i) : new Wi(t,e,i)
                }
                ,
                Wi.parseTrackName = function(t) {
                    var e = /^((?:\w+\/)*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/
                      , i = e.exec(t);
                    if (!i)
                        throw new Error("cannot parse trackName at all: " + t);
                    var n = {
                        nodeName: i[2],
                        objectName: i[3],
                        objectIndex: i[4],
                        propertyName: i[5],
                        propertyIndex: i[6]
                    };
                    if (null === n.propertyName || 0 === n.propertyName.length)
                        throw new Error("can not parse propertyName from trackName: " + t);
                    return n
                }
                ,
                Wi.findNode = function(t, e) {
                    if (!e || "" === e || "root" === e || "." === e || e === -1 || e === t.name || e === t.uuid)
                        return t;
                    if (t.skeleton) {
                        var i = function(t) {
                            for (var i = 0; i < t.bones.length; i++) {
                                var n = t.bones[i];
                                if (n.name === e)
                                    return n
                            }
                            return null
                        }
                          , n = i(t.skeleton);
                        if (n)
                            return n
                    }
                    if (t.children) {
                        var r = function(t) {
                            for (var i = 0; i < t.length; i++) {
                                var n = t[i];
                                if (n.name === e || n.uuid === e)
                                    return n;
                                var a = r(n.children);
                                if (a)
                                    return a
                            }
                            return null
                        }
                          , a = r(t.children);
                        if (a)
                            return a
                    }
                    return null
                }
                ,
                Xi.prototype = {
                    constructor: Xi,
                    isAnimationObjectGroup: !0,
                    add: function(t) {
                        for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, a = this._paths, o = this._parsedPaths, s = this._bindings, l = s.length, h = 0, c = arguments.length; h !== c; ++h) {
                            var u = arguments[h]
                              , p = u.uuid
                              , d = r[p];
                            if (void 0 === d) {
                                d = i++,
                                r[p] = d,
                                e.push(u);
                                for (var f = 0, m = l; f !== m; ++f)
                                    s[f].push(new Wi(u,a[f],o[f]))
                            } else if (d < n) {
                                var g = e[d]
                                  , v = --n
                                  , _ = e[v];
                                r[_.uuid] = d,
                                e[d] = _,
                                r[p] = v,
                                e[v] = u;
                                for (var f = 0, m = l; f !== m; ++f) {
                                    var y = s[f]
                                      , x = y[v]
                                      , b = y[d];
                                    y[d] = x,
                                    void 0 === b && (b = new Wi(u,a[f],o[f])),
                                    y[v] = b
                                }
                            } else
                                e[d] !== g && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                        }
                        this.nCachedObjects_ = n
                    },
                    remove: function(t) {
                        for (var e = this._objects, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                            var l = arguments[o]
                              , h = l.uuid
                              , c = n[h];
                            if (void 0 !== c && c >= i) {
                                var u = i++
                                  , p = e[u];
                                n[p.uuid] = c,
                                e[c] = p,
                                n[h] = u,
                                e[u] = l;
                                for (var d = 0, f = a; d !== f; ++d) {
                                    var m = r[d]
                                      , g = m[u]
                                      , v = m[c];
                                    m[c] = g,
                                    m[u] = v
                                }
                            }
                        }
                        this.nCachedObjects_ = i
                    },
                    uncache: function(t) {
                        for (var e = this._objects, i = e.length, n = this.nCachedObjects_, r = this._indicesByUUID, a = this._bindings, o = a.length, s = 0, l = arguments.length; s !== l; ++s) {
                            var h = arguments[s]
                              , c = h.uuid
                              , u = r[c];
                            if (void 0 !== u)
                                if (delete r[c],
                                u < n) {
                                    var p = --n
                                      , d = e[p]
                                      , f = --i
                                      , m = e[f];
                                    r[d.uuid] = u,
                                    e[u] = d,
                                    r[m.uuid] = p,
                                    e[p] = m,
                                    e.pop();
                                    for (var g = 0, v = o; g !== v; ++g) {
                                        var _ = a[g]
                                          , y = _[p]
                                          , x = _[f];
                                        _[u] = y,
                                        _[p] = x,
                                        _.pop()
                                    }
                                } else {
                                    var f = --i
                                      , m = e[f];
                                    r[m.uuid] = u,
                                    e[u] = m,
                                    e.pop();
                                    for (var g = 0, v = o; g !== v; ++g) {
                                        var _ = a[g];
                                        _[u] = _[f],
                                        _.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = n
                    },
                    subscribe_: function(t, e) {
                        var i = this._bindingsIndicesByPath
                          , n = i[t]
                          , r = this._bindings;
                        if (void 0 !== n)
                            return r[n];
                        var a = this._paths
                          , o = this._parsedPaths
                          , s = this._objects
                          , l = s.length
                          , h = this.nCachedObjects_
                          , c = new Array(l);
                        n = r.length,
                        i[t] = n,
                        a.push(t),
                        o.push(e),
                        r.push(c);
                        for (var u = h, p = s.length; u !== p; ++u) {
                            var d = s[u];
                            c[u] = new Wi(d,t,e)
                        }
                        return c
                    },
                    unsubscribe_: function(t) {
                        var e = this._bindingsIndicesByPath
                          , i = e[t];
                        if (void 0 !== i) {
                            var n = this._paths
                              , r = this._parsedPaths
                              , a = this._bindings
                              , o = a.length - 1
                              , s = a[o]
                              , l = t[o];
                            e[l] = i,
                            a[i] = s,
                            a.pop(),
                            r[i] = r[o],
                            r.pop(),
                            n[i] = n[o],
                            n.pop()
                        }
                    }
                },
                Yi.prototype = {
                    constructor: Yi,
                    play: function() {
                        return this._mixer._activateAction(this),
                        this
                    },
                    stop: function() {
                        return this._mixer._deactivateAction(this),
                        this.reset()
                    },
                    reset: function() {
                        return this.paused = !1,
                        this.enabled = !0,
                        this.time = 0,
                        this._loopCount = -1,
                        this._startTime = null,
                        this.stopFading().stopWarping()
                    },
                    isRunning: function() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function() {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function(t) {
                        return this._startTime = t,
                        this
                    },
                    setLoop: function(t, e) {
                        return this.loop = t,
                        this.repetitions = e,
                        this
                    },
                    setEffectiveWeight: function(t) {
                        return this.weight = t,
                        this._effectiveWeight = this.enabled ? t : 0,
                        this.stopFading()
                    },
                    getEffectiveWeight: function() {
                        return this._effectiveWeight
                    },
                    fadeIn: function(t) {
                        return this._scheduleFading(t, 0, 1)
                    },
                    fadeOut: function(t) {
                        return this._scheduleFading(t, 1, 0)
                    },
                    crossFadeFrom: function(t, e, i) {
                        if (t.fadeOut(e),
                        this.fadeIn(e),
                        i) {
                            var n = this._clip.duration
                              , r = t._clip.duration
                              , a = r / n
                              , o = n / r;
                            t.warp(1, a, e),
                            this.warp(o, 1, e)
                        }
                        return this
                    },
                    crossFadeTo: function(t, e, i) {
                        return t.crossFadeFrom(this, e, i)
                    },
                    stopFading: function() {
                        var t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null,
                        this._mixer._takeBackControlInterpolant(t)),
                        this
                    },
                    setEffectiveTimeScale: function(t) {
                        return this.timeScale = t,
                        this._effectiveTimeScale = this.paused ? 0 : t,
                        this.stopWarping()
                    },
                    getEffectiveTimeScale: function() {
                        return this._effectiveTimeScale
                    },
                    setDuration: function(t) {
                        return this.timeScale = this._clip.duration / t,
                        this.stopWarping()
                    },
                    syncWith: function(t) {
                        return this.time = t.time,
                        this.timeScale = t.timeScale,
                        this.stopWarping()
                    },
                    halt: function(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    },
                    warp: function(t, e, i) {
                        var n = this._mixer
                          , r = n.time
                          , a = this._timeScaleInterpolant
                          , o = this.timeScale;
                        null === a && (a = n._lendControlInterpolant(),
                        this._timeScaleInterpolant = a);
                        var s = a.parameterPositions
                          , l = a.sampleValues;
                        return s[0] = r,
                        s[1] = r + i,
                        l[0] = t / o,
                        l[1] = e / o,
                        this
                    },
                    stopWarping: function() {
                        var t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null,
                        this._mixer._takeBackControlInterpolant(t)),
                        this
                    },
                    getMixer: function() {
                        return this._mixer
                    },
                    getClip: function() {
                        return this._clip
                    },
                    getRoot: function() {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function(t, e, i, n) {
                        var r = this._startTime;
                        if (null !== r) {
                            var a = (t - r) * i;
                            if (a < 0 || 0 === i)
                                return;
                            this._startTime = null,
                            e = i * a
                        }
                        e *= this._updateTimeScale(t);
                        var o = this._updateTime(e)
                          , s = this._updateWeight(t);
                        if (s > 0)
                            for (var l = this._interpolants, h = this._propertyBindings, c = 0, u = l.length; c !== u; ++c)
                                l[c].evaluate(o),
                                h[c].accumulate(n, s)
                    },
                    _updateWeight: function(t) {
                        var e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            var i = this._weightInterpolant;
                            if (null !== i) {
                                var n = i.evaluate(t)[0];
                                e *= n,
                                t > i.parameterPositions[1] && (this.stopFading(),
                                0 === n && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e,
                        e
                    },
                    _updateTimeScale: function(t) {
                        var e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            var i = this._timeScaleInterpolant;
                            if (null !== i) {
                                var n = i.evaluate(t)[0];
                                e *= n,
                                t > i.parameterPositions[1] && (this.stopWarping(),
                                0 === e ? this.paused = !0 : this.timeScale = e)
                            }
                        }
                        return this._effectiveTimeScale = e,
                        e
                    },
                    _updateTime: function(t) {
                        var e = this.time + t;
                        if (0 === t)
                            return e;
                        var i = this._clip.duration
                          , n = this.loop
                          , r = this._loopCount;
                        if (n === ro) {
                            r === -1 && (this.loopCount = 0,
                            this._setEndings(!0, !0, !1));
                            t: {
                                if (e >= i)
                                    e = i;
                                else {
                                    if (!(e < 0))
                                        break t;
                                    e = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            var a = n === oo;
                            if (r === -1 && (t >= 0 ? (r = 0,
                            this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)),
                            e >= i || e < 0) {
                                var o = Math.floor(e / i);
                                e -= i * o,
                                r += Math.abs(o);
                                var s = this.repetitions - r;
                                if (s < 0)
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                    e = t > 0 ? i : 0,
                                    this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: t > 0 ? 1 : -1
                                    });
                                else {
                                    if (0 === s) {
                                        var l = t < 0;
                                        this._setEndings(l, !l, a)
                                    } else
                                        this._setEndings(!1, !1, a);
                                    this._loopCount = r,
                                    this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: o
                                    })
                                }
                            }
                            if (a && 1 === (1 & r))
                                return this.time = e,
                                i - e
                        }
                        return this.time = e,
                        e
                    },
                    _setEndings: function(t, e, i) {
                        var n = this._interpolantSettings;
                        i ? (n.endingStart = uo,
                        n.endingEnd = uo) : (t ? n.endingStart = this.zeroSlopeAtStart ? uo : co : n.endingStart = po,
                        e ? n.endingEnd = this.zeroSlopeAtEnd ? uo : co : n.endingEnd = po)
                    },
                    _scheduleFading: function(t, e, i) {
                        var n = this._mixer
                          , r = n.time
                          , a = this._weightInterpolant;
                        null === a && (a = n._lendControlInterpolant(),
                        this._weightInterpolant = a);
                        var o = a.parameterPositions
                          , s = a.sampleValues;
                        return o[0] = r,
                        s[0] = e,
                        o[1] = r + t,
                        s[1] = i,
                        this
                    }
                },
                Object.assign(qi.prototype, i.prototype, {
                    clipAction: function(t, e) {
                        var i = e || this._root
                          , n = i.uuid
                          , r = "string" == typeof t ? mi.findByName(i, t) : t
                          , a = null !== r ? r.uuid : t
                          , o = this._actionsByClip[a]
                          , s = null;
                        if (void 0 !== o) {
                            var l = o.actionByRoot[n];
                            if (void 0 !== l)
                                return l;
                            s = o.knownActions[0],
                            null === r && (r = s._clip)
                        }
                        if (null === r)
                            return null;
                        var h = new Yi(this,r,e);
                        return this._bindAction(h, s),
                        this._addInactiveAction(h, a, n),
                        h
                    },
                    existingAction: function(t, e) {
                        var i = e || this._root
                          , n = i.uuid
                          , r = "string" == typeof t ? mi.findByName(i, t) : t
                          , a = r ? r.uuid : t
                          , o = this._actionsByClip[a];
                        return void 0 !== o ? o.actionByRoot[n] || null : null
                    },
                    stopAllAction: function() {
                        var t = this._actions
                          , e = this._nActiveActions
                          , i = this._bindings
                          , n = this._nActiveBindings;
                        this._nActiveActions = 0,
                        this._nActiveBindings = 0;
                        for (var r = 0; r !== e; ++r)
                            t[r].reset();
                        for (var r = 0; r !== n; ++r)
                            i[r].useCount = 0;
                        return this
                    },
                    update: function(t) {
                        t *= this.timeScale;
                        for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) {
                            var s = e[o];
                            s.enabled && s._update(n, t, r, a)
                        }
                        for (var l = this._bindings, h = this._nActiveBindings, o = 0; o !== h; ++o)
                            l[o].apply(a);
                        return this
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(t) {
                        var e = this._actions
                          , i = t.uuid
                          , n = this._actionsByClip
                          , r = n[i];
                        if (void 0 !== r) {
                            for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                                var l = a[o];
                                this._deactivateAction(l);
                                var h = l._cacheIndex
                                  , c = e[e.length - 1];
                                l._cacheIndex = null,
                                l._byClipCacheIndex = null,
                                c._cacheIndex = h,
                                e[h] = c,
                                e.pop(),
                                this._removeInactiveBindingsForAction(l)
                            }
                            delete n[i]
                        }
                    },
                    uncacheRoot: function(t) {
                        var e = t.uuid
                          , i = this._actionsByClip;
                        for (var n in i) {
                            var r = i[n].actionByRoot
                              , a = r[e];
                            void 0 !== a && (this._deactivateAction(a),
                            this._removeInactiveAction(a))
                        }
                        var o = this._bindingsByRootAndName
                          , s = o[e];
                        if (void 0 !== s)
                            for (var l in s) {
                                var h = s[l];
                                h.restoreOriginalState(),
                                this._removeInactiveBinding(h)
                            }
                    },
                    uncacheAction: function(t, e) {
                        var i = this.existingAction(t, e);
                        null !== i && (this._deactivateAction(i),
                        this._removeInactiveAction(i))
                    }
                }),
                Object.assign(qi.prototype, {
                    _bindAction: function(t, e) {
                        var i = t._localRoot || this._root
                          , n = t._clip.tracks
                          , r = n.length
                          , a = t._propertyBindings
                          , o = t._interpolants
                          , s = i.uuid
                          , l = this._bindingsByRootAndName
                          , h = l[s];
                        void 0 === h && (h = {},
                        l[s] = h);
                        for (var c = 0; c !== r; ++c) {
                            var u = n[c]
                              , p = u.name
                              , d = h[p];
                            if (void 0 !== d)
                                a[c] = d;
                            else {
                                if (d = a[c],
                                void 0 !== d) {
                                    null === d._cacheIndex && (++d.referenceCount,
                                    this._addInactiveBinding(d, s, p));
                                    continue
                                }
                                var f = e && e._propertyBindings[c].binding.parsedPath;
                                d = new ji(Wi.create(i, p, f),u.ValueTypeName,u.getValueSize()),
                                ++d.referenceCount,
                                this._addInactiveBinding(d, s, p),
                                a[c] = d
                            }
                            o[c].resultBuffer = d.buffer
                        }
                    },
                    _activateAction: function(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                var e = (t._localRoot || this._root).uuid
                                  , i = t._clip.uuid
                                  , n = this._actionsByClip[i];
                                this._bindAction(t, n && n.knownActions[0]),
                                this._addInactiveAction(t, i, e)
                            }
                            for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                                var s = r[a];
                                0 === s.useCount++ && (this._lendBinding(s),
                                s.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    },
                    _deactivateAction: function(t) {
                        if (this._isActiveAction(t)) {
                            for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                                var r = e[i];
                                0 === --r.useCount && (r.restoreOriginalState(),
                                this._takeBackBinding(r))
                            }
                            this._takeBackAction(t)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [],
                        this._nActiveActions = 0,
                        this._actionsByClip = {},
                        this._bindings = [],
                        this._nActiveBindings = 0,
                        this._bindingsByRootAndName = {},
                        this._controlInterpolants = [],
                        this._nActiveControlInterpolants = 0;
                        var t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(t) {
                        var e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    },
                    _addInactiveAction: function(t, e, i) {
                        var n = this._actions
                          , r = this._actionsByClip
                          , a = r[e];
                        if (void 0 === a)
                            a = {
                                knownActions: [t],
                                actionByRoot: {}
                            },
                            t._byClipCacheIndex = 0,
                            r[e] = a;
                        else {
                            var o = a.knownActions;
                            t._byClipCacheIndex = o.length,
                            o.push(t)
                        }
                        t._cacheIndex = n.length,
                        n.push(t),
                        a.actionByRoot[i] = t
                    },
                    _removeInactiveAction: function(t) {
                        var e = this._actions
                          , i = e[e.length - 1]
                          , n = t._cacheIndex;
                        i._cacheIndex = n,
                        e[n] = i,
                        e.pop(),
                        t._cacheIndex = null;
                        var r = t._clip.uuid
                          , a = this._actionsByClip
                          , o = a[r]
                          , s = o.knownActions
                          , l = s[s.length - 1]
                          , h = t._byClipCacheIndex;
                        l._byClipCacheIndex = h,
                        s[h] = l,
                        s.pop(),
                        t._byClipCacheIndex = null;
                        var c = o.actionByRoot
                          , u = (e._localRoot || this._root).uuid;
                        delete c[u],
                        0 === s.length && delete a[r],
                        this._removeInactiveBindingsForAction(t)
                    },
                    _removeInactiveBindingsForAction: function(t) {
                        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                            var r = e[i];
                            0 === --r.referenceCount && this._removeInactiveBinding(r)
                        }
                    },
                    _lendAction: function(t) {
                        var e = this._actions
                          , i = t._cacheIndex
                          , n = this._nActiveActions++
                          , r = e[n];
                        t._cacheIndex = n,
                        e[n] = t,
                        r._cacheIndex = i,
                        e[i] = r
                    },
                    _takeBackAction: function(t) {
                        var e = this._actions
                          , i = t._cacheIndex
                          , n = --this._nActiveActions
                          , r = e[n];
                        t._cacheIndex = n,
                        e[n] = t,
                        r._cacheIndex = i,
                        e[i] = r
                    },
                    _addInactiveBinding: function(t, e, i) {
                        var n = this._bindingsByRootAndName
                          , r = n[e]
                          , a = this._bindings;
                        void 0 === r && (r = {},
                        n[e] = r),
                        r[i] = t,
                        t._cacheIndex = a.length,
                        a.push(t)
                    },
                    _removeInactiveBinding: function(t) {
                        var e = this._bindings
                          , i = t.binding
                          , n = i.rootNode.uuid
                          , r = i.path
                          , a = this._bindingsByRootAndName
                          , o = a[n]
                          , s = e[e.length - 1]
                          , l = t._cacheIndex;
                        s._cacheIndex = l,
                        e[l] = s,
                        e.pop(),
                        delete o[r];
                        t: {
                            for (var h in o)
                                break t;
                            delete a[n]
                        }
                    },
                    _lendBinding: function(t) {
                        var e = this._bindings
                          , i = t._cacheIndex
                          , n = this._nActiveBindings++
                          , r = e[n];
                        t._cacheIndex = n,
                        e[n] = t,
                        r._cacheIndex = i,
                        e[i] = r
                    },
                    _takeBackBinding: function(t) {
                        var e = this._bindings
                          , i = t._cacheIndex
                          , n = --this._nActiveBindings
                          , r = e[n];
                        t._cacheIndex = n,
                        e[n] = t,
                        r._cacheIndex = i,
                        e[i] = r
                    },
                    _lendControlInterpolant: function() {
                        var t = this._controlInterpolants
                          , e = this._nActiveControlInterpolants++
                          , i = t[e];
                        return void 0 === i && (i = new ri(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
                        i.__cacheIndex = e,
                        t[e] = i),
                        i
                    },
                    _takeBackControlInterpolant: function(t) {
                        var e = this._controlInterpolants
                          , i = t.__cacheIndex
                          , n = --this._nActiveControlInterpolants
                          , r = e[n];
                        t.__cacheIndex = n,
                        e[n] = t,
                        r.__cacheIndex = i,
                        e[i] = r
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1)
                }),
                Zi.prototype = {
                    constructor: Zi,
                    onUpdate: function(t) {
                        return this.dynamic = !0,
                        this.onUpdateCallback = t,
                        this
                    }
                },
                Qi.prototype = Object.create(Ht.prototype),
                Qi.prototype.constructor = Qi,
                Qi.prototype.isInstancedBufferGeometry = !0,
                Qi.prototype.addGroup = function(t, e, i) {
                    this.groups.push({
                        start: t,
                        count: e,
                        instances: i
                    })
                }
                ,
                Qi.prototype.copy = function(t) {
                    var e = t.index;
                    null !== e && this.setIndex(e.clone());
                    var i = t.attributes;
                    for (var n in i) {
                        var r = i[n];
                        this.addAttribute(n, r.clone())
                    }
                    for (var a = t.groups, o = 0, s = a.length; o < s; o++) {
                        var l = a[o];
                        this.addGroup(l.start, l.count, l.instances)
                    }
                    return this
                }
                ,
                Ji.prototype = {
                    constructor: Ji,
                    isInterleavedBufferAttribute: !0,
                    get length() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                        this.array.length
                    },
                    get count() {
                        return this.data.count
                    },
                    get array() {
                        return this.data.array
                    },
                    setX: function(t, e) {
                        return this.data.array[t * this.data.stride + this.offset] = e,
                        this
                    },
                    setY: function(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 1] = e,
                        this
                    },
                    setZ: function(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 2] = e,
                        this
                    },
                    setW: function(t, e) {
                        return this.data.array[t * this.data.stride + this.offset + 3] = e,
                        this
                    },
                    getX: function(t) {
                        return this.data.array[t * this.data.stride + this.offset]
                    },
                    getY: function(t) {
                        return this.data.array[t * this.data.stride + this.offset + 1]
                    },
                    getZ: function(t) {
                        return this.data.array[t * this.data.stride + this.offset + 2]
                    },
                    getW: function(t) {
                        return this.data.array[t * this.data.stride + this.offset + 3]
                    },
                    setXY: function(t, e, i) {
                        return t = t * this.data.stride + this.offset,
                        this.data.array[t + 0] = e,
                        this.data.array[t + 1] = i,
                        this
                    },
                    setXYZ: function(t, e, i, n) {
                        return t = t * this.data.stride + this.offset,
                        this.data.array[t + 0] = e,
                        this.data.array[t + 1] = i,
                        this.data.array[t + 2] = n,
                        this
                    },
                    setXYZW: function(t, e, i, n, r) {
                        return t = t * this.data.stride + this.offset,
                        this.data.array[t + 0] = e,
                        this.data.array[t + 1] = i,
                        this.data.array[t + 2] = n,
                        this.data.array[t + 3] = r,
                        this
                    }
                },
                Ki.prototype = {
                    constructor: Ki,
                    isInterleavedBuffer: !0,
                    get length() {
                        return this.array.length
                    },
                    get count() {
                        return this.array.length / this.stride
                    },
                    set needsUpdate(t) {
                        t === !0 && this.version++
                    },
                    setDynamic: function(t) {
                        return this.dynamic = t,
                        this
                    },
                    copy: function(t) {
                        return this.array = new t.array.constructor(t.array),
                        this.stride = t.stride,
                        this.dynamic = t.dynamic,
                        this
                    },
                    copyAt: function(t, e, i) {
                        t *= this.stride,
                        i *= e.stride;
                        for (var n = 0, r = this.stride; n < r; n++)
                            this.array[t + n] = e.array[i + n];
                        return this
                    },
                    set: function(t, e) {
                        return void 0 === e && (e = 0),
                        this.array.set(t, e),
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                },
                $i.prototype = Object.create(Ki.prototype),
                $i.prototype.constructor = $i,
                $i.prototype.isInstancedInterleavedBuffer = !0,
                $i.prototype.copy = function(t) {
                    return Ki.prototype.copy.call(this, t),
                    this.meshPerAttribute = t.meshPerAttribute,
                    this
                }
                ,
                tn.prototype = Object.create(Tt.prototype),
                tn.prototype.constructor = tn,
                tn.prototype.isInstancedBufferAttribute = !0,
                tn.prototype.copy = function(t) {
                    return Tt.prototype.copy.call(this, t),
                    this.meshPerAttribute = t.meshPerAttribute,
                    this
                }
                ,
                en.prototype = {
                    constructor: en,
                    linePrecision: 1,
                    set: function(t, e) {
                        this.ray.set(t, e)
                    },
                    setFromCamera: function(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
                        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(t, e) {
                        var i = [];
                        return rn(t, this, i, e),
                        i.sort(nn),
                        i
                    },
                    intersectObjects: function(t, e) {
                        var i = [];
                        if (Array.isArray(t) === !1)
                            return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                            i;
                        for (var n = 0, r = t.length; n < r; n++)
                            rn(t[n], this, i, e);
                        return i.sort(nn),
                        i
                    }
                },
                an.prototype = {
                    constructor: an,
                    start: function() {
                        this.startTime = (performance || Date).now(),
                        this.oldTime = this.startTime,
                        this.running = !0
                    },
                    stop: function() {
                        this.getElapsedTime(),
                        this.running = !1
                    },
                    getElapsedTime: function() {
                        return this.getDelta(),
                        this.elapsedTime
                    },
                    getDelta: function() {
                        var t = 0;
                        if (this.autoStart && !this.running && this.start(),
                        this.running) {
                            var e = (performance || Date).now();
                            t = (e - this.oldTime) / 1e3,
                            this.oldTime = e,
                            this.elapsedTime += t
                        }
                        return t
                    }
                },
                sn.prototype = {
                    constructor: sn,
                    set: function(t, e, i) {
                        return this.radius = t,
                        this.phi = e,
                        this.theta = i,
                        this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius.copy(t.radius),
                        this.phi.copy(t.phi),
                        this.theta.copy(t.theta),
                        this
                    },
                    makeSafe: function() {
                        var t = 1e-6;
                        return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)),
                        this
                    },
                    setFromVector3: function(t) {
                        return this.radius = t.length(),
                        0 === this.radius ? (this.theta = 0,
                        this.phi = 0) : (this.theta = Math.atan2(t.x, t.z),
                        this.phi = Math.acos(e.Math.clamp(t.y / this.radius, -1, 1))),
                        this
                    }
                },
                ln.prototype = Object.create(re.prototype),
                ln.prototype.constructor = ln,
                ln.prototype.createAnimation = function(t, e, i, n) {
                    var r = {
                        start: e,
                        end: i,
                        length: i - e + 1,
                        fps: n,
                        duration: (i - e) / n,
                        lastFrame: 0,
                        currentFrame: 0,
                        active: !1,
                        time: 0,
                        direction: 1,
                        weight: 1,
                        directionBackwards: !1,
                        mirroredLoop: !1
                    };
                    this.animationsMap[t] = r,
                    this.animationsList.push(r)
                }
                ,
                ln.prototype.autoCreateAnimations = function(t) {
                    for (var e, i = /([a-z]+)_?(\d+)/i, n = {}, r = this.geometry, a = 0, o = r.morphTargets.length; a < o; a++) {
                        var s = r.morphTargets[a]
                          , l = s.name.match(i);
                        if (l && l.length > 1) {
                            var h = l[1];
                            n[h] || (n[h] = {
                                start: 1 / 0,
                                end: -(1 / 0)
                            });
                            var c = n[h];
                            a < c.start && (c.start = a),
                            a > c.end && (c.end = a),
                            e || (e = h)
                        }
                    }
                    for (var h in n) {
                        var c = n[h];
                        this.createAnimation(h, c.start, c.end, t)
                    }
                    this.firstAnimation = e
                }
                ,
                ln.prototype.setAnimationDirectionForward = function(t) {
                    var e = this.animationsMap[t];
                    e && (e.direction = 1,
                    e.directionBackwards = !1)
                }
                ,
                ln.prototype.setAnimationDirectionBackward = function(t) {
                    var e = this.animationsMap[t];
                    e && (e.direction = -1,
                    e.directionBackwards = !0)
                }
                ,
                ln.prototype.setAnimationFPS = function(t, e) {
                    var i = this.animationsMap[t];
                    i && (i.fps = e,
                    i.duration = (i.end - i.start) / i.fps)
                }
                ,
                ln.prototype.setAnimationDuration = function(t, e) {
                    var i = this.animationsMap[t];
                    i && (i.duration = e,
                    i.fps = (i.end - i.start) / i.duration)
                }
                ,
                ln.prototype.setAnimationWeight = function(t, e) {
                    var i = this.animationsMap[t];
                    i && (i.weight = e)
                }
                ,
                ln.prototype.setAnimationTime = function(t, e) {
                    var i = this.animationsMap[t];
                    i && (i.time = e)
                }
                ,
                ln.prototype.getAnimationTime = function(t) {
                    var e = 0
                      , i = this.animationsMap[t];
                    return i && (e = i.time),
                    e
                }
                ,
                ln.prototype.getAnimationDuration = function(t) {
                    var e = -1
                      , i = this.animationsMap[t];
                    return i && (e = i.duration),
                    e
                }
                ,
                ln.prototype.playAnimation = function(t) {
                    var e = this.animationsMap[t];
                    e ? (e.time = 0,
                    e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
                }
                ,
                ln.prototype.stopAnimation = function(t) {
                    var e = this.animationsMap[t];
                    e && (e.active = !1)
                }
                ,
                ln.prototype.update = function(t) {
                    for (var i = 0, n = this.animationsList.length; i < n; i++) {
                        var r = this.animationsList[i];
                        if (r.active) {
                            var a = r.duration / r.length;
                            r.time += r.direction * t,
                            r.mirroredLoop ? (r.time > r.duration || r.time < 0) && (r.direction *= -1,
                            r.time > r.duration && (r.time = r.duration,
                            r.directionBackwards = !0),
                            r.time < 0 && (r.time = 0,
                            r.directionBackwards = !1)) : (r.time = r.time % r.duration,
                            r.time < 0 && (r.time += r.duration));
                            var o = r.start + e.Math.clamp(Math.floor(r.time / a), 0, r.length - 1)
                              , s = r.weight;
                            o !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0,
                            this.morphTargetInfluences[r.currentFrame] = 1 * s,
                            this.morphTargetInfluences[o] = 0,
                            r.lastFrame = r.currentFrame,
                            r.currentFrame = o);
                            var l = r.time % a / a;
                            r.directionBackwards && (l = 1 - l),
                            r.currentFrame !== r.lastFrame ? (this.morphTargetInfluences[r.currentFrame] = l * s,
                            this.morphTargetInfluences[r.lastFrame] = (1 - l) * s) : this.morphTargetInfluences[r.currentFrame] = s
                        }
                    }
                }
                ,
                hn.prototype = Object.create(zt.prototype),
                hn.prototype.constructor = hn,
                hn.prototype.isImmediateRenderObject = !0,
                cn.prototype = Object.create(Ht.prototype),
                cn.prototype.constructor = cn,
                un.prototype = Object.create(Me.prototype),
                un.prototype.constructor = un,
                pn.prototype = Object.create(Me.prototype),
                pn.prototype.constructor = pn,
                pn.prototype.update = function() {
                    var t = new l
                      , e = new l
                      , i = new rt;
                    return function() {
                        var n = ["a", "b", "c"];
                        this.object.updateMatrixWorld(!0),
                        i.getNormalMatrix(this.object.matrixWorld);
                        var r = this.object.matrixWorld
                          , a = this.geometry.attributes.position
                          , o = this.object.geometry;
                        if (o && o.isGeometry)
                            for (var s = o.vertices, l = o.faces, h = 0, c = 0, u = l.length; c < u; c++)
                                for (var p = l[c], d = 0, f = p.vertexNormals.length; d < f; d++) {
                                    var m = s[p[n[d]]]
                                      , g = p.vertexNormals[d];
                                    t.copy(m).applyMatrix4(r),
                                    e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                                    a.setXYZ(h, t.x, t.y, t.z),
                                    h += 1,
                                    a.setXYZ(h, e.x, e.y, e.z),
                                    h += 1
                                }
                        else if (o && o.isBufferGeometry)
                            for (var v = o.attributes.position, _ = o.attributes.normal, h = 0, d = 0, f = v.count; d < f; d++)
                                t.set(v.getX(d), v.getY(d), v.getZ(d)).applyMatrix4(r),
                                e.set(_.getX(d), _.getY(d), _.getZ(d)),
                                e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                                a.setXYZ(h, t.x, t.y, t.z),
                                h += 1,
                                a.setXYZ(h, e.x, e.y, e.z),
                                h += 1;
                        return a.needsUpdate = !0,
                        this
                    }
                }(),
                dn.prototype = Object.create(zt.prototype),
                dn.prototype.constructor = dn,
                dn.prototype.dispose = function() {
                    this.cone.geometry.dispose(),
                    this.cone.material.dispose()
                }
                ,
                dn.prototype.update = function() {
                    var t = new l
                      , e = new l;
                    return function() {
                        var i = this.light.distance ? this.light.distance : 1e3
                          , n = i * Math.tan(this.light.angle);
                        this.cone.scale.set(n, n, i),
                        t.setFromMatrixPosition(this.light.matrixWorld),
                        e.setFromMatrixPosition(this.light.target.matrixWorld),
                        this.cone.lookAt(e.sub(t)),
                        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
                    }
                }(),
                fn.prototype = Object.create(Me.prototype),
                fn.prototype.constructor = fn,
                fn.prototype.getBoneList = function(t) {
                    var e = [];
                    t && t.isBone && e.push(t);
                    for (var i = 0; i < t.children.length; i++)
                        e.push.apply(e, this.getBoneList(t.children[i]));
                    return e
                }
                ,
                fn.prototype.update = function() {
                    for (var t = this.geometry, e = (new o).getInverse(this.root.matrixWorld), i = new o, n = 0, r = 0; r < this.bones.length; r++) {
                        var a = this.bones[r];
                        a.parent && a.parent.isBone && (i.multiplyMatrices(e, a.matrixWorld),
                        t.vertices[n].setFromMatrixPosition(i),
                        i.multiplyMatrices(e, a.parent.matrixWorld),
                        t.vertices[n + 1].setFromMatrixPosition(i),
                        n += 2)
                    }
                    t.verticesNeedUpdate = !0,
                    t.computeBoundingSphere()
                }
                ,
                mn.prototype = Object.create(Ht.prototype),
                mn.prototype.constructor = mn,
                gn.prototype = Object.create(re.prototype),
                gn.prototype.constructor = gn,
                gn.prototype.dispose = function() {
                    this.geometry.dispose(),
                    this.material.dispose()
                }
                ,
                gn.prototype.update = function() {
                    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
                }
                ,
                vn.prototype = Object.create(kt.prototype),
                vn.prototype.constructor = vn,
                _n.prototype = Object.create(zt.prototype),
                _n.prototype.constructor = _n,
                _n.prototype.dispose = function() {
                    this.lightSphere.geometry.dispose(),
                    this.lightSphere.material.dispose()
                }
                ,
                _n.prototype.update = function() {
                    var t = new l;
                    return function() {
                        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
                        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
                        this.lightSphere.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()),
                        this.lightSphere.geometry.colorsNeedUpdate = !0
                    }
                }(),
                yn.prototype = Object.create(Me.prototype),
                yn.prototype.constructor = yn,
                yn.prototype.setColors = function() {
                    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
                }
                ,
                xn.prototype = Object.create(Me.prototype),
                xn.prototype.constructor = xn,
                xn.prototype.update = function() {
                    var t = new l
                      , e = new l
                      , i = new rt;
                    return function() {
                        this.object.updateMatrixWorld(!0),
                        i.getNormalMatrix(this.object.matrixWorld);
                        for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = a.faces, l = 0, h = 0, c = s.length; h < c; h++) {
                            var u = s[h]
                              , p = u.normal;
                            t.copy(o[u.a]).add(o[u.b]).add(o[u.c]).divideScalar(3).applyMatrix4(n),
                            e.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t),
                            r.setXYZ(l, t.x, t.y, t.z),
                            l += 1,
                            r.setXYZ(l, e.x, e.y, e.z),
                            l += 1
                        }
                        return r.needsUpdate = !0,
                        this
                    }
                }(),
                bn.prototype = Object.create(Ht.prototype),
                bn.prototype.constructor = bn,
                wn.prototype = Object.create(Me.prototype),
                wn.prototype.constructor = wn,
                Mn.prototype = Object.create(zt.prototype),
                Mn.prototype.constructor = Mn,
                Mn.prototype.dispose = function() {
                    var t = this.children[0]
                      , e = this.children[1];
                    t.geometry.dispose(),
                    t.material.dispose(),
                    e.geometry.dispose(),
                    e.material.dispose()
                }
                ,
                Mn.prototype.update = function() {
                    var t = new l
                      , e = new l
                      , i = new l;
                    return function() {
                        t.setFromMatrixPosition(this.light.matrixWorld),
                        e.setFromMatrixPosition(this.light.target.matrixWorld),
                        i.subVectors(e, t);
                        var n = this.children[0]
                          , r = this.children[1];
                        n.lookAt(i),
                        n.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
                        r.lookAt(i),
                        r.scale.z = i.length()
                    }
                }(),
                Tn.prototype = Object.create(Me.prototype),
                Tn.prototype.constructor = Tn,
                Tn.prototype.update = function() {
                    function t(t, a, o, s) {
                        n.set(a, o, s).unproject(r);
                        var l = i[t];
                        if (void 0 !== l)
                            for (var h = 0, c = l.length; h < c; h++)
                                e.vertices[l[h]].copy(n)
                    }
                    var e, i, n = new l, r = new oe;
                    return function() {
                        e = this.geometry,
                        i = this.pointMap;
                        var n = 1
                          , a = 1;
                        r.projectionMatrix.copy(this.camera.projectionMatrix),
                        t("c", 0, 0, -1),
                        t("t", 0, 0, 1),
                        t("n1", -n, -a, -1),
                        t("n2", n, -a, -1),
                        t("n3", -n, a, -1),
                        t("n4", n, a, -1),
                        t("f1", -n, -a, 1),
                        t("f2", n, -a, 1),
                        t("f3", -n, a, 1),
                        t("f4", n, a, 1),
                        t("u1", .7 * n, 1.1 * a, -1),
                        t("u2", .7 * -n, 1.1 * a, -1),
                        t("u3", 0, 2 * a, -1),
                        t("cf1", -n, 0, 1),
                        t("cf2", n, 0, 1),
                        t("cf3", 0, -a, 1),
                        t("cf4", 0, a, 1),
                        t("cn1", -n, 0, -1),
                        t("cn2", n, 0, -1),
                        t("cn3", 0, -a, -1),
                        t("cn4", 0, a, -1),
                        e.verticesNeedUpdate = !0
                    }
                }(),
                Sn.prototype = Object.create(kt.prototype),
                Sn.prototype.constructor = Sn,
                En.prototype = Object.create(re.prototype),
                En.prototype.constructor = En,
                En.prototype.update = function() {
                    this.box.setFromObject(this.object),
                    this.box.size(this.scale),
                    this.box.center(this.position)
                }
                ,
                An.prototype = Object.create(Me.prototype),
                An.prototype.constructor = An,
                An.prototype.update = function() {
                    var t = new it;
                    return function(e) {
                        if (e && e.isBox3 ? t.copy(e) : t.setFromObject(e),
                        !t.isEmpty()) {
                            var i = t.min
                              , n = t.max
                              , r = this.geometry.attributes.position
                              , a = r.array;
                            a[0] = n.x,
                            a[1] = n.y,
                            a[2] = n.z,
                            a[3] = i.x,
                            a[4] = n.y,
                            a[5] = n.z,
                            a[6] = i.x,
                            a[7] = i.y,
                            a[8] = n.z,
                            a[9] = n.x,
                            a[10] = i.y,
                            a[11] = n.z,
                            a[12] = n.x,
                            a[13] = n.y,
                            a[14] = i.z,
                            a[15] = i.x,
                            a[16] = n.y,
                            a[17] = i.z,
                            a[18] = i.x,
                            a[19] = i.y,
                            a[20] = i.z,
                            a[21] = n.x,
                            a[22] = i.y,
                            a[23] = i.z,
                            r.needsUpdate = !0,
                            this.geometry.computeBoundingSphere()
                        }
                    }
                }(),
                Pn.prototype = Object.create(Ht.prototype),
                Pn.prototype.constructor = Pn;
                var Gl = new Ht;
                Gl.addAttribute("position", new Ot([0, 0, 0, 0, 1, 0],3));
                var Vl = new Pn(0,.5,1,5,1);
                Vl.translate(0, -.5, 0),
                Rn.prototype = Object.create(zt.prototype),
                Rn.prototype.constructor = Rn,
                Rn.prototype.setDirection = function() {
                    var t, e = new l;
                    return function(i) {
                        i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(),
                        t = Math.acos(i.y),
                        this.quaternion.setFromAxisAngle(e, t))
                    }
                }(),
                Rn.prototype.setLength = function(t, e, i) {
                    void 0 === e && (e = .2 * t),
                    void 0 === i && (i = .2 * e),
                    this.line.scale.set(1, Math.max(0, t - e), 1),
                    this.line.updateMatrix(),
                    this.cone.scale.set(i, e, i),
                    this.cone.position.y = t,
                    this.cone.updateMatrix()
                }
                ,
                Rn.prototype.setColor = function(t) {
                    this.line.material.color.copy(t),
                    this.cone.material.color.copy(t)
                }
                ,
                Ln.prototype = Object.create(Me.prototype),
                Ln.prototype.constructor = Ln,
                Cn.prototype = Object.create(kt.prototype),
                Cn.prototype.constructor = Cn,
                On.prototype = Object.create(kt.prototype),
                On.prototype.constructor = On,
                In.prototype = Object.create(On.prototype),
                In.prototype.constructor = In,
                Dn.prototype = Object.create(On.prototype),
                Dn.prototype.constructor = Dn,
                Un.prototype = Object.create(On.prototype),
                Un.prototype.constructor = Un,
                Fn.prototype = Object.create(On.prototype),
                Fn.prototype.constructor = Fn,
                Nn.prototype = Object.create(Ht.prototype),
                Nn.prototype.constructor = Nn,
                zn.prototype = Object.create(kt.prototype),
                zn.prototype.constructor = zn,
                Bn.prototype = Object.create(Ht.prototype),
                Bn.prototype.constructor = Bn,
                kn.prototype = Object.create(kt.prototype),
                kn.prototype.constructor = kn,
                Gn.prototype = Object.create(Ri.prototype),
                Gn.prototype.constructor = Gn,
                Vn.prototype = Object.create(Ht.prototype),
                Vn.prototype.constructor = Vn,
                Hn.prototype = Object.create(kt.prototype),
                Hn.prototype.constructor = Hn,
                jn.prototype = Object.create(kt.prototype),
                jn.prototype.constructor = jn,
                Wn.prototype = Object.create(Ht.prototype),
                Wn.prototype.constructor = Wn,
                Xn.prototype = Object.create(kt.prototype),
                Xn.prototype.constructor = Xn,
                Yn.prototype = Object.create(kt.prototype),
                Yn.prototype.constructor = Yn,
                qn.prototype = Object.create(Yn.prototype),
                qn.prototype.constructor = qn,
                Zn.prototype = Object.create(Ht.prototype),
                Zn.prototype.constructor = Zn,
                Qn.prototype = Object.create(Ht.prototype),
                Qn.prototype.constructor = Qn,
                Jn.prototype = Object.create(kt.prototype),
                Jn.prototype.constructor = Jn,
                e.CatmullRomCurve3 = function() {
                    function t() {}
                    var e = new l
                      , i = new t
                      , n = new t
                      , r = new t;
                    return t.prototype.init = function(t, e, i, n) {
                        this.c0 = t,
                        this.c1 = i,
                        this.c2 = -3 * t + 3 * e - 2 * i - n,
                        this.c3 = 2 * t - 2 * e + i + n
                    }
                    ,
                    t.prototype.initNonuniformCatmullRom = function(t, e, i, n, r, a, o) {
                        var s = (e - t) / r - (i - t) / (r + a) + (i - e) / a
                          , l = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                        s *= a,
                        l *= a,
                        this.init(e, i, s, l)
                    }
                    ,
                    t.prototype.initCatmullRom = function(t, e, i, n, r) {
                        this.init(e, i, r * (i - t), r * (n - e))
                    }
                    ,
                    t.prototype.calc = function(t) {
                        var e = t * t
                          , i = e * t;
                        return this.c0 + this.c1 * t + this.c2 * e + this.c3 * i
                    }
                    ,
                    bi.create(function(t) {
                        this.points = t || [],
                        this.closed = !1
                    }, function(t) {
                        var a, o, s, h, c = this.points;
                        h = c.length,
                        h < 2 && console.log("duh, you need at least 2 points"),
                        a = (h - (this.closed ? 0 : 1)) * t,
                        o = Math.floor(a),
                        s = a - o,
                        this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / c.length) + 1) * c.length : 0 === s && o === h - 1 && (o = h - 2,
                        s = 1);
                        var u, p, d, f;
                        if (this.closed || o > 0 ? u = c[(o - 1) % h] : (e.subVectors(c[0], c[1]).add(c[0]),
                        u = e),
                        p = c[o % h],
                        d = c[(o + 1) % h],
                        this.closed || o + 2 < h ? f = c[(o + 2) % h] : (e.subVectors(c[h - 1], c[h - 2]).add(c[h - 1]),
                        f = e),
                        void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                            var m = "chordal" === this.type ? .5 : .25
                              , g = Math.pow(u.distanceToSquared(p), m)
                              , v = Math.pow(p.distanceToSquared(d), m)
                              , _ = Math.pow(d.distanceToSquared(f), m);
                            v < 1e-4 && (v = 1),
                            g < 1e-4 && (g = v),
                            _ < 1e-4 && (_ = v),
                            i.initNonuniformCatmullRom(u.x, p.x, d.x, f.x, g, v, _),
                            n.initNonuniformCatmullRom(u.y, p.y, d.y, f.y, g, v, _),
                            r.initNonuniformCatmullRom(u.z, p.z, d.z, f.z, g, v, _)
                        } else if ("catmullrom" === this.type) {
                            var y = void 0 !== this.tension ? this.tension : .5;
                            i.initCatmullRom(u.x, p.x, d.x, f.x, y),
                            n.initCatmullRom(u.y, p.y, d.y, f.y, y),
                            r.initCatmullRom(u.z, p.z, d.z, f.z, y)
                        }
                        var x = new l(i.calc(s),n.calc(s),r.calc(s));
                        return x
                    })
                }(),
                Kn.prototype = Object.create(e.CatmullRomCurve3.prototype);
                var Hl = bi.create(function(t) {
                    console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"),
                    this.points = void 0 === t ? [] : t
                }, function(t) {
                    var i = this.points
                      , n = (i.length - 1) * t
                      , r = Math.floor(n)
                      , a = n - r
                      , o = i[0 == r ? r : r - 1]
                      , s = i[r]
                      , h = i[r > i.length - 2 ? i.length - 1 : r + 1]
                      , c = i[r > i.length - 3 ? i.length - 1 : r + 2]
                      , u = e.CurveUtils.interpolate;
                    return new l(u(o.x, s.x, h.x, c.x, a),u(o.y, s.y, h.y, c.y, a),u(o.z, s.z, h.z, c.z, a))
                });
                e.CubicBezierCurve3 = bi.create(function(t, e, i, n) {
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = i,
                    this.v3 = n
                }, function(t) {
                    var i = e.ShapeUtils.b3;
                    return new l(i(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x),i(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y),i(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
                }),
                e.QuadraticBezierCurve3 = bi.create(function(t, e, i) {
                    this.v0 = t,
                    this.v1 = e,
                    this.v2 = i
                }, function(t) {
                    var i = e.ShapeUtils.b2;
                    return new l(i(t, this.v0.x, this.v1.x, this.v2.x),i(t, this.v0.y, this.v1.y, this.v2.y),i(t, this.v0.z, this.v1.z, this.v2.z))
                }),
                e.LineCurve3 = bi.create(function(t, e) {
                    this.v1 = t,
                    this.v2 = e
                }, function(t) {
                    if (1 === t)
                        return this.v2.clone();
                    var e = new l;
                    return e.subVectors(this.v2, this.v1),
                    e.multiplyScalar(t),
                    e.add(this.v1),
                    e
                }),
                $n.prototype = Object.create(Ti.prototype),
                $n.prototype.constructor = $n,
                e.SceneUtils = {
                    createMultiMaterialObject: function(t, e) {
                        for (var i = new Ee, n = 0, r = e.length; n < r; n++)
                            i.add(new re(t,e[n]));
                        return i
                    },
                    detach: function(t, e, i) {
                        t.applyMatrix(e.matrixWorld),
                        e.remove(t),
                        i.add(t)
                    },
                    attach: function(t, e, i) {
                        var n = new o;
                        n.getInverse(i.matrixWorld),
                        t.applyMatrix(n),
                        e.remove(t),
                        i.add(t)
                    }
                };
                var jl = 0
                  , Wl = 1;
                Object.assign(c.prototype, {
                    empty: function() {
                        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                    },
                    isIntersectionBox: function(t) {
                        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(t)
                    }
                }),
                Object.assign(it.prototype, {
                    empty: function() {
                        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
                        this.isEmpty()
                    },
                    isIntersectionBox: function(t) {
                        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(t)
                    },
                    isIntersectionSphere: function(t) {
                        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                        this.intersectsSphere(t)
                    }
                }),
                Object.assign(rt.prototype, {
                    multiplyVector3: function(t) {
                        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
                        t.applyMatrix3(this)
                    },
                    multiplyVector3Array: function(t) {
                        return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                        this.applyToVector3Array(t)
                    }
                }),
                Object.assign(o.prototype, {
                    extractPosition: function(t) {
                        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
                        this.copyPosition(t)
                    },
                    setRotationFromQuaternion: function(t) {
                        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
                        this.makeRotationFromQuaternion(t)
                    },
                    multiplyVector3: function(t) {
                        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."),
                        t.applyProjection(this)
                    },
                    multiplyVector4: function(t) {
                        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        t.applyMatrix4(this)
                    },
                    multiplyVector3Array: function(t) {
                        return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
                        this.applyToVector3Array(t)
                    },
                    rotateAxis: function(t) {
                        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
                        t.transformDirection(this)
                    },
                    crossVector: function(t) {
                        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
                        t.applyMatrix4(this)
                    },
                    translate: function(t) {
                        console.error("THREE.Matrix4: .translate() has been removed.")
                    },
                    rotateX: function(t) {
                        console.error("THREE.Matrix4: .rotateX() has been removed.")
                    },
                    rotateY: function(t) {
                        console.error("THREE.Matrix4: .rotateY() has been removed.")
                    },
                    rotateZ: function(t) {
                        console.error("THREE.Matrix4: .rotateZ() has been removed.")
                    },
                    rotateByAxis: function(t, e) {
                        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                    }
                }),
                Object.assign(at.prototype, {
                    isIntersectionLine: function(t) {
                        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
                        this.intersectsLine(t)
                    }
                }),
                Object.assign(s.prototype, {
                    multiplyVector3: function(t) {
                        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
                        t.applyQuaternion(this)
                    }
                }),
                Object.assign(te.prototype, {
                    isIntersectionBox: function(t) {
                        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
                        this.intersectsBox(t)
                    },
                    isIntersectionPlane: function(t) {
                        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
                        this.intersectsPlane(t)
                    },
                    isIntersectionSphere: function(t) {
                        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
                        this.intersectsSphere(t)
                    }
                }),
                Object.assign(l.prototype, {
                    setEulerFromRotationMatrix: function() {
                        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                    },
                    setEulerFromQuaternion: function() {
                        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                    },
                    getPositionFromMatrix: function(t) {
                        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
                        this.setFromMatrixPosition(t)
                    },
                    getScaleFromMatrix: function(t) {
                        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
                        this.setFromMatrixScale(t)
                    },
                    getColumnFromMatrix: function(t, e) {
                        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
                        this.setFromMatrixColumn(e, t)
                    }
                }),
                Object.assign(zt.prototype, {
                    getChildByName: function(t) {
                        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
                        this.getObjectByName(t)
                    },
                    renderDepth: function(t) {
                        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                    },
                    translate: function(t, e) {
                        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
                        this.translateOnAxis(e, t)
                    }
                }),
                Object.defineProperties(zt.prototype, {
                    eulerOrder: {
                        get: function() {
                            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order
                        },
                        set: function(t) {
                            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                            this.rotation.order = t
                        }
                    },
                    useQuaternion: {
                        get: function() {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        },
                        set: function(t) {
                            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                        }
                    }
                }),
                Object.defineProperties(ge.prototype, {
                    objects: {
                        get: function() {
                            return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                            this.levels
                        }
                    }
                }),
                se.prototype.setLens = function(t, e) {
                    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
                    void 0 !== e && (this.filmGauge = e),
                    this.setFocalLength(t)
                }
                ,
                Object.defineProperties(Ye.prototype, {
                    onlyShadow: {
                        set: function(t) {
                            console.warn("THREE.Light: .onlyShadow has been removed.")
                        }
                    },
                    shadowCameraFov: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                            this.shadow.camera.fov = t
                        }
                    },
                    shadowCameraLeft: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                            this.shadow.camera.left = t
                        }
                    },
                    shadowCameraRight: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                            this.shadow.camera.right = t
                        }
                    },
                    shadowCameraTop: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                            this.shadow.camera.top = t
                        }
                    },
                    shadowCameraBottom: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                            this.shadow.camera.bottom = t
                        }
                    },
                    shadowCameraNear: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                            this.shadow.camera.near = t
                        }
                    },
                    shadowCameraFar: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                            this.shadow.camera.far = t
                        }
                    },
                    shadowCameraVisible: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                        }
                    },
                    shadowBias: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                            this.shadow.bias = t
                        }
                    },
                    shadowDarkness: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowDarkness has been removed.")
                        }
                    },
                    shadowMapWidth: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                            this.shadow.mapSize.width = t
                        }
                    },
                    shadowMapHeight: {
                        set: function(t) {
                            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                            this.shadow.mapSize.height = t
                        }
                    }
                }),
                Object.defineProperties(Tt.prototype, {
                    length: {
                        get: function() {
                            return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
                            this.array.length
                        }
                    }
                }),
                Object.assign(Ht.prototype, {
                    addIndex: function(t) {
                        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
                        this.setIndex(t)
                    },
                    addDrawCall: function(t, e, i) {
                        void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
                        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
                        this.addGroup(t, e)
                    },
                    clearDrawCalls: function() {
                        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
                        this.clearGroups()
                    },
                    computeTangents: function() {
                        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                    },
                    computeOffsets: function() {
                        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                    }
                }),
                Object.defineProperties(Ht.prototype, {
                    drawcalls: {
                        get: function() {
                            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                            this.groups
                        }
                    },
                    offsets: {
                        get: function() {
                            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                            this.groups
                        }
                    }
                }),
                Object.defineProperties(J.prototype, {
                    wrapAround: {
                        get: function() {
                            console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                        },
                        set: function(t) {
                            console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                        }
                    },
                    wrapRGB: {
                        get: function() {
                            return console.warn("THREE." + this.type + ": .wrapRGB has been removed."),
                            new tt
                        }
                    }
                }),
                Object.defineProperties(Fe.prototype, {
                    metal: {
                        get: function() {
                            return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                            !1
                        },
                        set: function(t) {
                            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                        }
                    }
                }),
                Object.defineProperties($.prototype, {
                    derivatives: {
                        get: function() {
                            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                            this.extensions.derivatives
                        },
                        set: function(t) {
                            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                            this.extensions.derivatives = t
                        }
                    }
                }),
                i.prototype = Object.assign(Object.create({
                    constructor: i,
                    apply: function(t) {
                        console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."),
                        Object.assign(t, this)
                    }
                }), i.prototype),
                Object.assign(he.prototype, {
                    supportsFloatTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
                        this.extensions.get("OES_texture_float")
                    },
                    supportsHalfFloatTextures: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
                        this.extensions.get("OES_texture_half_float")
                    },
                    supportsStandardDerivatives: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
                        this.extensions.get("OES_standard_derivatives")
                    },
                    supportsCompressedTextureS3TC: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
                        this.extensions.get("WEBGL_compressed_texture_s3tc")
                    },
                    supportsCompressedTexturePVRTC: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
                        this.extensions.get("WEBGL_compressed_texture_pvrtc")
                    },
                    supportsBlendMinMax: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
                        this.extensions.get("EXT_blend_minmax")
                    },
                    supportsVertexTextures: function() {
                        return this.capabilities.vertexTextures
                    },
                    supportsInstancedArrays: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
                        this.extensions.get("ANGLE_instanced_arrays")
                    },
                    enableScissorTest: function(t) {
                        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
                        this.setScissorTest(t)
                    },
                    initMaterial: function() {
                        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                    },
                    addPrePlugin: function() {
                        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                    },
                    addPostPlugin: function() {
                        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                    },
                    updateShadowMap: function() {
                        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                    }
                }),
                Object.defineProperties(he.prototype, {
                    shadowMapEnabled: {
                        get: function() {
                            return this.shadowMap.enabled
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                            this.shadowMap.enabled = t
                        }
                    },
                    shadowMapType: {
                        get: function() {
                            return this.shadowMap.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                            this.shadowMap.type = t
                        }
                    },
                    shadowMapCullFace: {
                        get: function() {
                            return this.shadowMap.cullFace
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
                            this.shadowMap.cullFace = t
                        }
                    }
                }),
                Object.defineProperties(st.prototype, {
                    cullFace: {
                        get: function() {
                            return this.renderReverseSided ? dr : pr
                        },
                        set: function(t) {
                            var e = t !== pr;
                            console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."),
                            this.renderReverseSided = e
                        }
                    }
                }),
                Object.defineProperties(Q.prototype, {
                    wrapS: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                            this.texture.wrapS
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                            this.texture.wrapS = t
                        }
                    },
                    wrapT: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                            this.texture.wrapT
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                            this.texture.wrapT = t
                        }
                    },
                    magFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                            this.texture.magFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                            this.texture.magFilter = t
                        }
                    },
                    minFilter: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                            this.texture.minFilter
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                            this.texture.minFilter = t
                        }
                    },
                    anisotropy: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                            this.texture.anisotropy
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                            this.texture.anisotropy = t
                        }
                    },
                    offset: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                            this.texture.offset
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                            this.texture.offset = t
                        }
                    },
                    repeat: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                            this.texture.repeat
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                            this.texture.repeat = t
                        }
                    },
                    format: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                            this.texture.format
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                            this.texture.format = t
                        }
                    },
                    type: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                            this.texture.type
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                            this.texture.type = t
                        }
                    },
                    generateMipmaps: {
                        get: function() {
                            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                            this.texture.generateMipmaps
                        },
                        set: function(t) {
                            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                            this.texture.generateMipmaps = t
                        }
                    }
                }),
                Object.assign(Gi.prototype, {
                    load: function(t) {
                        console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
                        var e = this
                          , i = new Ni;
                        return i.load(t, function(t) {
                            e.setBuffer(t)
                        }),
                        this
                    }
                }),
                Object.assign(Hi.prototype, {
                    getData: function(t) {
                        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
                        this.getFrequencyData()
                    }
                });
                var Xl = {
                    merge: function(t, e, i) {
                        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                        var n;
                        e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(),
                        n = e.matrix,
                        e = e.geometry),
                        t.merge(e, n, i)
                    },
                    center: function(t) {
                        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
                        t.center()
                    }
                }
                  , Yl = {
                    crossOrigin: void 0,
                    loadTexture: function(t, e, i, n) {
                        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                        var r = new Xe;
                        r.setCrossOrigin(this.crossOrigin);
                        var a = r.load(t, i, void 0, n);
                        return e && (a.mapping = e),
                        a
                    },
                    loadTextureCube: function(t, e, i, n) {
                        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                        var r = new We;
                        r.setCrossOrigin(this.crossOrigin);
                        var a = r.load(t, i, void 0, n);
                        return e && (a.mapping = e),
                        a
                    },
                    loadCompressedTexture: function() {
                        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                    },
                    loadCompressedTextureCube: function() {
                        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                    }
                };
                Object.defineProperty(e, "AudioContext", {
                    get: function() {
                        return e.getAudioContext()
                    }
                }),
                e.SpritePlugin = h,
                e.LensFlarePlugin = u,
                e.WebGLUniforms = X,
                e.WebGLTextures = Y,
                e.WebGLState = Z,
                e.WebGLShadowMap = st,
                e.WebGLShader = ht,
                e.WebGLProperties = ct,
                e.WebGLPrograms = Mt,
                e.WebGLProgram = wt,
                e.WebGLObjects = Wt,
                e.WebGLLights = Xt,
                e.WebGLGeometries = jt,
                e.WebGLCapabilities = Yt,
                e.WebGLExtensions = qt,
                e.WebGLIndexedBufferRenderer = Zt,
                e.WebGLClipping = Qt,
                e.WebGLBufferRenderer = Jt,
                e.WebGLRenderTargetCube = Kt,
                e.WebGLRenderTarget = Q,
                e.WebGLRenderer = he,
                e.ShaderLib = Il,
                e.UniformsLib = Ol,
                e.ShaderChunk = Cl,
                e.FogExp2 = ce,
                e.Fog = ue,
                e.Scene = pe,
                e.LensFlare = de,
                e.Sprite = me,
                e.LOD = ge,
                e.SkinnedMesh = xe,
                e.Skeleton = _e,
                e.Bone = ye,
                e.Mesh = re,
                e.LineSegments = Me,
                e.Line = we,
                e.Points = Se,
                e.Group = Ee,
                e.VideoTexture = Ae,
                e.DataTexture = ve,
                e.CompressedTexture = Pe,
                e.CubeTexture = p,
                e.CanvasTexture = Re,
                e.DepthTexture = Le,
                e.TextureIdCount = a,
                e.Texture = r,
                e.ShadowMaterial = Ce,
                e.SpriteMaterial = fe,
                e.RawShaderMaterial = Oe,
                e.ShaderMaterial = $,
                e.PointsMaterial = Te,
                e.MultiMaterial = Ie,
                e.MeshPhysicalMaterial = Ue,
                e.MeshStandardMaterial = De,
                e.MeshPhongMaterial = Fe,
                e.MeshNormalMaterial = Ne,
                e.MeshLambertMaterial = ze,
                e.MeshDepthMaterial = et,
                e.MeshBasicMaterial = ne,
                e.LineDashedMaterial = Be,
                e.LineBasicMaterial = be,
                e.MaterialIdCount = K,
                e.Material = J,
                e.CompressedTextureLoader = Ve,
                e.BinaryTextureLoader = He,
                e.DataTextureLoader = Nl,
                e.CubeTextureLoader = We,
                e.TextureLoader = Xe,
                e.ObjectLoader = xi,
                e.MaterialLoader = gi,
                e.BufferGeometryLoader = vi,
                e.LoadingManager = ke,
                e.JSONLoader = yi,
                e.ImageLoader = je,
                e.FontLoader = Ui,
                e.XHRLoader = Ge,
                e.Loader = _i,
                e.AudioLoader = Ni,
                e.SpotLightShadow = Qe,
                e.SpotLight = Je,
                e.PointLight = Ke,
                e.HemisphereLight = qe,
                e.DirectionalLightShadow = $e,
                e.DirectionalLight = ti,
                e.AmbientLight = ei,
                e.LightShadow = Ze,
                e.Light = Ye,
                e.StereoCamera = zi,
                e.PerspectiveCamera = se,
                e.OrthographicCamera = le,
                e.CubeCamera = Bi,
                e.Camera = oe,
                e.AudioListener = ki,
                e.PositionalAudio = Vi,
                e.getAudioContext = Fi,
                e.AudioAnalyser = Hi,
                e.Audio = Gi,
                e.VectorKeyframeTrack = si,
                e.StringKeyframeTrack = ui,
                e.QuaternionKeyframeTrack = hi,
                e.NumberKeyframeTrack = ci,
                e.ColorKeyframeTrack = di,
                e.BooleanKeyframeTrack = pi,
                e.PropertyMixer = ji,
                e.PropertyBinding = Wi,
                e.KeyframeTrack = fi,
                e.AnimationObjectGroup = Xi,
                e.AnimationMixer = qi,
                e.AnimationClip = mi,
                e.Uniform = Zi,
                e.InstancedBufferGeometry = Qi,
                e.BufferGeometry = Ht,
                e.DirectGeometry = Vt,
                e.GeometryIdCount = Gt,
                e.Geometry = kt,
                e.InterleavedBufferAttribute = Ji,
                e.InstancedInterleavedBuffer = $i,
                e.InterleavedBuffer = Ki,
                e.InstancedBufferAttribute = tn,
                e.DynamicBufferAttribute = Dt,
                e.Float64Attribute = It,
                e.Float32Attribute = Ot,
                e.Uint32Attribute = Ct,
                e.Int32Attribute = Lt,
                e.Uint16Attribute = Rt,
                e.Int16Attribute = Pt,
                e.Uint8ClampedAttribute = At,
                e.Uint8Attribute = Et,
                e.Int8Attribute = St,
                e.BufferAttribute = Tt,
                e.Face3 = Ut,
                e.Object3DIdCount = Bt,
                e.Object3D = zt,
                e.Raycaster = en,
                e.Layers = Nt,
                e.EventDispatcher = i,
                e.Clock = an,
                e.QuaternionLinearInterpolant = li,
                e.LinearInterpolant = ri,
                e.DiscreteInterpolant = ai,
                e.CubicInterpolant = ni,
                e.Interpolant = ii,
                e.Triangle = ie,
                e.Spline = on,
                e.Spherical = sn,
                e.Plane = at,
                e.Frustum = ot,
                e.Sphere = nt,
                e.Ray = te,
                e.Matrix4 = o,
                e.Matrix3 = rt,
                e.Box3 = it,
                e.Box2 = c,
                e.Line3 = ee,
                e.Euler = Ft,
                e.Vector4 = q,
                e.Vector3 = l,
                e.Vector2 = n,
                e.Quaternion = s,
                e.Color = tt,
                e.MorphBlendMesh = ln,
                e.ImmediateRenderObject = hn,
                e.WireframeHelper = un,
                e.VertexNormalsHelper = pn,
                e.SpotLightHelper = dn,
                e.SkeletonHelper = fn,
                e.PointLightHelper = gn,
                e.HemisphereLightHelper = _n,
                e.GridHelper = yn,
                e.FaceNormalsHelper = xn,
                e.EdgesHelper = wn,
                e.DirectionalLightHelper = Mn,
                e.CameraHelper = Tn,
                e.BoundingBoxHelper = En,
                e.BoxHelper = An,
                e.ArrowHelper = Rn,
                e.AxisHelper = Ln,
                e.WireframeGeometry = cn,
                e.ParametricGeometry = Cn,
                e.TetrahedronGeometry = In,
                e.OctahedronGeometry = Dn,
                e.IcosahedronGeometry = Un,
                e.DodecahedronGeometry = Fn,
                e.PolyhedronGeometry = On,
                e.TubeGeometry = Pi,
                e.TorusKnotGeometry = zn,
                e.TorusKnotBufferGeometry = Nn,
                e.TorusGeometry = kn,
                e.TorusBufferGeometry = Bn,
                e.TextGeometry = Gn,
                e.SphereBufferGeometry = mn,
                e.SphereGeometry = vn,
                e.RingGeometry = Hn,
                e.RingBufferGeometry = Vn,
                e.PlaneBufferGeometry = ae,
                e.PlaneGeometry = jn,
                e.LatheGeometry = Xn,
                e.LatheBufferGeometry = Wn,
                e.ShapeGeometry = Li;
                e.ExtrudeGeometry = Ri;
                e.EdgesGeometry = bn,
                e.ConeGeometry = qn,
                e.ConeBufferGeometry = Zn,
                e.CylinderGeometry = Yn,
                e.CylinderBufferGeometry = Pn,
                e.CircleBufferGeometry = Qn,
                e.CircleGeometry = Jn,
                e.BoxBufferGeometry = $t,
                e.BoxGeometry = Sn,
                e.ClosedSplineCurve3 = Kn,
                e.SplineCurve3 = Hl,
                e.ArcCurve = $n,
                e.EllipseCurve = Ti,
                e.SplineCurve = Si,
                e.CubicBezierCurve = Ei,
                e.QuadraticBezierCurve = Ai,
                e.LineCurve = wi,
                e.Shape = Ci,
                e.ShapePath = Ii,
                e.Path = Oi,
                e.Font = Di,
                e.CurvePath = Mi,
                e.Curve = bi,
                e.REVISION = hr,
                e.MOUSE = cr,
                e.CullFaceNone = ur,
                e.CullFaceBack = pr,
                e.CullFaceFront = dr,
                e.CullFaceFrontBack = fr,
                e.FrontFaceDirectionCW = mr,
                e.FrontFaceDirectionCCW = gr,
                e.BasicShadowMap = vr,
                e.PCFShadowMap = _r,
                e.PCFSoftShadowMap = yr,
                e.FrontSide = xr,
                e.BackSide = br,
                e.DoubleSide = wr,
                e.FlatShading = Mr,
                e.SmoothShading = Tr,
                e.NoColors = Sr,
                e.FaceColors = Er,
                e.VertexColors = Ar,
                e.NoBlending = Pr,
                e.NormalBlending = Rr,
                e.AdditiveBlending = Lr,
                e.SubtractiveBlending = Cr,
                e.MultiplyBlending = Or,
                e.CustomBlending = Ir,
                e.AddEquation = Dr,
                e.SubtractEquation = Ur,
                e.ReverseSubtractEquation = Fr,
                e.MinEquation = Nr,
                e.MaxEquation = zr,
                e.ZeroFactor = Br,
                e.OneFactor = kr,
                e.SrcColorFactor = Gr,
                e.OneMinusSrcColorFactor = Vr,
                e.SrcAlphaFactor = Hr,
                e.OneMinusSrcAlphaFactor = jr,
                e.DstAlphaFactor = Wr,
                e.OneMinusDstAlphaFactor = Xr,
                e.DstColorFactor = Yr,
                e.OneMinusDstColorFactor = qr,
                e.SrcAlphaSaturateFactor = Zr,
                e.NeverDepth = Qr,
                e.AlwaysDepth = Jr,
                e.LessDepth = Kr,
                e.LessEqualDepth = $r,
                e.EqualDepth = ta,
                e.GreaterEqualDepth = ea,
                e.GreaterDepth = ia,
                e.NotEqualDepth = na,
                e.MultiplyOperation = ra,
                e.MixOperation = aa,
                e.AddOperation = oa,
                e.NoToneMapping = sa,
                e.LinearToneMapping = la,
                e.ReinhardToneMapping = ha,
                e.Uncharted2ToneMapping = ca,
                e.CineonToneMapping = ua,
                e.UVMapping = pa,
                e.CubeReflectionMapping = da,
                e.CubeRefractionMapping = fa,
                e.EquirectangularReflectionMapping = ma,
                e.EquirectangularRefractionMapping = ga,
                e.SphericalReflectionMapping = va,
                e.CubeUVReflectionMapping = _a,
                e.CubeUVRefractionMapping = ya,
                e.RepeatWrapping = xa,
                e.ClampToEdgeWrapping = ba,
                e.MirroredRepeatWrapping = wa,
                e.NearestFilter = Ma,
                e.NearestMipMapNearestFilter = Ta,
                e.NearestMipMapLinearFilter = Sa,
                e.LinearFilter = Ea,
                e.LinearMipMapNearestFilter = Aa,
                e.LinearMipMapLinearFilter = Pa,
                e.UnsignedByteType = Ra,
                e.ByteType = La,
                e.ShortType = Ca,
                e.UnsignedShortType = Oa,
                e.IntType = Ia,
                e.UnsignedIntType = Da,
                e.FloatType = Ua,
                e.HalfFloatType = Fa,
                e.UnsignedShort4444Type = Na,
                e.UnsignedShort5551Type = za,
                e.UnsignedShort565Type = Ba,
                e.UnsignedInt248Type = ka,
                e.AlphaFormat = Ga,
                e.RGBFormat = Va,
                e.RGBAFormat = Ha,
                e.LuminanceFormat = ja,
                e.LuminanceAlphaFormat = Wa,
                e.RGBEFormat = Xa,
                e.DepthFormat = Ya,
                e.DepthStencilFormat = qa,
                e.RGB_S3TC_DXT1_Format = Za,
                e.RGBA_S3TC_DXT1_Format = Qa,
                e.RGBA_S3TC_DXT3_Format = Ja,
                e.RGBA_S3TC_DXT5_Format = Ka,
                e.RGB_PVRTC_4BPPV1_Format = $a,
                e.RGB_PVRTC_2BPPV1_Format = to,
                e.RGBA_PVRTC_4BPPV1_Format = eo,
                e.RGBA_PVRTC_2BPPV1_Format = io,
                e.RGB_ETC1_Format = no,
                e.LoopOnce = ro,
                e.LoopRepeat = ao,
                e.LoopPingPong = oo,
                e.InterpolateDiscrete = so,
                e.InterpolateLinear = lo,
                e.InterpolateSmooth = ho,
                e.ZeroCurvatureEnding = co,
                e.ZeroSlopeEnding = uo,
                e.WrapAroundEnding = po,
                e.TrianglesDrawMode = fo,
                e.TriangleStripDrawMode = mo,
                e.TriangleFanDrawMode = go,
                e.LinearEncoding = vo,
                e.sRGBEncoding = _o,
                e.GammaEncoding = yo,
                e.RGBEEncoding = xo,
                e.LogLuvEncoding = bo,
                e.RGBM7Encoding = wo,
                e.RGBM16Encoding = Mo,
                e.RGBDEncoding = To,
                e.BasicDepthPacking = So,
                e.RGBADepthPacking = Eo,
                e.CubeGeometry = Sn,
                e.Face4 = tr,
                e.LineStrip = jl,
                e.LinePieces = Wl,
                e.MeshFaceMaterial = Ie,
                e.PointCloud = er,
                e.Particle = me,
                e.ParticleSystem = ir,
                e.PointCloudMaterial = nr,
                e.ParticleBasicMaterial = rr,
                e.ParticleSystemMaterial = ar,
                e.Vertex = or,
                e.GeometryUtils = Xl,
                e.ImageUtils = Yl,
                e.Projector = sr,
                e.CanvasRenderer = lr,
                Object.defineProperty(e, "__esModule", {
                    value: !0
                })
            })
        }
        ).call(e, i(n))
    }
}));
